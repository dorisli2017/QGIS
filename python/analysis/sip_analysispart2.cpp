/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPI_analysis.h"

#line 17 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsgridfilewriter.sip"
#include "qgsgridfilewriter.h"
#line 12 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 16 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "core/auto_generated/geometry/qgsrectangle.sip"
#include "qgsrectangle.h"
#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 25 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsGridFileWriter_writeFile, "writeFile(self, feedback: QgsFeedback = None) -> int\n"
"Writes the grid file.\n"
"\n"
"An optional ``feedback`` object can be set for progress reports and cancellation support\n"
"\n"
":return: 0 in case of success");

extern "C" {static PyObject *meth_QgsGridFileWriter_writeFile(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGridFileWriter_writeFile(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
         ::QgsGridFileWriter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsGridFileWriter, &sipCpp, sipType_QgsFeedback, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->writeFile(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGridFileWriter, sipName_writeFile, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGridFileWriter(void *, int);}
static void release_QgsGridFileWriter(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGridFileWriter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGridFileWriter(sipSimpleWrapper *);}
static void dealloc_QgsGridFileWriter(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGridFileWriter(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGridFileWriter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGridFileWriter(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGridFileWriter *sipCpp = 0;

    {
         ::QgsInterpolator* a0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QgsRectangle* a2;
        int a3;
        int a4;

        static const char *sipKwdList[] = {
            sipName_interpolator,
            sipName_outputPath,
            sipName_extent,
            sipName_nCols,
            sipName_nRows,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J1J9ii", sipType_QgsInterpolator, &a0, sipType_QString,&a1, &a1State, sipType_QgsRectangle, &a2, &a3, &a4))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGridFileWriter(a0,*a1,*a2,a3,a4);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            return sipCpp;
        }
    }

    {
        const  ::QgsGridFileWriter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGridFileWriter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGridFileWriter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGridFileWriter[] = {
    {SIP_MLNAME_CAST(sipName_writeFile), (PyCFunction)meth_QgsGridFileWriter_writeFile, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGridFileWriter_writeFile)}
};

PyDoc_STRVAR(doc_QgsGridFileWriter, "QgsGridFileWriter(interpolator: QgsInterpolator, outputPath: str, extent: QgsRectangle, nCols: int, nRows: int)\n"
"Constructor for QgsGridFileWriter, for the specified ``interpolator``.\n"
"\n"
"The ``outputPath`` argument is used to set the output file path.\n"
"\n"
"The ``extent`` and ``nCols``, ``nRows`` arguments dictate the extent and size of the output raster.\n"
"\n"
"QgsGridFileWriter(QgsGridFileWriter)");


static pyqt5ClassPluginDef plugin_QgsGridFileWriter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGridFileWriter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGridFileWriter,
        {0},
        &plugin_QgsGridFileWriter
    },
    {
        sipNameNr_QgsGridFileWriter,
        {0, 0, 1},
        1, methods_QgsGridFileWriter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGridFileWriter,
    -1,
    -1,
    0,
    0,
    init_type_QgsGridFileWriter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGridFileWriter,
    0,
    0,
    0,
    release_QgsGridFileWriter,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 245 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 22 "core/auto_generated/qgsfeaturesource.sip"
#include "qgsfeaturesource.h"
#line 249 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 252 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


/* Call the instance's destructor. */
extern "C" {static void release_QgsInterpolator_LayerData(void *, int);}
static void release_QgsInterpolator_LayerData(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsInterpolator::LayerData *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsInterpolator_LayerData(void *, SIP_SSIZE_T, void *);}
static void assign_QgsInterpolator_LayerData(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsInterpolator::LayerData *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSrc);
}


extern "C" {static void *array_QgsInterpolator_LayerData(SIP_SSIZE_T);}
static void *array_QgsInterpolator_LayerData(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsInterpolator::LayerData[sipNrElem];
}


extern "C" {static void *copy_QgsInterpolator_LayerData(const void *, SIP_SSIZE_T);}
static void *copy_QgsInterpolator_LayerData(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsInterpolator::LayerData(reinterpret_cast<const  ::QgsInterpolator::LayerData *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsInterpolator_LayerData(sipSimpleWrapper *);}
static void dealloc_QgsInterpolator_LayerData(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsInterpolator_LayerData(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsInterpolator_LayerData(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsInterpolator_LayerData(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsInterpolator::LayerData *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsInterpolator::LayerData();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsInterpolator::LayerData* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsInterpolator_LayerData, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsInterpolator::LayerData(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_QgsInterpolator_LayerData_interpolationAttribute(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsInterpolator_LayerData_interpolationAttribute(void *sipSelf, PyObject *, PyObject *)
{
    int sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    sipVal = sipCpp->interpolationAttribute;

    return SIPLong_FromLong(sipVal);
}


extern "C" {static int varset_QgsInterpolator_LayerData_interpolationAttribute(void *, PyObject *, PyObject *);}
static int varset_QgsInterpolator_LayerData_interpolationAttribute(void *sipSelf, PyObject *sipPy, PyObject *)
{
    int sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    sipVal = sipLong_AsInt(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->interpolationAttribute = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsInterpolator_LayerData_source(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsInterpolator_LayerData_source(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsFeatureSource*sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    sipVal = sipCpp->source;

    return sipConvertFromType(sipVal, sipType_QgsFeatureSource, NULL);
}


extern "C" {static int varset_QgsInterpolator_LayerData_source(void *, PyObject *, PyObject *);}
static int varset_QgsInterpolator_LayerData_source(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsFeatureSource*sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QgsFeatureSource *>(sipForceConvertToType(sipPy,sipType_QgsFeatureSource,NULL,0,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->source = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsInterpolator_LayerData_sourceType(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsInterpolator_LayerData_sourceType(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsInterpolator::SourceType sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    sipVal = sipCpp->sourceType;

    return sipConvertFromEnum(static_cast<int>(sipVal), sipType_QgsInterpolator_SourceType);
}


extern "C" {static int varset_QgsInterpolator_LayerData_sourceType(void *, PyObject *, PyObject *);}
static int varset_QgsInterpolator_LayerData_sourceType(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsInterpolator::SourceType sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    sipVal = ( ::QgsInterpolator::SourceType)sipConvertToEnum(sipPy, sipType_QgsInterpolator_SourceType);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->sourceType = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsInterpolator_LayerData_valueSource(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsInterpolator_LayerData_valueSource(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsInterpolator::ValueSource sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    sipVal = sipCpp->valueSource;

    return sipConvertFromEnum(static_cast<int>(sipVal), sipType_QgsInterpolator_ValueSource);
}


extern "C" {static int varset_QgsInterpolator_LayerData_valueSource(void *, PyObject *, PyObject *);}
static int varset_QgsInterpolator_LayerData_valueSource(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsInterpolator::ValueSource sipVal;
     ::QgsInterpolator::LayerData *sipCpp = reinterpret_cast< ::QgsInterpolator::LayerData *>(sipSelf);

    sipVal = ( ::QgsInterpolator::ValueSource)sipConvertToEnum(sipPy, sipType_QgsInterpolator_ValueSource);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->valueSource = sipVal;

    return 0;
}

sipVariableDef variables_QgsInterpolator_LayerData[] = {
    {InstanceVariable, sipName_interpolationAttribute, (PyMethodDef *)varget_QgsInterpolator_LayerData_interpolationAttribute, (PyMethodDef *)varset_QgsInterpolator_LayerData_interpolationAttribute, NULL, NULL},
    {InstanceVariable, sipName_source, (PyMethodDef *)varget_QgsInterpolator_LayerData_source, (PyMethodDef *)varset_QgsInterpolator_LayerData_source, NULL, NULL},
    {InstanceVariable, sipName_sourceType, (PyMethodDef *)varget_QgsInterpolator_LayerData_sourceType, (PyMethodDef *)varset_QgsInterpolator_LayerData_sourceType, NULL, NULL},
    {InstanceVariable, sipName_valueSource, (PyMethodDef *)varget_QgsInterpolator_LayerData_valueSource, (PyMethodDef *)varset_QgsInterpolator_LayerData_valueSource, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsInterpolator_LayerData, "\1QgsInterpolator.LayerData()\n"
"QgsInterpolator.LayerData(QgsInterpolator.LayerData)");


static pyqt5ClassPluginDef plugin_QgsInterpolator_LayerData = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsInterpolator_LayerData = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsInterpolator__LayerData,
        {0},
        &plugin_QgsInterpolator_LayerData
    },
    {
        sipNameNr_LayerData,
        {53, 255, 0},
        0, 0,
        0, 0,
        4, variables_QgsInterpolator_LayerData,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsInterpolator_LayerData,
    -1,
    -1,
    0,
    0,
    init_type_QgsInterpolator_LayerData,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsInterpolator_LayerData,
    assign_QgsInterpolator_LayerData,
    array_QgsInterpolator_LayerData,
    copy_QgsInterpolator_LayerData,
    release_QgsInterpolator_LayerData,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 540 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 544 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 547 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 550 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


class sipQgsInterpolator : public  ::QgsInterpolator
{
public:
    sipQgsInterpolator(const QList< ::QgsInterpolator::LayerData>&);
    sipQgsInterpolator(const  ::QgsInterpolator&);
    virtual ~sipQgsInterpolator();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::QgsInterpolator::Result sipProtect_cacheBaseData( ::QgsFeedback*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int interpolatePoint(double,double,double&, ::QgsFeedback*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsInterpolator(const sipQgsInterpolator &);
    sipQgsInterpolator &operator = (const sipQgsInterpolator &);

    char sipPyMethods[1];
};

sipQgsInterpolator::sipQgsInterpolator(const QList< ::QgsInterpolator::LayerData>& a0):  ::QgsInterpolator(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsInterpolator::sipQgsInterpolator(const  ::QgsInterpolator& a0):  ::QgsInterpolator(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsInterpolator::~sipQgsInterpolator()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipQgsInterpolator::interpolatePoint(double a0,double a1,double& a2, ::QgsFeedback*a3)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QgsInterpolator,sipName_interpolatePoint);

    if (!sipMeth)
        return 0;

    extern int sipVH__analysis_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, double,double,double&, ::QgsFeedback*);

    return sipVH__analysis_14(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

 ::QgsInterpolator::Result sipQgsInterpolator::sipProtect_cacheBaseData( ::QgsFeedback*a0)
{
    return  ::QgsInterpolator::cacheBaseData(a0);
}


PyDoc_STRVAR(doc_QgsInterpolator_interpolatePoint, "interpolatePoint(self, x: float, y: float, feedback: QgsFeedback = None) -> Tuple[int, float]\n"
"Calculates interpolation value for map coordinates x, y\n"
"\n"
":param x: x-coordinate (in map units)\n"
":param y: y-coordinate (in map units)\n"
":param feedback: optional feedback object for progress and cancellation support\n"
"\n"
":return: - 0 in case of success\n"
"         - result: interpolation result");

extern "C" {static PyObject *meth_QgsInterpolator_interpolatePoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsInterpolator_interpolatePoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        double a0;
        double a1;
        double a2;
         ::QgsFeedback* a3 = 0;
         ::QgsInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd|J8", &sipSelf, sipType_QgsInterpolator, &sipCpp, &a0, &a1, sipType_QgsFeedback, &a3))
        {
            int sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsInterpolator, sipName_interpolatePoint);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->interpolatePoint(a0,a1,a2,a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(id)",sipRes,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsInterpolator, sipName_interpolatePoint, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsInterpolator_cacheBaseData, "cacheBaseData(self, feedback: QgsFeedback = None) -> QgsInterpolator.Result\n"
"Caches the vertex and value data from the provider. All the vertex data\n"
"will be held in virtual memory.\n"
"\n"
"An optional ``feedback`` argument may be specified to allow cancellation and\n"
"progress reports from the cache operation.\n"
"\n"
":return: Success in case of success");

extern "C" {static PyObject *meth_QgsInterpolator_cacheBaseData(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsInterpolator_cacheBaseData(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
        sipQgsInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsInterpolator, &sipCpp, sipType_QgsFeedback, &a0))
        {
             ::QgsInterpolator::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_cacheBaseData(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsInterpolator_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsInterpolator, sipName_cacheBaseData, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsInterpolator(void *, int);}
static void release_QgsInterpolator(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsInterpolator *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsInterpolator *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsInterpolator(sipSimpleWrapper *);}
static void dealloc_QgsInterpolator(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsInterpolator *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsInterpolator(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsInterpolator(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsInterpolator(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsInterpolator *sipCpp = 0;

    {
        const QList< ::QgsInterpolator::LayerData>* a0;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_layerData,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1", sipType_QList_0100QgsInterpolator_LayerData,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsInterpolator(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QList< ::QgsInterpolator::LayerData> *>(a0),sipType_QList_0100QgsInterpolator_LayerData,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QList< ::QgsInterpolator::LayerData> *>(a0),sipType_QList_0100QgsInterpolator_LayerData,a0State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsInterpolator* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsInterpolator, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsInterpolator(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsInterpolator[] = {
    {SIP_MLNAME_CAST(sipName_cacheBaseData), (PyCFunction)meth_QgsInterpolator_cacheBaseData, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsInterpolator_cacheBaseData)},
    {SIP_MLNAME_CAST(sipName_interpolatePoint), (PyCFunction)meth_QgsInterpolator_interpolatePoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsInterpolator_interpolatePoint)}
};

static sipEnumMemberDef enummembers_QgsInterpolator[] = {
    {sipName_Canceled, static_cast<int>( ::QgsInterpolator::Canceled), 55},
    {sipName_FeatureGeometryError, static_cast<int>( ::QgsInterpolator::FeatureGeometryError), 55},
    {sipName_InvalidSource, static_cast<int>( ::QgsInterpolator::InvalidSource), 55},
    {sipName_SourceBreakLines, static_cast<int>( ::QgsInterpolator::SourceBreakLines), 56},
    {sipName_SourcePoints, static_cast<int>( ::QgsInterpolator::SourcePoints), 56},
    {sipName_SourceStructureLines, static_cast<int>( ::QgsInterpolator::SourceStructureLines), 56},
    {sipName_Success, static_cast<int>( ::QgsInterpolator::Success), 55},
    {sipName_ValueAttribute, static_cast<int>( ::QgsInterpolator::ValueAttribute), 57},
    {sipName_ValueM, static_cast<int>( ::QgsInterpolator::ValueM), 57},
    {sipName_ValueZ, static_cast<int>( ::QgsInterpolator::ValueZ), 57},
};

PyDoc_STRVAR(doc_QgsInterpolator, "\n"
"\n"
"\n"
"Interface class for interpolations. Interpolators take\n"
"the vertices of a vector layer as base data. The z-Value\n"
"can be an attribute or the z-coordinates in case of 3D types.");


static pyqt5ClassPluginDef plugin_QgsInterpolator = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsInterpolator = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsInterpolator,
        {0},
        &plugin_QgsInterpolator
    },
    {
        sipNameNr_QgsInterpolator,
        {0, 0, 1},
        2, methods_QgsInterpolator,
        10, enummembers_QgsInterpolator,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsInterpolator,
    -1,
    -1,
    0,
    0,
    init_type_QgsInterpolator,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsInterpolator,
    0,
    0,
    0,
    release_QgsInterpolator,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};




/* Call the instance's destructor. */
extern "C" {static void release_QgsInterpolatorVertexData(void *, int);}
static void release_QgsInterpolatorVertexData(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsInterpolatorVertexData *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsInterpolatorVertexData(void *, SIP_SSIZE_T, void *);}
static void assign_QgsInterpolatorVertexData(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsInterpolatorVertexData *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsInterpolatorVertexData *>(sipSrc);
}


extern "C" {static void *array_QgsInterpolatorVertexData(SIP_SSIZE_T);}
static void *array_QgsInterpolatorVertexData(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsInterpolatorVertexData[sipNrElem];
}


extern "C" {static void *copy_QgsInterpolatorVertexData(const void *, SIP_SSIZE_T);}
static void *copy_QgsInterpolatorVertexData(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsInterpolatorVertexData(reinterpret_cast<const  ::QgsInterpolatorVertexData *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsInterpolatorVertexData(sipSimpleWrapper *);}
static void dealloc_QgsInterpolatorVertexData(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsInterpolatorVertexData(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsInterpolatorVertexData(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsInterpolatorVertexData(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsInterpolatorVertexData *sipCpp = 0;

    {
        double a0;
        double a1;
        double a2;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_z,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "ddd", &a0, &a1, &a2))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsInterpolatorVertexData(a0,a1,a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsInterpolatorVertexData();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsInterpolatorVertexData* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsInterpolatorVertexData, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsInterpolatorVertexData(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_QgsInterpolatorVertexData_x(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsInterpolatorVertexData_x(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsInterpolatorVertexData *sipCpp = reinterpret_cast< ::QgsInterpolatorVertexData *>(sipSelf);

    sipVal = sipCpp->x;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsInterpolatorVertexData_x(void *, PyObject *, PyObject *);}
static int varset_QgsInterpolatorVertexData_x(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsInterpolatorVertexData *sipCpp = reinterpret_cast< ::QgsInterpolatorVertexData *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->x = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsInterpolatorVertexData_y(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsInterpolatorVertexData_y(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsInterpolatorVertexData *sipCpp = reinterpret_cast< ::QgsInterpolatorVertexData *>(sipSelf);

    sipVal = sipCpp->y;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsInterpolatorVertexData_y(void *, PyObject *, PyObject *);}
static int varset_QgsInterpolatorVertexData_y(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsInterpolatorVertexData *sipCpp = reinterpret_cast< ::QgsInterpolatorVertexData *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->y = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsInterpolatorVertexData_z(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsInterpolatorVertexData_z(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsInterpolatorVertexData *sipCpp = reinterpret_cast< ::QgsInterpolatorVertexData *>(sipSelf);

    sipVal = sipCpp->z;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsInterpolatorVertexData_z(void *, PyObject *, PyObject *);}
static int varset_QgsInterpolatorVertexData_z(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsInterpolatorVertexData *sipCpp = reinterpret_cast< ::QgsInterpolatorVertexData *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->z = sipVal;

    return 0;
}

sipVariableDef variables_QgsInterpolatorVertexData[] = {
    {InstanceVariable, sipName_x, (PyMethodDef *)varget_QgsInterpolatorVertexData_x, (PyMethodDef *)varset_QgsInterpolatorVertexData_x, NULL, NULL},
    {InstanceVariable, sipName_y, (PyMethodDef *)varget_QgsInterpolatorVertexData_y, (PyMethodDef *)varset_QgsInterpolatorVertexData_y, NULL, NULL},
    {InstanceVariable, sipName_z, (PyMethodDef *)varget_QgsInterpolatorVertexData_z, (PyMethodDef *)varset_QgsInterpolatorVertexData_z, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsInterpolatorVertexData, "QgsInterpolatorVertexData(x: float, y: float, z: float)\n"
"Constructor for QgsInterpolatorVertexData with the specified\n"
"``x``, ``y``, and ``z`` coordinate.\n"
"\n"
"QgsInterpolatorVertexData()\n"
"Constructor for QgsInterpolatorVertexData\n"
"\n"
"QgsInterpolatorVertexData(QgsInterpolatorVertexData)");


static pyqt5ClassPluginDef plugin_QgsInterpolatorVertexData = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsInterpolatorVertexData = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsInterpolatorVertexData,
        {0},
        &plugin_QgsInterpolatorVertexData
    },
    {
        sipNameNr_QgsInterpolatorVertexData,
        {0, 0, 1},
        0, 0,
        0, 0,
        3, variables_QgsInterpolatorVertexData,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsInterpolatorVertexData,
    -1,
    -1,
    0,
    0,
    init_type_QgsInterpolatorVertexData,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsInterpolatorVertexData,
    assign_QgsInterpolatorVertexData,
    array_QgsInterpolatorVertexData,
    copy_QgsInterpolatorVertexData,
    release_QgsInterpolatorVertexData,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 26 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsfeaturepool.sip"
#include "qgsfeaturepool.h"
#line 1207 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 305 "core/auto_generated/qgsvectorlayer.sip"
#include "qgsvectorlayer.h"
#line 1211 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 1217 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 1220 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 157 "core/auto_generated/qgscoordinatereferencesystem.sip"
#include "qgscoordinatereferencesystem.h"
#line 1223 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 24 "core/auto_generated/geometry/qgswkbtypes.sip"
#include "qgswkbtypes.h"
#line 1226 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 1229 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 21 "core/auto_generated/qgsfeaturesink.sip"
#include "qgsfeaturesink.h"
#line 1232 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 200 "core/auto_generated/qgsfeatureiterator.sip"
#include "qgsfeatureiterator.h"
#line 1235 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsFeaturePool_getFeature, "getFeature(self, id: int, feature: QgsFeature) -> bool\n"
"Retrieves the feature with the specified ``id`` into ``feature``.\n"
"It will be retrieved from the cache or from the underlying feature source if unavailable.\n"
"If the feature is neither available from the cache nor from the source it will return ``False``.");

extern "C" {static PyObject *meth_QgsFeaturePool_getFeature(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_getFeature(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeatureId a0;
         ::QgsFeature* a1;
         ::QgsFeaturePool *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_feature,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BnJ9", &sipSelf, sipType_QgsFeaturePool, &sipCpp, &a0, sipType_QgsFeature, &a1))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->getFeature(a0,*a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_getFeature, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsFeaturePool_updateFeature, "updateFeature(self, feature: QgsFeature)\n"
"Updates a feature in this pool.\n"
"Implementations will update the feature on the layer or on the data provider.");

extern "C" {static PyObject *meth_QgsFeaturePool_updateFeature(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_updateFeature(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QgsFeature* a0;
         ::QgsFeaturePool *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feature,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsFeaturePool, &sipCpp, sipType_QgsFeature, &a0))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsFeaturePool, sipName_updateFeature);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->updateFeature(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_updateFeature, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsFeaturePool_deleteFeature, "deleteFeature(self, fid: int)\n"
"Removes a feature from this pool.\n"
"Implementations will remove the feature from the layer or from the data provider.");

extern "C" {static PyObject *meth_QgsFeaturePool_deleteFeature(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_deleteFeature(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::QgsFeatureId a0;
         ::QgsFeaturePool *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fid,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bn", &sipSelf, sipType_QgsFeaturePool, &sipCpp, &a0))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsFeaturePool, sipName_deleteFeature);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->deleteFeature(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_deleteFeature, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsFeaturePool_layer, "layer(self) -> QgsVectorLayer\n"
"Gets a pointer to the underlying layer.\n"
"May return a ````None```` if the layer has been deleted.\n"
"This must only be called from the main thread.");

extern "C" {static PyObject *meth_QgsFeaturePool_layer(PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_layer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeaturePool *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsFeaturePool, &sipCpp))
        {
             ::QgsVectorLayer*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->layer();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QgsVectorLayer,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_layer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsFeaturePool_layerId, "layerId(self) -> str\n"
"The layer id of the layer.");

extern "C" {static PyObject *meth_QgsFeaturePool_layerId(PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_layerId(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeaturePool *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsFeaturePool, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->layerId());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_layerId, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsFeaturePool_geometryType, "geometryType(self) -> QgsWkbTypes.GeometryType\n"
"The geometry type of this layer.");

extern "C" {static PyObject *meth_QgsFeaturePool_geometryType(PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_geometryType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeaturePool *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsFeaturePool, &sipCpp))
        {
             ::QgsWkbTypes::GeometryType sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->geometryType();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsWkbTypes_GeometryType);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_geometryType, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsFeaturePool_crs, "crs(self) -> QgsCoordinateReferenceSystem\n"
"The coordinate reference system of this layer.");

extern "C" {static PyObject *meth_QgsFeaturePool_crs(PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_crs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeaturePool *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsFeaturePool, &sipCpp))
        {
             ::QgsCoordinateReferenceSystem*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsCoordinateReferenceSystem(sipCpp->crs());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsCoordinateReferenceSystem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_crs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsFeaturePool_layerName, "layerName(self) -> str\n"
"Returns the name of the layer.\n"
"\n"
"Should be preferred over layer().name() because it can directly be run on\n"
"the background thread.");

extern "C" {static PyObject *meth_QgsFeaturePool_layerName(PyObject *, PyObject *);}
static PyObject *meth_QgsFeaturePool_layerName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeaturePool *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsFeaturePool, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->layerName());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsFeaturePool, sipName_layerName, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsFeaturePool(void *, const sipTypeDef *);}
static void *cast_QgsFeaturePool(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsFeaturePool *sipCpp = reinterpret_cast< ::QgsFeaturePool *>(sipCppV);

    if (targetType == sipType_QgsFeatureSink)
        return static_cast< ::QgsFeatureSink *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsFeaturePool(void *, int);}
static void release_QgsFeaturePool(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsFeaturePool *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsFeaturePool(sipSimpleWrapper *);}
static void dealloc_QgsFeaturePool(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsFeaturePool(sipGetAddress(sipSelf), 0);
    }
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsFeaturePool[] = {{10, 7, 1}};


static PyMethodDef methods_QgsFeaturePool[] = {
    {SIP_MLNAME_CAST(sipName_crs), meth_QgsFeaturePool_crs, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsFeaturePool_crs)},
    {SIP_MLNAME_CAST(sipName_deleteFeature), (PyCFunction)meth_QgsFeaturePool_deleteFeature, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsFeaturePool_deleteFeature)},
    {SIP_MLNAME_CAST(sipName_geometryType), meth_QgsFeaturePool_geometryType, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsFeaturePool_geometryType)},
    {SIP_MLNAME_CAST(sipName_getFeature), (PyCFunction)meth_QgsFeaturePool_getFeature, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsFeaturePool_getFeature)},
    {SIP_MLNAME_CAST(sipName_layer), meth_QgsFeaturePool_layer, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsFeaturePool_layer)},
    {SIP_MLNAME_CAST(sipName_layerId), meth_QgsFeaturePool_layerId, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsFeaturePool_layerId)},
    {SIP_MLNAME_CAST(sipName_layerName), meth_QgsFeaturePool_layerName, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsFeaturePool_layerName)},
    {SIP_MLNAME_CAST(sipName_updateFeature), (PyCFunction)meth_QgsFeaturePool_updateFeature, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsFeaturePool_updateFeature)}
};

PyDoc_STRVAR(doc_QgsFeaturePool, "QgsFeaturePool(layer: QgsVectorLayer)\n"
"Creates a new feature pool for ``layer``.\n"
"\n"
"A feature pool is based on a vector layer and caches features.\n"
"\n"
".. note::\n"
"\n"
"   This class is a technology preview and unstable API.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsFeaturePool = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsFeaturePool = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsFeaturePool,
        {0},
        &plugin_QgsFeaturePool
    },
    {
        sipNameNr_QgsFeaturePool,
        {0, 0, 1},
        8, methods_QgsFeaturePool,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsFeaturePool,
    -1,
    -1,
    supers_QgsFeaturePool,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsFeaturePool,
    0,
    0,
    0,
    release_QgsFeaturePool,
    cast_QgsFeaturePool,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 97 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 1728 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"



/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometryCheckerUtils_LayerFeatures(void *, int);}
static void release_QgsGeometryCheckerUtils_LayerFeatures(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGeometryCheckerUtils::LayerFeatures *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGeometryCheckerUtils_LayerFeatures(sipSimpleWrapper *);}
static void dealloc_QgsGeometryCheckerUtils_LayerFeatures(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometryCheckerUtils_LayerFeatures(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGeometryCheckerUtils_LayerFeatures(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometryCheckerUtils_LayerFeatures(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGeometryCheckerUtils::LayerFeatures *sipCpp = 0;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeatures* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGeometryCheckerUtils_LayerFeatures, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometryCheckerUtils::LayerFeatures(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}

PyDoc_STRVAR(doc_QgsGeometryCheckerUtils_LayerFeatures, "\n"
"\n"
"\n"
"Contains a set of layers and feature ids in those layers to pass to a geometry check.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsGeometryCheckerUtils_LayerFeatures = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometryCheckerUtils_LayerFeatures = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometryCheckerUtils__LayerFeatures,
        {0},
        &plugin_QgsGeometryCheckerUtils_LayerFeatures
    },
    {
        sipNameNr_LayerFeatures,
        {36, 255, 0},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometryCheckerUtils_LayerFeatures,
    -1,
    -1,
    0,
    0,
    init_type_QgsGeometryCheckerUtils_LayerFeatures,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometryCheckerUtils_LayerFeatures,
    0,
    0,
    0,
    release_QgsGeometryCheckerUtils_LayerFeatures,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 42 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 1854 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 26 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsfeaturepool.sip"
#include "qgsfeaturepool.h"
#line 1858 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 1864 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 1867 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 45 "core/auto_generated/geometry/qgsgeometry.sip"
#include "qgsgeometry.h"
#line 1870 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsGeometryCheckerUtils_LayerFeature_feature, "feature(self) -> QgsFeature\n"
"Returns the feature.\n"
"The geometry will not be reprojected regardless of useMapCrs.");

extern "C" {static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_feature(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_feature(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckerUtils_LayerFeature, &sipCpp))
        {
             ::QgsFeature*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsFeature(sipCpp->feature());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsFeature,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_LayerFeature, sipName_feature, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckerUtils_LayerFeature_layerId, "layerId(self) -> str\n"
"The layer id.");

extern "C" {static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_layerId(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_layerId(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckerUtils_LayerFeature, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->layerId());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_LayerFeature, sipName_layerId, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckerUtils_LayerFeature_geometry, "geometry(self) -> QgsGeometry\n"
"Returns the geometry of this feature.\n"
"If useMapCrs was specified, it will already be reprojected into the\n"
"CRS specified in the context specified in the constructor.");

extern "C" {static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_geometry(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_geometry(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckerUtils_LayerFeature, &sipCpp))
        {
             ::QgsGeometry*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometry(sipCpp->geometry());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGeometry,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_LayerFeature, sipName_geometry, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckerUtils_LayerFeature_id, "id(self) -> str\n"
"Returns a combination of the layerId and the feature id.");

extern "C" {static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_id(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_id(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckerUtils_LayerFeature, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->id());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_LayerFeature, sipName_id, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckerUtils_LayerFeature_useMapCrs, "useMapCrs(self) -> bool\n"
"Returns if the geometry is reprojected to the map CRS or not.");

extern "C" {static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_useMapCrs(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckerUtils_LayerFeature_useMapCrs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckerUtils_LayerFeature, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->useMapCrs();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_LayerFeature, sipName_useMapCrs, NULL);

    return NULL;
}


extern "C" {static PyObject *slot_QgsGeometryCheckerUtils_LayerFeature___ne__(PyObject *,PyObject *);}
static PyObject *slot_QgsGeometryCheckerUtils_LayerFeature___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QgsGeometryCheckerUtils::LayerFeature *sipCpp = reinterpret_cast< ::QgsGeometryCheckerUtils::LayerFeature *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsGeometryCheckerUtils_LayerFeature));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QgsGeometryCheckerUtils_LayerFeature, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp-> ::QgsGeometryCheckerUtils::LayerFeature::operator!=(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__analysis, ne_slot, sipType_QgsGeometryCheckerUtils_LayerFeature, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QgsGeometryCheckerUtils_LayerFeature___eq__(PyObject *,PyObject *);}
static PyObject *slot_QgsGeometryCheckerUtils_LayerFeature___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QgsGeometryCheckerUtils::LayerFeature *sipCpp = reinterpret_cast< ::QgsGeometryCheckerUtils::LayerFeature *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsGeometryCheckerUtils_LayerFeature));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_QgsGeometryCheckerUtils_LayerFeature, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp-> ::QgsGeometryCheckerUtils::LayerFeature::operator==(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__analysis, eq_slot, sipType_QgsGeometryCheckerUtils_LayerFeature, sipSelf, sipArg);
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometryCheckerUtils_LayerFeature(void *, int);}
static void release_QgsGeometryCheckerUtils_LayerFeature(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGeometryCheckerUtils::LayerFeature *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGeometryCheckerUtils_LayerFeature(sipSimpleWrapper *);}
static void dealloc_QgsGeometryCheckerUtils_LayerFeature(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometryCheckerUtils_LayerFeature(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGeometryCheckerUtils_LayerFeature(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometryCheckerUtils_LayerFeature(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGeometryCheckerUtils::LayerFeature *sipCpp = 0;

    {
        const  ::QgsFeaturePool* a0;
        const  ::QgsFeature* a1;
        const  ::QgsGeometryCheckContext* a2;
        bool a3;

        static const char *sipKwdList[] = {
            sipName_pool,
            sipName_feature,
            sipName_context,
            sipName_useMapCrs,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J9J8b", sipType_QgsFeaturePool, &a0, sipType_QgsFeature, &a1, sipType_QgsGeometryCheckContext, &a2, &a3))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometryCheckerUtils::LayerFeature(a0,*a1,a2,a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsGeometryCheckerUtils::LayerFeature* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGeometryCheckerUtils_LayerFeature, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometryCheckerUtils::LayerFeature(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QgsGeometryCheckerUtils_LayerFeature[] = {
    {(void *)slot_QgsGeometryCheckerUtils_LayerFeature___ne__, ne_slot},
    {(void *)slot_QgsGeometryCheckerUtils_LayerFeature___eq__, eq_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_QgsGeometryCheckerUtils_LayerFeature[] = {
    {SIP_MLNAME_CAST(sipName_feature), meth_QgsGeometryCheckerUtils_LayerFeature_feature, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckerUtils_LayerFeature_feature)},
    {SIP_MLNAME_CAST(sipName_geometry), meth_QgsGeometryCheckerUtils_LayerFeature_geometry, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckerUtils_LayerFeature_geometry)},
    {SIP_MLNAME_CAST(sipName_id), meth_QgsGeometryCheckerUtils_LayerFeature_id, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckerUtils_LayerFeature_id)},
    {SIP_MLNAME_CAST(sipName_layerId), meth_QgsGeometryCheckerUtils_LayerFeature_layerId, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckerUtils_LayerFeature_layerId)},
    {SIP_MLNAME_CAST(sipName_useMapCrs), meth_QgsGeometryCheckerUtils_LayerFeature_useMapCrs, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckerUtils_LayerFeature_useMapCrs)}
};

PyDoc_STRVAR(doc_QgsGeometryCheckerUtils_LayerFeature, "QgsGeometryCheckerUtils.LayerFeature(pool: QgsFeaturePool, feature: QgsFeature, context: QgsGeometryCheckContext, useMapCrs: bool)\n"
"Create a new layer/feature combination.\n"
"The layer is defined by ``pool``, ``feature`` needs to be from this layer.\n"
"If ``useMapCrs`` is ``True``, geometries will be reprojected to the mapCrs defined\n"
"in ``context``.\n"
"\n"
"QgsGeometryCheckerUtils.LayerFeature(QgsGeometryCheckerUtils.LayerFeature)\n"
"\n"
"\n"
"A layer feature combination to uniquely identify and access a feature in\n"
"a set of layers.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsGeometryCheckerUtils_LayerFeature = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometryCheckerUtils_LayerFeature = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometryCheckerUtils__LayerFeature,
        {0},
        &plugin_QgsGeometryCheckerUtils_LayerFeature
    },
    {
        sipNameNr_LayerFeature,
        {36, 255, 0},
        5, methods_QgsGeometryCheckerUtils_LayerFeature,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometryCheckerUtils_LayerFeature,
    -1,
    -1,
    0,
    slots_QgsGeometryCheckerUtils_LayerFeature,
    init_type_QgsGeometryCheckerUtils_LayerFeature,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometryCheckerUtils_LayerFeature,
    0,
    0,
    0,
    release_QgsGeometryCheckerUtils_LayerFeature,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 2348 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"



/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometryCheckerUtils(void *, int);}
static void release_QgsGeometryCheckerUtils(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGeometryCheckerUtils *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsGeometryCheckerUtils(void *, SIP_SSIZE_T, void *);}
static void assign_QgsGeometryCheckerUtils(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsGeometryCheckerUtils *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsGeometryCheckerUtils *>(sipSrc);
}


extern "C" {static void *array_QgsGeometryCheckerUtils(SIP_SSIZE_T);}
static void *array_QgsGeometryCheckerUtils(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsGeometryCheckerUtils[sipNrElem];
}


extern "C" {static void *copy_QgsGeometryCheckerUtils(const void *, SIP_SSIZE_T);}
static void *copy_QgsGeometryCheckerUtils(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsGeometryCheckerUtils(reinterpret_cast<const  ::QgsGeometryCheckerUtils *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsGeometryCheckerUtils(sipSimpleWrapper *);}
static void dealloc_QgsGeometryCheckerUtils(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometryCheckerUtils(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGeometryCheckerUtils(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometryCheckerUtils(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGeometryCheckerUtils *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometryCheckerUtils();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsGeometryCheckerUtils* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGeometryCheckerUtils, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometryCheckerUtils(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}

PyDoc_STRVAR(doc_QgsGeometryCheckerUtils, "\n"
"\n"
"\n"
"\n"
"Contains utilities required for geometry checks.\n"
"\n"
".. note::\n"
"\n"
"   This class is a technology preview and unstable API.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsGeometryCheckerUtils = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometryCheckerUtils = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometryCheckerUtils,
        {0},
        &plugin_QgsGeometryCheckerUtils
    },
    {
        sipNameNr_QgsGeometryCheckerUtils,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometryCheckerUtils,
    -1,
    -1,
    0,
    0,
    init_type_QgsGeometryCheckerUtils,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometryCheckerUtils,
    assign_QgsGeometryCheckerUtils,
    array_QgsGeometryCheckerUtils,
    copy_QgsGeometryCheckerUtils,
    release_QgsGeometryCheckerUtils,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgszonalstatistics.sip"
#include "qgszonalstatistics.h"
#line 2519 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgszonalstatistics.sip"
#include "qgszonalstatistics.h"
#line 2523 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


extern "C" {static long slot_QgsZonalStatistics_Statistics___hash__(PyObject *);}
static long slot_QgsZonalStatistics_Statistics___hash__(PyObject *sipSelf)
{
     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;


    {
        {
            long sipRes = 0;

#line 116 "/usr/share/sip/PyQt5/QtCore/qglobal.sip"
        sipRes = sipCpp->operator QgsZonalStatistics::Statistics::Int();
#line 2541 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static int slot_QgsZonalStatistics_Statistics___bool__(PyObject *);}
static int slot_QgsZonalStatistics_Statistics___bool__(PyObject *sipSelf)
{
     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return -1;


    {
        {
            int sipRes = 0;

#line 111 "/usr/share/sip/PyQt5/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QgsZonalStatistics::Statistics::Int() != 0);
#line 2566 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

            return sipRes;
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___ne__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::QgsZonalStatistics::Statistics* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QgsZonalStatistics_Statistics, &a0, &a0State))
        {
            bool sipRes = 0;

#line 106 "/usr/share/sip/PyQt5/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QgsZonalStatistics::Statistics::Int() != a0->operator QgsZonalStatistics::Statistics::Int());
#line 2596 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
            sipReleaseType(const_cast< ::QgsZonalStatistics::Statistics *>(a0),sipType_QgsZonalStatistics_Statistics,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__analysis, ne_slot, sipType_QgsZonalStatistics_Statistics, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___eq__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::QgsZonalStatistics::Statistics* a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J1", sipType_QgsZonalStatistics_Statistics, &a0, &a0State))
        {
            bool sipRes = 0;

#line 101 "/usr/share/sip/PyQt5/QtCore/qglobal.sip"
        sipRes = (sipCpp->operator QgsZonalStatistics::Statistics::Int() == a0->operator QgsZonalStatistics::Statistics::Int());
#line 2632 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
            sipReleaseType(const_cast< ::QgsZonalStatistics::Statistics *>(a0),sipType_QgsZonalStatistics_Statistics,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__analysis, eq_slot, sipType_QgsZonalStatistics_Statistics, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___ixor__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___ixor__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QgsZonalStatistics_Statistics)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
#line 95 "/usr/share/sip/PyQt5/QtCore/qglobal.sip"
        *sipCpp = QgsZonalStatistics::Statistics(*sipCpp ^ a0);
#line 2671 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___xor__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___xor__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsZonalStatistics::Statistics* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QgsZonalStatistics_Statistics, &a0, &a0State, &a1))
        {
             ::QgsZonalStatistics::Statistics*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsZonalStatistics::Statistics((*a0 ^ a1));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(a0,sipType_QgsZonalStatistics_Statistics,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_QgsZonalStatistics_Statistics,a0State);

            return sipConvertFromNewType(sipRes,sipType_QgsZonalStatistics_Statistics,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__analysis, xor_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___ior__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___ior__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QgsZonalStatistics_Statistics)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
#line 89 "/usr/share/sip/PyQt5/QtCore/qglobal.sip"
        *sipCpp = QgsZonalStatistics::Statistics(*sipCpp | a0);
#line 2756 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___or__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___or__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsZonalStatistics::Statistics* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QgsZonalStatistics_Statistics, &a0, &a0State, &a1))
        {
             ::QgsZonalStatistics::Statistics*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsZonalStatistics::Statistics((*a0 | a1));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(a0,sipType_QgsZonalStatistics_Statistics,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_QgsZonalStatistics_Statistics,a0State);

            return sipConvertFromNewType(sipRes,sipType_QgsZonalStatistics_Statistics,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__analysis, or_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___iand__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___iand__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_QgsZonalStatistics_Statistics)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp-> ::QgsZonalStatistics::Statistics::operator&=(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___and__(PyObject *,PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___and__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsZonalStatistics::Statistics* a0;
        int a0State = 0;
        int a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J1i", sipType_QgsZonalStatistics_Statistics, &a0, &a0State, &a1))
        {
             ::QgsZonalStatistics::Statistics*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsZonalStatistics::Statistics((*a0 & a1));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(a0,sipType_QgsZonalStatistics_Statistics,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_QgsZonalStatistics_Statistics,a0State);

            return sipConvertFromNewType(sipRes,sipType_QgsZonalStatistics_Statistics,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__analysis, and_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___invert__(PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___invert__(PyObject *sipSelf)
{
     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;


    {
        {
             ::QgsZonalStatistics::Statistics*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsZonalStatistics::Statistics(~(*sipCpp));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsZonalStatistics_Statistics,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_QgsZonalStatistics_Statistics___int__(PyObject *);}
static PyObject *slot_QgsZonalStatistics_Statistics___int__(PyObject *sipSelf)
{
     ::QgsZonalStatistics::Statistics *sipCpp = reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_QgsZonalStatistics_Statistics));

    if (!sipCpp)
        return 0;


    {
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = *sipCpp;
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsZonalStatistics_Statistics(void *, int);}
static void release_QgsZonalStatistics_Statistics(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsZonalStatistics_Statistics(void *, SIP_SSIZE_T, void *);}
static void assign_QgsZonalStatistics_Statistics(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsZonalStatistics::Statistics *>(sipSrc);
}


extern "C" {static void *array_QgsZonalStatistics_Statistics(SIP_SSIZE_T);}
static void *array_QgsZonalStatistics_Statistics(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsZonalStatistics::Statistics[sipNrElem];
}


extern "C" {static void *copy_QgsZonalStatistics_Statistics(const void *, SIP_SSIZE_T);}
static void *copy_QgsZonalStatistics_Statistics(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsZonalStatistics::Statistics(reinterpret_cast<const  ::QgsZonalStatistics::Statistics *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsZonalStatistics_Statistics(sipSimpleWrapper *);}
static void dealloc_QgsZonalStatistics_Statistics(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsZonalStatistics_Statistics(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsZonalStatistics_Statistics(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsZonalStatistics_Statistics(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsZonalStatistics::Statistics *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsZonalStatistics::Statistics();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        int a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "i", &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsZonalStatistics::Statistics(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsZonalStatistics::Statistics* a0;
        int a0State = 0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J1", sipType_QgsZonalStatistics_Statistics, &a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsZonalStatistics::Statistics(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QgsZonalStatistics::Statistics *>(a0),sipType_QgsZonalStatistics_Statistics,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QgsZonalStatistics::Statistics *>(a0),sipType_QgsZonalStatistics_Statistics,a0State);

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static int convertTo_QgsZonalStatistics_Statistics(PyObject *, void **, int *, PyObject *);}
static int convertTo_QgsZonalStatistics_Statistics(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
     ::QgsZonalStatistics::Statistics **sipCppPtr = reinterpret_cast< ::QgsZonalStatistics::Statistics **>(sipCppPtrV);

#line 121 "/usr/share/sip/PyQt5/QtCore/qglobal.sip"
// Allow an instance of the base enum whenever a QgsZonalStatistics::Statistics is expected.

if (sipIsErr == NULL)
    return (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QgsZonalStatistics_Statistic)) ||
            sipCanConvertToType(sipPy, sipType_QgsZonalStatistics_Statistics, SIP_NO_CONVERTORS));

if (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_QgsZonalStatistics_Statistic)))
{
    *sipCppPtr = new QgsZonalStatistics::Statistics(int(SIPLong_AsLong(sipPy)));

    return sipGetState(sipTransferObj);
}

*sipCppPtr = reinterpret_cast<QgsZonalStatistics::Statistics *>(sipConvertToType(sipPy, sipType_QgsZonalStatistics_Statistics, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

return 0;
#line 3127 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
}


/* Define this type's Python slots. */
static sipPySlotDef slots_QgsZonalStatistics_Statistics[] = {
    {(void *)slot_QgsZonalStatistics_Statistics___hash__, hash_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___bool__, bool_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___ne__, ne_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___eq__, eq_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___ixor__, ixor_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___xor__, xor_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___ior__, ior_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___or__, or_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___iand__, iand_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___and__, and_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___invert__, invert_slot},
    {(void *)slot_QgsZonalStatistics_Statistics___int__, int_slot},
    {0, (sipPySlotType)0}
};

PyDoc_STRVAR(doc_QgsZonalStatistics_Statistics, "\1QgsZonalStatistics.Statistics()\n"
"QgsZonalStatistics.Statistics(Union[QgsZonalStatistics.Statistics, QgsZonalStatistics.Statistic])\n"
"QgsZonalStatistics.Statistics(QgsZonalStatistics.Statistics)");


static pyqt5ClassPluginDef plugin_QgsZonalStatistics_Statistics = {
    0,
    1,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsZonalStatistics_Statistics = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsZonalStatistics__Statistics,
        {0},
        &plugin_QgsZonalStatistics_Statistics
    },
    {
        sipNameNr_Statistics,
        {91, 255, 0},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsZonalStatistics_Statistics,
    -1,
    -1,
    0,
    slots_QgsZonalStatistics_Statistics,
    init_type_QgsZonalStatistics_Statistics,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsZonalStatistics_Statistics,
    assign_QgsZonalStatistics_Statistics,
    array_QgsZonalStatistics_Statistics,
    copy_QgsZonalStatistics_Statistics,
    release_QgsZonalStatistics_Statistics,
    0,
    convertTo_QgsZonalStatistics_Statistics,
    0,
    0,
    0,
    0,
    0
};

#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgszonalstatistics.sip"
#include "qgszonalstatistics.h"
#line 3215 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 305 "core/auto_generated/qgsvectorlayer.sip"
#include "qgsvectorlayer.h"
#line 3219 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 81 "core/auto_generated/raster/qgsrasterlayer.sip"
#include "qgsrasterlayer.h"
#line 3222 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 3225 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgszonalstatistics.sip"
#include "qgszonalstatistics.h"
#line 3228 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 76 "core/auto_generated/raster/qgsrasterinterface.sip"
#include "qgsrasterinterface.h"
// QgsRasterInterface subclasses
#include <qgsbrightnesscontrastfilter.h>
#include <qgshuesaturationfilter.h>
#include <qgsrasterdataprovider.h>
#include <qgsrasternuller.h>
#include <qgsrasterprojector.h>
#include <qgsrasterrenderer.h>
#include <qgsrasterresamplefilter.h>

// QgsRasterRenderer subclasses
#include <qgshillshaderenderer.h>
#include <qgsmultibandcolorrenderer.h>
#include <qgspalettedrasterrenderer.h>
#include <qgssinglebandcolordatarenderer.h>
#include <qgssinglebandgrayrenderer.h>
#include <qgssinglebandpseudocolorrenderer.h>
#line 3247 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 157 "core/auto_generated/qgscoordinatereferencesystem.sip"
#include "qgscoordinatereferencesystem.h"
#line 3250 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 3253 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsZonalStatistics_calculateStatistics, "calculateStatistics(self, feedback: QgsFeedback) -> int\n"
"Starts the calculation\n"
"\n"
":return: 0 in case of success");

extern "C" {static PyObject *meth_QgsZonalStatistics_calculateStatistics(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsZonalStatistics_calculateStatistics(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0;
         ::QgsZonalStatistics *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsZonalStatistics, &sipCpp, sipType_QgsFeedback, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->calculateStatistics(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsZonalStatistics, sipName_calculateStatistics, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsZonalStatistics(void *, int);}
static void release_QgsZonalStatistics(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsZonalStatistics *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsZonalStatistics(sipSimpleWrapper *);}
static void dealloc_QgsZonalStatistics(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsZonalStatistics(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsZonalStatistics(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsZonalStatistics(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsZonalStatistics *sipCpp = 0;

    {
         ::QgsVectorLayer* a0;
         ::QgsRasterLayer* a1;
        const  ::QString& a2def = QString();
        const  ::QString* a2 = &a2def;
        int a2State = 0;
        int a3 = 1;
         ::QgsZonalStatistics::Statistics a4def = QgsZonalStatistics::Statistics(QgsZonalStatistics::Count|QgsZonalStatistics::Sum|QgsZonalStatistics::Mean);
         ::QgsZonalStatistics::Statistics* a4 = &a4def;
        int a4State = 0;

        static const char *sipKwdList[] = {
            sipName_polygonLayer,
            sipName_rasterLayer,
            sipName_attributePrefix,
            sipName_rasterBand,
            sipName_stats,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J8|J1iJ1", sipType_QgsVectorLayer, &a0, sipType_QgsRasterLayer, &a1, sipType_QString,&a2, &a2State, &a3, sipType_QgsZonalStatistics_Statistics, &a4, &a4State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsZonalStatistics(a0,a1,*a2,a3,*a4);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(a4,sipType_QgsZonalStatistics_Statistics,a4State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(a4,sipType_QgsZonalStatistics_Statistics,a4State);

            return sipCpp;
        }
    }

    {
         ::QgsVectorLayer* a0;
         ::QgsRasterInterface* a1;
        const  ::QgsCoordinateReferenceSystem* a2;
        double a3;
        double a4;
        const  ::QString& a5def = QString();
        const  ::QString* a5 = &a5def;
        int a5State = 0;
        int a6 = 1;
         ::QgsZonalStatistics::Statistics a7def = QgsZonalStatistics::Statistics(QgsZonalStatistics::Count|QgsZonalStatistics::Sum|QgsZonalStatistics::Mean);
         ::QgsZonalStatistics::Statistics* a7 = &a7def;
        int a7State = 0;

        static const char *sipKwdList[] = {
            sipName_polygonLayer,
            sipName_rasterInterface,
            sipName_rasterCrs,
            sipName_rasterUnitsPerPixelX,
            sipName_rasterUnitsPerPixelY,
            sipName_attributePrefix,
            sipName_rasterBand,
            sipName_stats,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J8J9dd|J1iJ1", sipType_QgsVectorLayer, &a0, sipType_QgsRasterInterface, &a1, sipType_QgsCoordinateReferenceSystem, &a2, &a3, &a4, sipType_QString,&a5, &a5State, &a6, sipType_QgsZonalStatistics_Statistics, &a7, &a7State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsZonalStatistics(a0,a1,*a2,a3,a4,*a5,a6,*a7);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a5),sipType_QString,a5State);
            sipReleaseType(a7,sipType_QgsZonalStatistics_Statistics,a7State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a5),sipType_QString,a5State);
            sipReleaseType(a7,sipType_QgsZonalStatistics_Statistics,a7State);

            return sipCpp;
        }
    }

    {
        const  ::QgsZonalStatistics* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsZonalStatistics, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsZonalStatistics(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsZonalStatistics[] = {
    {SIP_MLNAME_CAST(sipName_calculateStatistics), (PyCFunction)meth_QgsZonalStatistics_calculateStatistics, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsZonalStatistics_calculateStatistics)}
};

static sipEnumMemberDef enummembers_QgsZonalStatistics[] = {
    {sipName_All, static_cast<int>( ::QgsZonalStatistics::All), 92},
    {sipName_Count, static_cast<int>( ::QgsZonalStatistics::Count), 92},
    {sipName_Majority, static_cast<int>( ::QgsZonalStatistics::Majority), 92},
    {sipName_Max, static_cast<int>( ::QgsZonalStatistics::Max), 92},
    {sipName_Mean, static_cast<int>( ::QgsZonalStatistics::Mean), 92},
    {sipName_Median, static_cast<int>( ::QgsZonalStatistics::Median), 92},
    {sipName_Min, static_cast<int>( ::QgsZonalStatistics::Min), 92},
    {sipName_Minority, static_cast<int>( ::QgsZonalStatistics::Minority), 92},
    {sipName_Range, static_cast<int>( ::QgsZonalStatistics::Range), 92},
    {sipName_StDev, static_cast<int>( ::QgsZonalStatistics::StDev), 92},
    {sipName_Sum, static_cast<int>( ::QgsZonalStatistics::Sum), 92},
    {sipName_Variance, static_cast<int>( ::QgsZonalStatistics::Variance), 92},
    {sipName_Variety, static_cast<int>( ::QgsZonalStatistics::Variety), 92},
};

PyDoc_STRVAR(doc_QgsZonalStatistics, "QgsZonalStatistics(polygonLayer: QgsVectorLayer, rasterLayer: QgsRasterLayer, attributePrefix: str = '', rasterBand: int = 1, stats: Union[QgsZonalStatistics.Statistics, QgsZonalStatistics.Statistic] = QgsZonalStatistics.Statistics(QgsZonalStatistics.Count|QgsZonalStatistics.Sum|QgsZonalStatistics.Mean))\n"
"Convenience constructor for QgsZonalStatistics, using an input raster layer.\n"
"\n"
"The raster layer must exist for the lifetime of the zonal statistics calculation.\n"
"\n"
".. warning::\n"
"\n"
"   Constructing QgsZonalStatistics using this method is not thread safe, and\n"
"   the constructor which accepts a QgsRasterInterface should be used instead.\n"
"\n"
"QgsZonalStatistics(polygonLayer: QgsVectorLayer, rasterInterface: QgsRasterInterface, rasterCrs: QgsCoordinateReferenceSystem, rasterUnitsPerPixelX: float, rasterUnitsPerPixelY: float, attributePrefix: str = '', rasterBand: int = 1, stats: Union[QgsZonalStatistics.Statistics, QgsZonalStatistics.Statistic] = QgsZonalStatistics.Statistics(QgsZonalStatistics.Count|QgsZonalStatistics.Sum|QgsZonalStatistics.Mean))\n"
"Constructor for QgsZonalStatistics, using a QgsRasterInterface.\n"
"\n"
"The ``polygonLayer`` gives the vector layer containing the (multi)polygon features corresponding to the\n"
"different zones. This layer will be modified, adding extra attributes for each of the zonal statistics\n"
"calculated.\n"
"\n"
"Pixel values for each zone are taken from the raster ``rasterInterface``. The constructor must also\n"
"be given various properties relating to the input raster, such as the raster CRS (``rasterCrs``),\n"
"and the size (X and Y) in map units for each raster pixel. The source raster band is specified\n"
"via ``rasterBand``, where a value of 1 corresponds to the first band.\n"
"\n"
"If the CRS of the ``polygonLayer`` and ``rasterCrs`` differ, the calculation will automatically\n"
"reproject the zones to ensure valid results are calculated.\n"
"\n"
"The ``attributePrefix`` argument specifies an optional prefix to use when creating the\n"
"new fields for each calculated statistic.\n"
"\n"
"Finally, the calculated statistics can be set via the ``stats`` argument. A new field will be\n"
"added to ``polygonLayer`` for each statistic calculated.\n"
"\n"
".. warning::\n"
"\n"
"   The raster interface must exist for the lifetime of the zonal statistics calculation. For thread\n"
"   safe use, always use a cloned raster interface.\n"
"\n"
".. versionadded:: 3.2\n"
"\n"
"QgsZonalStatistics(QgsZonalStatistics)\n"
"\n"
"A class that calculates raster statistics (count, sum, mean) for a polygon or multipolygon layer and appends the results as attributes.");


static pyqt5ClassPluginDef plugin_QgsZonalStatistics = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsZonalStatistics = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsZonalStatistics,
        {0},
        &plugin_QgsZonalStatistics
    },
    {
        sipNameNr_QgsZonalStatistics,
        {0, 0, 1},
        1, methods_QgsZonalStatistics,
        13, enummembers_QgsZonalStatistics,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsZonalStatistics,
    -1,
    -1,
    0,
    0,
    init_type_QgsZonalStatistics,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsZonalStatistics,
    0,
    0,
    0,
    release_QgsZonalStatistics,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 35 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgsgeometrysnappersinglesource.sip"
#include "qgsgeometrysnappersinglesource.h"
#line 3575 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 22 "core/auto_generated/qgsfeaturesource.sip"
#include "qgsfeaturesource.h"
#line 3579 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 21 "core/auto_generated/qgsfeaturesink.sip"
#include "qgsfeaturesink.h"
#line 3582 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 3585 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsGeometrySnapperSingleSource_run, "run(source: QgsFeatureSource, sink: QgsFeatureSink, thresh: float, feedback: QgsFeedback) -> int\n"
"Run the algorithm on given source and output results to the sink, using threshold value in the source's map units.\n"
"Returns number of modified geometries.");

extern "C" {static PyObject *meth_QgsGeometrySnapperSingleSource_run(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapperSingleSource_run(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeatureSource* a0;
         ::QgsFeatureSink* a1;
        double a2;
         ::QgsFeedback* a3;

        static const char *sipKwdList[] = {
            sipName_source,
            sipName_sink,
            sipName_thresh,
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9dJ8", sipType_QgsFeatureSource, &a0, sipType_QgsFeatureSink, &a1, &a2, sipType_QgsFeedback, &a3))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes =  ::QgsGeometrySnapperSingleSource::run(*a0,*a1,a2,a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapperSingleSource, sipName_run, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometrySnapperSingleSource(void *, int);}
static void release_QgsGeometrySnapperSingleSource(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGeometrySnapperSingleSource *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsGeometrySnapperSingleSource(void *, SIP_SSIZE_T, void *);}
static void assign_QgsGeometrySnapperSingleSource(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsGeometrySnapperSingleSource *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsGeometrySnapperSingleSource *>(sipSrc);
}


extern "C" {static void *array_QgsGeometrySnapperSingleSource(SIP_SSIZE_T);}
static void *array_QgsGeometrySnapperSingleSource(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsGeometrySnapperSingleSource[sipNrElem];
}


extern "C" {static void *copy_QgsGeometrySnapperSingleSource(const void *, SIP_SSIZE_T);}
static void *copy_QgsGeometrySnapperSingleSource(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsGeometrySnapperSingleSource(reinterpret_cast<const  ::QgsGeometrySnapperSingleSource *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsGeometrySnapperSingleSource(sipSimpleWrapper *);}
static void dealloc_QgsGeometrySnapperSingleSource(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometrySnapperSingleSource(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGeometrySnapperSingleSource(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometrySnapperSingleSource(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGeometrySnapperSingleSource *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometrySnapperSingleSource();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsGeometrySnapperSingleSource* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGeometrySnapperSingleSource, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometrySnapperSingleSource(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGeometrySnapperSingleSource[] = {
    {SIP_MLNAME_CAST(sipName_run), (PyCFunction)meth_QgsGeometrySnapperSingleSource_run, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometrySnapperSingleSource_run)}
};

PyDoc_STRVAR(doc_QgsGeometrySnapperSingleSource, "\n"
"\n"
"\n"
"\n"
"Makes sure that any two vertices of the vector layer are at least at distance given by the threshold value.\n"
"The algorithm moves nearby vertices to one location and adds vertices to segments that are passing around other\n"
"vertices within the threshold. It does not remove any vertices. Also, it does not modify geometries unless\n"
"needed (it does not snap coordinates to a grid).\n"
"\n"
"This algorithm comes handy when doing vector overlay operations such as intersection, union or difference\n"
"to prevent possible topological errors caused by numerical errors if coordinates are very close to each other.\n"
"\n"
"After running the algorithm some previously valid geometries may become invalid and therefore it may be useful\n"
"to run Fix geometries algorithm afterwards.\n"
"\n"
".. note::\n"
"\n"
"   Originally ported from GRASS implementation of Vect_snap_lines_list()\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsGeometrySnapperSingleSource = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometrySnapperSingleSource = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometrySnapperSingleSource,
        {0},
        &plugin_QgsGeometrySnapperSingleSource
    },
    {
        sipNameNr_QgsGeometrySnapperSingleSource,
        {0, 0, 1},
        1, methods_QgsGeometrySnapperSingleSource,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometrySnapperSingleSource,
    -1,
    -1,
    0,
    0,
    init_type_QgsGeometrySnapperSingleSource,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometrySnapperSingleSource,
    assign_QgsGeometrySnapperSingleSource,
    array_QgsGeometrySnapperSingleSource,
    copy_QgsGeometrySnapperSingleSource,
    release_QgsGeometrySnapperSingleSource,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 92 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgsgeometrysnapper.sip"
#include "qgsgeometrysnapper.h"
#line 3821 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 24 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgsgeometrysnapper.sip"
#include "qgsgeometrysnapper.h"
#line 3825 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 575 "core/conversions.sip"
#include <qmap.h>
#line 3828 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 45 "core/auto_generated/geometry/qgsgeometry.sip"
#include "qgsgeometry.h"
#line 3831 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 3837 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsInternalGeometrySnapper_snapFeature, "snapFeature(self, feature: QgsFeature) -> QgsGeometry\n"
"Snaps a single feature's geometry against all feature geometries already processed by\n"
"calls to snapFeature() in this object, and returns the snapped geometry.");

extern "C" {static PyObject *meth_QgsInternalGeometrySnapper_snapFeature(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsInternalGeometrySnapper_snapFeature(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeature* a0;
         ::QgsInternalGeometrySnapper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feature,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsInternalGeometrySnapper, &sipCpp, sipType_QgsFeature, &a0))
        {
             ::QgsGeometry*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometry(sipCpp->snapFeature(*a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGeometry,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsInternalGeometrySnapper, sipName_snapFeature, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsInternalGeometrySnapper_snappedGeometries, "snappedGeometries(self) -> object\n"
"Returns a QgsGeometryMap of all feature geometries snapped by this object.");

extern "C" {static PyObject *meth_QgsInternalGeometrySnapper_snappedGeometries(PyObject *, PyObject *);}
static PyObject *meth_QgsInternalGeometrySnapper_snappedGeometries(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsInternalGeometrySnapper *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsInternalGeometrySnapper, &sipCpp))
        {
             ::QgsGeometryMap*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometryMap(sipCpp->snappedGeometries());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QMap_3800_0100QgsGeometry,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsInternalGeometrySnapper, sipName_snappedGeometries, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsInternalGeometrySnapper(void *, int);}
static void release_QgsInternalGeometrySnapper(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsInternalGeometrySnapper *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsInternalGeometrySnapper(sipSimpleWrapper *);}
static void dealloc_QgsInternalGeometrySnapper(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsInternalGeometrySnapper(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsInternalGeometrySnapper(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsInternalGeometrySnapper(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsInternalGeometrySnapper *sipCpp = 0;

    {
        double a0;
         ::QgsGeometrySnapper::SnapMode a1 = QgsGeometrySnapper::PreferNodes;

        static const char *sipKwdList[] = {
            sipName_snapTolerance,
            sipName_mode,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "d|E", &a0, sipType_QgsGeometrySnapper_SnapMode, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsInternalGeometrySnapper(a0,a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsInternalGeometrySnapper* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsInternalGeometrySnapper, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsInternalGeometrySnapper(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsInternalGeometrySnapper[] = {
    {SIP_MLNAME_CAST(sipName_snapFeature), (PyCFunction)meth_QgsInternalGeometrySnapper_snapFeature, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsInternalGeometrySnapper_snapFeature)},
    {SIP_MLNAME_CAST(sipName_snappedGeometries), meth_QgsInternalGeometrySnapper_snappedGeometries, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsInternalGeometrySnapper_snappedGeometries)}
};

PyDoc_STRVAR(doc_QgsInternalGeometrySnapper, "QgsInternalGeometrySnapper(snapTolerance: float, mode: QgsGeometrySnapper.SnapMode = QgsGeometrySnapper.PreferNodes)\n"
"Constructor for QgsInternalGeometrySnapper. The ``snapTolerance`` and ``mode`` parameters dictate\n"
"how geometries will be snapped by the snapper.\n"
"\n"
"QgsInternalGeometrySnapper(QgsInternalGeometrySnapper)\n"
"\n"
"QgsInternalGeometrySnapper allows a set of geometries to be snapped to each other. It can be used to close gaps in layers.\n"
"\n"
"To use :py:class:`QgsInternalGeometrySnapper`, first construct the snapper using the desired snap parameters. Then,\n"
"features are fed to to the snapper one-by-one by calling snapFeature(). Each feature passed by calling\n"
"snapFeature() will be snapped to any features which have already been processed by the snapper.\n"
"\n"
"After processing all desired features, the results can be fetched by calling snappedGeometries().\n"
"The returned QgsGeometryMap can be passed to QgsVectorDataProvider.changeGeometryValues() to save\n"
"the snapped geometries back to the source layer.\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsInternalGeometrySnapper = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsInternalGeometrySnapper = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsInternalGeometrySnapper,
        {0},
        &plugin_QgsInternalGeometrySnapper
    },
    {
        sipNameNr_QgsInternalGeometrySnapper,
        {0, 0, 1},
        2, methods_QgsInternalGeometrySnapper,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsInternalGeometrySnapper,
    -1,
    -1,
    0,
    0,
    init_type_QgsInternalGeometrySnapper,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsInternalGeometrySnapper,
    0,
    0,
    0,
    release_QgsInternalGeometrySnapper,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 24 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/qgsgeometrysnapper.sip"
#include "qgsgeometrysnapper.h"
#line 4096 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 22 "core/auto_generated/qgsfeaturesource.sip"
#include "qgsfeaturesource.h"
#line 4100 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4103 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 4109 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 45 "core/auto_generated/geometry/qgsgeometry.sip"
#include "qgsgeometry.h"
#line 4112 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4115 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 4118 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4121 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 247 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4124 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 235 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4127 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
#include <qobject.h>
#line 4130 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 4133 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 4136 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4139 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 30 "/usr/share/sip/PyQt5/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 4142 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 149 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4145 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4148 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qthread.sip"
#include <qthread.h>
#line 4151 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4154 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qregexp.sip"
#include <qregexp.h>
#line 4157 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 4160 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 4163 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


class sipQgsGeometrySnapper : public  ::QgsGeometrySnapper
{
public:
    sipQgsGeometrySnapper( ::QgsFeatureSource*);
    virtual ~sipQgsGeometrySnapper();

    int qt_metacall(QMetaObject::Call,int,void **);
    void *qt_metacast(const char *);
    const QMetaObject *metaObject() const;

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::QObject* sipProtect_sender() const;
    int sipProtect_receivers(const char*) const;
    void sipProtectVirt_timerEvent(bool, ::QTimerEvent*);
    void sipProtectVirt_childEvent(bool, ::QChildEvent*);
    void sipProtectVirt_customEvent(bool, ::QEvent*);
    void sipProtectVirt_connectNotify(bool,const  ::QMetaMethod&);
    void sipProtectVirt_disconnectNotify(bool,const  ::QMetaMethod&);
    int sipProtect_senderSignalIndex() const;
    bool sipProtect_isSignalConnected(const  ::QMetaMethod&) const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool event( ::QEvent*);
    bool eventFilter( ::QObject*, ::QEvent*);
    void timerEvent( ::QTimerEvent*);
    void childEvent( ::QChildEvent*);
    void customEvent( ::QEvent*);
    void connectNotify(const  ::QMetaMethod&);
    void disconnectNotify(const  ::QMetaMethod&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsGeometrySnapper(const sipQgsGeometrySnapper &);
    sipQgsGeometrySnapper &operator = (const sipQgsGeometrySnapper &);

    char sipPyMethods[7];
};

sipQgsGeometrySnapper::sipQgsGeometrySnapper( ::QgsFeatureSource*a0):  ::QgsGeometrySnapper(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometrySnapper::~sipQgsGeometrySnapper()
{
    sipInstanceDestroyed(sipPySelf);
}

const QMetaObject *sipQgsGeometrySnapper::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip__analysis_qt_metaobject(sipPySelf,sipType_QgsGeometrySnapper);

    return  ::QgsGeometrySnapper::metaObject();
}

int sipQgsGeometrySnapper::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QgsGeometrySnapper::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip__analysis_qt_metacall(sipPySelf,sipType_QgsGeometrySnapper,_c,_id,_a);

    return _id;
}

void *sipQgsGeometrySnapper::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip__analysis_qt_metacast(sipPySelf, sipType_QgsGeometrySnapper, _clname, &sipCpp) ? sipCpp :  ::QgsGeometrySnapper::qt_metacast(_clname));
}

bool sipQgsGeometrySnapper::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_event);

    if (!sipMeth)
        return  ::QgsGeometrySnapper::event(a0);

    extern bool sipVH__analysis_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH__analysis_7(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQgsGeometrySnapper::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_eventFilter);

    if (!sipMeth)
        return  ::QgsGeometrySnapper::eventFilter(a0,a1);

    extern bool sipVH__analysis_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH__analysis_6(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQgsGeometrySnapper::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QgsGeometrySnapper::timerEvent(a0);
        return;
    }

    extern void sipVH__analysis_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH__analysis_5(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGeometrySnapper::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_childEvent);

    if (!sipMeth)
    {
         ::QgsGeometrySnapper::childEvent(a0);
        return;
    }

    extern void sipVH__analysis_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH__analysis_4(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGeometrySnapper::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_customEvent);

    if (!sipMeth)
    {
         ::QgsGeometrySnapper::customEvent(a0);
        return;
    }

    extern void sipVH__analysis_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH__analysis_3(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGeometrySnapper::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QgsGeometrySnapper::connectNotify(a0);
        return;
    }

    extern void sipVH__analysis_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH__analysis_2(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGeometrySnapper::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QgsGeometrySnapper::disconnectNotify(a0);
        return;
    }

    extern void sipVH__analysis_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH__analysis_2(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::QObject* sipQgsGeometrySnapper::sipProtect_sender() const
{
    return  ::QObject::sender();
}

int sipQgsGeometrySnapper::sipProtect_receivers(const char*a0) const
{
    return  ::QObject::receivers(a0);
}

void sipQgsGeometrySnapper::sipProtectVirt_timerEvent(bool sipSelfWasArg, ::QTimerEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::timerEvent(a0) : timerEvent(a0));
}

void sipQgsGeometrySnapper::sipProtectVirt_childEvent(bool sipSelfWasArg, ::QChildEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::childEvent(a0) : childEvent(a0));
}

void sipQgsGeometrySnapper::sipProtectVirt_customEvent(bool sipSelfWasArg, ::QEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::customEvent(a0) : customEvent(a0));
}

void sipQgsGeometrySnapper::sipProtectVirt_connectNotify(bool sipSelfWasArg,const  ::QMetaMethod& a0)
{
    (sipSelfWasArg ?  ::QObject::connectNotify(a0) : connectNotify(a0));
}

void sipQgsGeometrySnapper::sipProtectVirt_disconnectNotify(bool sipSelfWasArg,const  ::QMetaMethod& a0)
{
    (sipSelfWasArg ?  ::QObject::disconnectNotify(a0) : disconnectNotify(a0));
}

int sipQgsGeometrySnapper::sipProtect_senderSignalIndex() const
{
    return  ::QObject::senderSignalIndex();
}

bool sipQgsGeometrySnapper::sipProtect_isSignalConnected(const  ::QMetaMethod& a0) const
{
    return  ::QObject::isSignalConnected(a0);
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_sender, "sender(self) -> QObject");

extern "C" {static PyObject *meth_QgsGeometrySnapper_sender(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_sender(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp))
        {
             ::QObject*sipRes = 0;

#line 560 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL and Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        if (!sipRes)
        {
            typedef QObject *(*qtcore_qobject_sender_t)();
        
            static qtcore_qobject_sender_t qtcore_qobject_sender = 0;
        
            if (!qtcore_qobject_sender)
            {
                qtcore_qobject_sender = (qtcore_qobject_sender_t)sipImportSymbol("qtcore_qobject_sender");
                Q_ASSERT(qtcore_qobject_sender);
            }
        
            sipRes = qtcore_qobject_sender();
        }
#line 4457 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_sender, doc_QgsGeometrySnapper_sender);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_receivers, "receivers(self, PYQT_SIGNAL) -> int");

extern "C" {static PyObject *meth_QgsGeometrySnapper_receivers(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_receivers(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BP0", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, &a0))
        {
            int sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 591 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
        // We need to handle the signal object.  Import the helper if it hasn't already
        // been done.
        typedef sipErrorState (*pyqt5_get_signal_signature_t)(PyObject *, const QObject *, const QByteArray &);
        
        static pyqt5_get_signal_signature_t pyqt5_get_signal_signature = 0;
        
        if (!pyqt5_get_signal_signature)
        {
            pyqt5_get_signal_signature = (pyqt5_get_signal_signature_t)sipImportSymbol("pyqt5_get_signal_signature");
            Q_ASSERT(pyqt5_get_signal_signature);
        }
        
        QByteArray signal_signature;
            
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        if ((sipError = pyqt5_get_signal_signature(a0, sipCpp, signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->receivers(signal_signature.constData());
        }
        #else
        if ((sipError = pyqt5_get_signal_signature(a0, static_cast<const QObject *>(sipCpp), signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->sipProtect_receivers(signal_signature.constData());
        }
        #endif
        else if (sipError == sipErrorContinue)
        {
            sipError = sipBadCallableArg(0, a0);
        }
#line 4517 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return SIPLong_FromLong(sipRes);
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_receivers, doc_QgsGeometrySnapper_receivers);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_timerEvent, "timerEvent(self, QTimerEvent)");

extern "C" {static PyObject *meth_QgsGeometrySnapper_timerEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_timerEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QTimerEvent* a0;
        sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QTimerEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_timerEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_timerEvent, doc_QgsGeometrySnapper_timerEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_childEvent, "childEvent(self, QChildEvent)");

extern "C" {static PyObject *meth_QgsGeometrySnapper_childEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_childEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QChildEvent* a0;
        sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QChildEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_childEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_childEvent, doc_QgsGeometrySnapper_childEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_customEvent, "customEvent(self, QEvent)");

extern "C" {static PyObject *meth_QgsGeometrySnapper_customEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_customEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QEvent* a0;
        sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_customEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_customEvent, doc_QgsGeometrySnapper_customEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_connectNotify, "connectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QgsGeometrySnapper_connectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_connectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
        sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QMetaMethod, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_connectNotify(sipSelfWasArg,*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_connectNotify, doc_QgsGeometrySnapper_connectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_disconnectNotify, "disconnectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QgsGeometrySnapper_disconnectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
        sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QMetaMethod, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_disconnectNotify(sipSelfWasArg,*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_disconnectNotify, doc_QgsGeometrySnapper_disconnectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_senderSignalIndex, "senderSignalIndex(self) -> int");

extern "C" {static PyObject *meth_QgsGeometrySnapper_senderSignalIndex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_senderSignalIndex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_senderSignalIndex();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_senderSignalIndex, doc_QgsGeometrySnapper_senderSignalIndex);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_isSignalConnected, "isSignalConnected(self, QMetaMethod) -> bool");

extern "C" {static PyObject *meth_QgsGeometrySnapper_isSignalConnected(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_isSignalConnected(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QMetaMethod* a0;
        const sipQgsGeometrySnapper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QMetaMethod, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_isSignalConnected(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_isSignalConnected, doc_QgsGeometrySnapper_isSignalConnected);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_snapGeometry, "snapGeometry(self, geometry: QgsGeometry, snapTolerance: float, mode: QgsGeometrySnapper.SnapMode = QgsGeometrySnapper.PreferNodes) -> QgsGeometry\n"
"Snaps a geometry to the reference layer and returns the result. The geometry must be in the same\n"
"CRS as the reference layer, and must have the same type as the reference layer geometry. The snap tolerance\n"
"is specified in the layer units for the reference layer.\n"
"\n"
"snapGeometry(geometry: QgsGeometry, snapTolerance: float, referenceGeometries: object, mode: QgsGeometrySnapper.SnapMode = QgsGeometrySnapper.PreferNodes) -> QgsGeometry\n"
"Snaps a single geometry against a list of reference geometries.");

extern "C" {static PyObject *meth_QgsGeometrySnapper_snapGeometry(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_snapGeometry(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometry* a0;
        double a1;
         ::QgsGeometrySnapper::SnapMode a2 =  ::QgsGeometrySnapper::PreferNodes;
        const  ::QgsGeometrySnapper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_geometry,
            sipName_snapTolerance,
            sipName_mode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9d|E", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QgsGeometry, &a0, &a1, sipType_QgsGeometrySnapper_SnapMode, &a2))
        {
             ::QgsGeometry*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometry(sipCpp->snapGeometry(*a0,a1,a2));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGeometry,NULL);
        }
    }

    {
        const  ::QgsGeometry* a0;
        double a1;
        const QList< ::QgsGeometry>* a2;
        int a2State = 0;
         ::QgsGeometrySnapper::SnapMode a3 =  ::QgsGeometrySnapper::PreferNodes;

        static const char *sipKwdList[] = {
            sipName_geometry,
            sipName_snapTolerance,
            sipName_referenceGeometries,
            sipName_mode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ1|E", sipType_QgsGeometry, &a0, &a1, sipType_QList_0100QgsGeometry,&a2, &a2State, sipType_QgsGeometrySnapper_SnapMode, &a3))
        {
             ::QgsGeometry*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometry( ::QgsGeometrySnapper::snapGeometry(*a0,a1,*a2,a3));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QList< ::QgsGeometry> *>(a2),sipType_QList_0100QgsGeometry,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QList< ::QgsGeometry> *>(a2),sipType_QList_0100QgsGeometry,a2State);

            return sipConvertFromNewType(sipRes,sipType_QgsGeometry,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_snapGeometry, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometrySnapper_snapFeatures, "snapFeatures(self, features: object, snapTolerance: float, mode: QgsGeometrySnapper.SnapMode = QgsGeometrySnapper.PreferNodes) -> object\n"
"Snaps a set of features to the reference layer and returns the result. This operation is\n"
"multithreaded for performance. The featureSnapped() signal will be emitted each time a feature\n"
"is processed. The snap tolerance is specified in the layer units for the reference layer.");

extern "C" {static PyObject *meth_QgsGeometrySnapper_snapFeatures(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometrySnapper_snapFeatures(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeatureList* a0;
        int a0State = 0;
        double a1;
         ::QgsGeometrySnapper::SnapMode a2 =  ::QgsGeometrySnapper::PreferNodes;
         ::QgsGeometrySnapper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_features,
            sipName_snapTolerance,
            sipName_mode,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1d|E", &sipSelf, sipType_QgsGeometrySnapper, &sipCpp, sipType_QList_0100QgsFeature,&a0, &a0State, &a1, sipType_QgsGeometrySnapper_SnapMode, &a2))
        {
             ::QgsFeatureList*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsFeatureList(sipCpp->snapFeatures(*a0,a1,a2));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QgsFeatureList *>(a0),sipType_QList_0100QgsFeature,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QgsFeatureList *>(a0),sipType_QList_0100QgsFeature,a0State);

            return sipConvertFromNewType(sipRes,sipType_QList_0100QgsFeature,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometrySnapper, sipName_snapFeatures, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsGeometrySnapper(void *, const sipTypeDef *);}
static void *cast_QgsGeometrySnapper(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsGeometrySnapper *sipCpp = reinterpret_cast< ::QgsGeometrySnapper *>(sipCppV);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometrySnapper(void *, int);}
static void release_QgsGeometrySnapper(void *sipCppV, int)
{
     ::QgsGeometrySnapper *sipCpp = reinterpret_cast< ::QgsGeometrySnapper *>(sipCppV);

    Py_BEGIN_ALLOW_THREADS

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGeometrySnapper(sipSimpleWrapper *);}
static void dealloc_QgsGeometrySnapper(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsGeometrySnapper *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometrySnapper(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsGeometrySnapper(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometrySnapper(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsGeometrySnapper *sipCpp = 0;

    {
         ::QgsFeatureSource* a0;

        static const char *sipKwdList[] = {
            sipName_referenceSource,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8", sipType_QgsFeatureSource, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometrySnapper(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsGeometrySnapper[] = {{6, 0, 1}};


static PyMethodDef methods_QgsGeometrySnapper[] = {
    {SIP_MLNAME_CAST(sipName_childEvent), (PyCFunction)meth_QgsGeometrySnapper_childEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_connectNotify), (PyCFunction)meth_QgsGeometrySnapper_connectNotify, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_customEvent), (PyCFunction)meth_QgsGeometrySnapper_customEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), (PyCFunction)meth_QgsGeometrySnapper_disconnectNotify, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_isSignalConnected), (PyCFunction)meth_QgsGeometrySnapper_isSignalConnected, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_receivers), (PyCFunction)meth_QgsGeometrySnapper_receivers, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_sender), (PyCFunction)meth_QgsGeometrySnapper_sender, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_senderSignalIndex), (PyCFunction)meth_QgsGeometrySnapper_senderSignalIndex, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_snapFeatures), (PyCFunction)meth_QgsGeometrySnapper_snapFeatures, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometrySnapper_snapFeatures)},
    {SIP_MLNAME_CAST(sipName_snapGeometry), (PyCFunction)meth_QgsGeometrySnapper_snapGeometry, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometrySnapper_snapGeometry)},
    {SIP_MLNAME_CAST(sipName_timerEvent), (PyCFunction)meth_QgsGeometrySnapper_timerEvent, METH_VARARGS|METH_KEYWORDS, NULL}
};

static sipEnumMemberDef enummembers_QgsGeometrySnapper[] = {
    {sipName_EndPointPreferClosest, static_cast<int>( ::QgsGeometrySnapper::EndPointPreferClosest), 40},
    {sipName_EndPointPreferNodes, static_cast<int>( ::QgsGeometrySnapper::EndPointPreferNodes), 40},
    {sipName_EndPointToEndPoint, static_cast<int>( ::QgsGeometrySnapper::EndPointToEndPoint), 40},
    {sipName_PreferClosest, static_cast<int>( ::QgsGeometrySnapper::PreferClosest), 40},
    {sipName_PreferClosestNoExtraVertices, static_cast<int>( ::QgsGeometrySnapper::PreferClosestNoExtraVertices), 40},
    {sipName_PreferNodes, static_cast<int>( ::QgsGeometrySnapper::PreferNodes), 40},
    {sipName_PreferNodesNoExtraVertices, static_cast<int>( ::QgsGeometrySnapper::PreferNodesNoExtraVertices), 40},
};

PyDoc_STRVAR(doc_QgsGeometrySnapper, "QgsGeometrySnapper(referenceSource: QgsFeatureSource)\n"
"Constructor for QgsGeometrySnapper. A reference feature source which contains geometries to snap to must be\n"
"set. It is assumed that all geometries snapped using this object will have the\n"
"same CRS as the reference source (ie, no reprojection is performed).\n"
"\n"
"QgsGeometrySnapper allows a geometry to be snapped to the geometries within a\n"
"different reference layer. Vertices in the geometries will be modified to\n"
"match the reference layer features within a specified snap tolerance.\n"
"\n"
".. versionadded:: 3.0");


/* Define this type's signals. */
static const pyqt5QtSignal signals_QgsGeometrySnapper[] = {
    {"featureSnapped()", "Emitted each time a feature has been processed when calling snapFeatures()", 0, 0},
    {0, 0, 0, 0}
};


static pyqt5ClassPluginDef plugin_QgsGeometrySnapper = {
    & ::QgsGeometrySnapper::staticMetaObject,
    0,
    signals_QgsGeometrySnapper,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometrySnapper = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometrySnapper,
        {0},
        &plugin_QgsGeometrySnapper
    },
    {
        sipNameNr_QgsGeometrySnapper,
        {0, 0, 1},
        11, methods_QgsGeometrySnapper,
        7, enummembers_QgsGeometrySnapper,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometrySnapper,
    -1,
    -1,
    supers_QgsGeometrySnapper,
    0,
    init_type_QgsGeometrySnapper,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometrySnapper,
    0,
    0,
    0,
    release_QgsGeometrySnapper,
    cast_QgsGeometrySnapper,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 32 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/mesh/qgsmeshcalculator.sip"
#include "qgsmeshcalculator.h"
#line 5161 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 5165 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 26 "core/auto_generated/geometry/qgsrectangle.sip"
#include "qgsrectangle.h"
#line 5168 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 74 "core/auto_generated/mesh/qgsmeshlayer.sip"
#include "qgsmeshlayer.h"
#line 5171 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 45 "core/auto_generated/geometry/qgsgeometry.sip"
#include "qgsgeometry.h"
#line 5174 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 5177 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsMeshCalculator_processCalculation, "processCalculation(self, feedback: QgsFeedback = None) -> QgsMeshCalculator.Result\n"
"Starts the calculation, writes new dataset group to file and adds it to the mesh layer\n"
"\n"
":param feedback: The optional feedback argument for progress reporting and cancellation support\n"
"\n"
":return: QgsMeshCalculator.Success in case of success");

extern "C" {static PyObject *meth_QgsMeshCalculator_processCalculation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsMeshCalculator_processCalculation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
         ::QgsMeshCalculator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsMeshCalculator, &sipCpp, sipType_QgsFeedback, &a0))
        {
             ::QgsMeshCalculator::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->processCalculation(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsMeshCalculator_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsMeshCalculator, sipName_processCalculation, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsMeshCalculator_expression_valid, "expression_valid(formulaString: str, layer: QgsMeshLayer) -> QgsMeshCalculator.Result\n"
"Returns whether formula is valid for particular mesh layer\n"
"\n"
":param formulaString: formula/expression to evaluate. Consists of dataset group names, operators and numbers\n"
":param layer: mesh layer with dataset groups references in formulaString\n"
"\n"
":return: QgsMeshCalculator.Success in case of success");

extern "C" {static PyObject *meth_QgsMeshCalculator_expression_valid(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsMeshCalculator_expression_valid(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QgsMeshLayer* a1;

        static const char *sipKwdList[] = {
            sipName_formulaString,
            sipName_layer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J1J8", sipType_QString,&a0, &a0State, sipType_QgsMeshLayer, &a1))
        {
             ::QgsMeshCalculator::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes =  ::QgsMeshCalculator::expression_valid(*a0,a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsMeshCalculator_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsMeshCalculator, sipName_expression_valid, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsMeshCalculator(void *, int);}
static void release_QgsMeshCalculator(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsMeshCalculator *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsMeshCalculator(sipSimpleWrapper *);}
static void dealloc_QgsMeshCalculator(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsMeshCalculator(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsMeshCalculator(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsMeshCalculator(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsMeshCalculator *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QgsRectangle* a2;
        double a3;
        double a4;
         ::QgsMeshLayer* a5;

        static const char *sipKwdList[] = {
            sipName_formulaString,
            sipName_outputFile,
            sipName_outputExtent,
            sipName_startTime,
            sipName_endTime,
            sipName_layer,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J9ddJ8", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QgsRectangle, &a2, &a3, &a4, sipType_QgsMeshLayer, &a5))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsMeshCalculator(*a0,*a1,*a2,a3,a4,a5);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            return sipCpp;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QgsGeometry* a2;
        double a3;
        double a4;
         ::QgsMeshLayer* a5;

        static const char *sipKwdList[] = {
            sipName_formulaString,
            sipName_outputFile,
            sipName_outputMask,
            sipName_startTime,
            sipName_endTime,
            sipName_layer,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J9ddJ8", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QgsGeometry, &a2, &a3, &a4, sipType_QgsMeshLayer, &a5))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsMeshCalculator(*a0,*a1,*a2,a3,a4,a5);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            return sipCpp;
        }
    }

    {
        const  ::QgsMeshCalculator* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsMeshCalculator, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsMeshCalculator(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsMeshCalculator[] = {
    {SIP_MLNAME_CAST(sipName_expression_valid), (PyCFunction)meth_QgsMeshCalculator_expression_valid, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsMeshCalculator_expression_valid)},
    {SIP_MLNAME_CAST(sipName_processCalculation), (PyCFunction)meth_QgsMeshCalculator_processCalculation, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsMeshCalculator_processCalculation)}
};

static sipEnumMemberDef enummembers_QgsMeshCalculator[] = {
    {sipName_Canceled, static_cast<int>( ::QgsMeshCalculator::Canceled), 65},
    {sipName_CreateOutputError, static_cast<int>( ::QgsMeshCalculator::CreateOutputError), 65},
    {sipName_EvaluateError, static_cast<int>( ::QgsMeshCalculator::EvaluateError), 65},
    {sipName_InputLayerError, static_cast<int>( ::QgsMeshCalculator::InputLayerError), 65},
    {sipName_InvalidDatasets, static_cast<int>( ::QgsMeshCalculator::InvalidDatasets), 65},
    {sipName_MemoryError, static_cast<int>( ::QgsMeshCalculator::MemoryError), 65},
    {sipName_ParserError, static_cast<int>( ::QgsMeshCalculator::ParserError), 65},
    {sipName_Success, static_cast<int>( ::QgsMeshCalculator::Success), 65},
};

PyDoc_STRVAR(doc_QgsMeshCalculator, "QgsMeshCalculator(formulaString: str, outputFile: str, outputExtent: QgsRectangle, startTime: float, endTime: float, layer: QgsMeshLayer)\n"
"Creates calculator with bounding box (rectangular) mask\n"
"\n"
":param formulaString: formula/expression to evaluate. Consists of dataset group names, operators and numbers\n"
":param outputFile: file to store the resulting dataset group data\n"
":param outputExtent: spatial filter defined by rectangle\n"
":param startTime: time filter defining the starting dataset\n"
":param endTime: time filter defining the ending dataset\n"
":param layer: mesh layer with dataset groups references in formulaString\n"
"\n"
"QgsMeshCalculator(formulaString: str, outputFile: str, outputMask: QgsGeometry, startTime: float, endTime: float, layer: QgsMeshLayer)\n"
"Creates calculator with geometry mask\n"
"\n"
":param formulaString: formula/expression to evaluate. Consists of dataset group names, operators and numbers\n"
":param outputFile: file to store the resulting dataset group data\n"
":param outputMask: spatial filter defined by geometry\n"
":param startTime: time filter defining the starting dataset\n"
":param endTime: time filter defining the ending dataset\n"
":param layer: mesh layer with dataset groups references in formulaString\n"
"\n"
"QgsMeshCalculator(QgsMeshCalculator)\n"
"\n"
"Performs mesh layer calculations.\n"
"\n"
"Mesh calculator can do various mathematical operations\n"
"between dataset groups from a single mesh layer.\n"
"Resulting dataset group is added to the mesh layer.\n"
"Result can be filtered by extent or a vector layer mask\n"
"spatially and by selection of times.\n"
"\n"
"Note: only dataset groups defined on vertices are\n"
"implemented and supported\n"
"\n"
".. versionadded:: 3.6");


static pyqt5ClassPluginDef plugin_QgsMeshCalculator = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsMeshCalculator = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsMeshCalculator,
        {0},
        &plugin_QgsMeshCalculator
    },
    {
        sipNameNr_QgsMeshCalculator,
        {0, 0, 1},
        2, methods_QgsMeshCalculator,
        8, enummembers_QgsMeshCalculator,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsMeshCalculator,
    -1,
    -1,
    0,
    0,
    init_type_QgsMeshCalculator,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsMeshCalculator,
    0,
    0,
    0,
    release_QgsMeshCalculator,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgstotalcurvaturefilter.sip"
#include "qgstotalcurvaturefilter.h"
#line 5539 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 5543 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 5546 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


class sipQgsTotalCurvatureFilter : public  ::QgsTotalCurvatureFilter
{
public:
    sipQgsTotalCurvatureFilter(const  ::QString&,const  ::QString&,const  ::QString&);
    sipQgsTotalCurvatureFilter(const  ::QgsTotalCurvatureFilter&);
    virtual ~sipQgsTotalCurvatureFilter();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    float sipProtectVirt_processNineCellWindow(bool,float*,float*,float*,float*,float*,float*,float*,float*,float*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    float processNineCellWindow(float*,float*,float*,float*,float*,float*,float*,float*,float*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsTotalCurvatureFilter(const sipQgsTotalCurvatureFilter &);
    sipQgsTotalCurvatureFilter &operator = (const sipQgsTotalCurvatureFilter &);

    char sipPyMethods[1];
};

sipQgsTotalCurvatureFilter::sipQgsTotalCurvatureFilter(const  ::QString& a0,const  ::QString& a1,const  ::QString& a2):  ::QgsTotalCurvatureFilter(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsTotalCurvatureFilter::sipQgsTotalCurvatureFilter(const  ::QgsTotalCurvatureFilter& a0):  ::QgsTotalCurvatureFilter(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsTotalCurvatureFilter::~sipQgsTotalCurvatureFilter()
{
    sipInstanceDestroyed(sipPySelf);
}

float sipQgsTotalCurvatureFilter::processNineCellWindow(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_processNineCellWindow);

    if (!sipMeth)
        return  ::QgsTotalCurvatureFilter::processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8);

    extern float sipVH__analysis_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, float*,float*,float*,float*,float*,float*,float*,float*,float*);

    return sipVH__analysis_1(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

float sipQgsTotalCurvatureFilter::sipProtectVirt_processNineCellWindow(bool sipSelfWasArg,float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return (sipSelfWasArg ?  ::QgsTotalCurvatureFilter::processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8) : processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8));
}


PyDoc_STRVAR(doc_QgsTotalCurvatureFilter_processNineCellWindow, "processNineCellWindow(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates total curvature from nine input values. The input values and the output value can be equal to the\n"
"nodata value if not present or outside of the border. Must be implemented by subclasses*");

extern "C" {static PyObject *meth_QgsTotalCurvatureFilter_processNineCellWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsTotalCurvatureFilter_processNineCellWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsTotalCurvatureFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsTotalCurvatureFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtectVirt_processNineCellWindow(sipSelfWasArg,&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsTotalCurvatureFilter, sipName_processNineCellWindow, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsTotalCurvatureFilter(void *, const sipTypeDef *);}
static void *cast_QgsTotalCurvatureFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsTotalCurvatureFilter *sipCpp = reinterpret_cast< ::QgsTotalCurvatureFilter *>(sipCppV);

    if (targetType == sipType_QgsNineCellFilter)
        return static_cast< ::QgsNineCellFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsTotalCurvatureFilter(void *, int);}
static void release_QgsTotalCurvatureFilter(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsTotalCurvatureFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsTotalCurvatureFilter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsTotalCurvatureFilter(sipSimpleWrapper *);}
static void dealloc_QgsTotalCurvatureFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsTotalCurvatureFilter *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsTotalCurvatureFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsTotalCurvatureFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsTotalCurvatureFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsTotalCurvatureFilter *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsTotalCurvatureFilter(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsTotalCurvatureFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsTotalCurvatureFilter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsTotalCurvatureFilter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsTotalCurvatureFilter[] = {{70, 255, 1}};


static PyMethodDef methods_QgsTotalCurvatureFilter[] = {
    {SIP_MLNAME_CAST(sipName_processNineCellWindow), (PyCFunction)meth_QgsTotalCurvatureFilter_processNineCellWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsTotalCurvatureFilter_processNineCellWindow)}
};

PyDoc_STRVAR(doc_QgsTotalCurvatureFilter, "\n"
"\n"
"\n"
"Calculates total curvature as described by Wilson, Gallant (2000): terrain analysis*");


static pyqt5ClassPluginDef plugin_QgsTotalCurvatureFilter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsTotalCurvatureFilter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsTotalCurvatureFilter,
        {0},
        &plugin_QgsTotalCurvatureFilter
    },
    {
        sipNameNr_QgsTotalCurvatureFilter,
        {0, 0, 1},
        1, methods_QgsTotalCurvatureFilter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsTotalCurvatureFilter,
    -1,
    -1,
    supers_QgsTotalCurvatureFilter,
    0,
    init_type_QgsTotalCurvatureFilter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsTotalCurvatureFilter,
    0,
    0,
    0,
    release_QgsTotalCurvatureFilter,
    cast_QgsTotalCurvatureFilter,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 17 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrastercalcnode.sip"
#include "qgsrastercalcnode.h"
#line 5857 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 16 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrastermatrix.sip"
#include "qgsrastermatrix.h"
#line 5861 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 5864 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 149 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 5867 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


PyDoc_STRVAR(doc_QgsRasterCalcNode_type, "type(self) -> QgsRasterCalcNode.Type\n"
"QgsRasterCalcNode cannot be copied");

extern "C" {static PyObject *meth_QgsRasterCalcNode_type(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalcNode_type(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterCalcNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterCalcNode, &sipCpp))
        {
             ::QgsRasterCalcNode::Type sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->type();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsRasterCalcNode_Type);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalcNode, sipName_type, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterCalcNode_setLeft, "setLeft(self, left: QgsRasterCalcNode)");

extern "C" {static PyObject *meth_QgsRasterCalcNode_setLeft(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalcNode_setLeft(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterCalcNode* a0;
         ::QgsRasterCalcNode *sipCpp;

        static const char *sipKwdList[] = {
            sipName_left,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsRasterCalcNode, &sipCpp, sipType_QgsRasterCalcNode, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setLeft(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalcNode, sipName_setLeft, doc_QgsRasterCalcNode_setLeft);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterCalcNode_setRight, "setRight(self, right: QgsRasterCalcNode)");

extern "C" {static PyObject *meth_QgsRasterCalcNode_setRight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalcNode_setRight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterCalcNode* a0;
         ::QgsRasterCalcNode *sipCpp;

        static const char *sipKwdList[] = {
            sipName_right,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsRasterCalcNode, &sipCpp, sipType_QgsRasterCalcNode, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setRight(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalcNode, sipName_setRight, doc_QgsRasterCalcNode_setRight);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterCalcNode_toString, "toString(self, cStyle: bool = False) -> str\n"
"Returns a string representation of the expression\n"
"\n"
":param cStyle: if ``True`` operators will follow C syntax\n"
"\n"
".. versionadded:: 3.6");

extern "C" {static PyObject *meth_QgsRasterCalcNode_toString(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalcNode_toString(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0 = 0;
        const  ::QgsRasterCalcNode *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cStyle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|b", &sipSelf, sipType_QgsRasterCalcNode, &sipCpp, &a0))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->toString(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalcNode, sipName_toString, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterCalcNode_findNodes, "findNodes(self, type: QgsRasterCalcNode.Type) -> object\n"
"Returns a list of nodes of a specific ``type``\n"
"\n"
".. versionadded:: 3.6");

extern "C" {static PyObject *meth_QgsRasterCalcNode_findNodes(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalcNode_findNodes(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterCalcNode::Type a0;
        const  ::QgsRasterCalcNode *sipCpp;

        static const char *sipKwdList[] = {
            sipName_type,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BE", &sipSelf, sipType_QgsRasterCalcNode, &sipCpp, sipType_QgsRasterCalcNode_Type, &a0))
        {
            QList<const  ::QgsRasterCalcNode*>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new QList<const  ::QgsRasterCalcNode*>(sipCpp->findNodes(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0111QgsRasterCalcNode,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalcNode, sipName_findNodes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterCalcNode_parseRasterCalcString, "parseRasterCalcString(str: str, parserErrorMsg: str) -> QgsRasterCalcNode");

extern "C" {static PyObject *meth_QgsRasterCalcNode_parseRasterCalcString(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalcNode_parseRasterCalcString(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QString* a1;
        int a1State = 0;

        static const char *sipKwdList[] = {
            sipName_str,
            sipName_parserErrorMsg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State))
        {
             ::QgsRasterCalcNode*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes =  ::QgsRasterCalcNode::parseRasterCalcString(*a0,*a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(a1,sipType_QString,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(a1,sipType_QString,a1State);

            return sipConvertFromNewType(sipRes,sipType_QgsRasterCalcNode,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalcNode, sipName_parseRasterCalcString, doc_QgsRasterCalcNode_parseRasterCalcString);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsRasterCalcNode(void *, int);}
static void release_QgsRasterCalcNode(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsRasterCalcNode *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsRasterCalcNode(sipSimpleWrapper *);}
static void dealloc_QgsRasterCalcNode(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsRasterCalcNode(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsRasterCalcNode(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsRasterCalcNode(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsRasterCalcNode *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalcNode();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        double a0;

        static const char *sipKwdList[] = {
            sipName_number,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "d", &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalcNode(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
         ::QgsRasterMatrix* a0;

        static const char *sipKwdList[] = {
            sipName_matrix,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8", sipType_QgsRasterMatrix, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalcNode(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
         ::QgsRasterCalcNode::Operator a0;
         ::QgsRasterCalcNode* a1;
         ::QgsRasterCalcNode* a2;

        static const char *sipKwdList[] = {
            sipName_op,
            sipName_left,
            sipName_right,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "EJ8J8", sipType_QgsRasterCalcNode_Operator, &a0, sipType_QgsRasterCalcNode, &a1, sipType_QgsRasterCalcNode, &a2))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalcNode(a0,a1,a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_rasterName,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1", sipType_QString,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalcNode(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsRasterCalcNode[] = {
    {SIP_MLNAME_CAST(sipName_findNodes), (PyCFunction)meth_QgsRasterCalcNode_findNodes, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterCalcNode_findNodes)},
    {SIP_MLNAME_CAST(sipName_parseRasterCalcString), (PyCFunction)meth_QgsRasterCalcNode_parseRasterCalcString, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterCalcNode_parseRasterCalcString)},
    {SIP_MLNAME_CAST(sipName_setLeft), (PyCFunction)meth_QgsRasterCalcNode_setLeft, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterCalcNode_setLeft)},
    {SIP_MLNAME_CAST(sipName_setRight), (PyCFunction)meth_QgsRasterCalcNode_setRight, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterCalcNode_setRight)},
    {SIP_MLNAME_CAST(sipName_toString), (PyCFunction)meth_QgsRasterCalcNode_toString, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterCalcNode_toString)},
    {SIP_MLNAME_CAST(sipName_type), meth_QgsRasterCalcNode_type, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterCalcNode_type)}
};

static sipEnumMemberDef enummembers_QgsRasterCalcNode[] = {
    {sipName_opACOS, static_cast<int>( ::QgsRasterCalcNode::opACOS), 72},
    {sipName_opAND, static_cast<int>( ::QgsRasterCalcNode::opAND), 72},
    {sipName_opASIN, static_cast<int>( ::QgsRasterCalcNode::opASIN), 72},
    {sipName_opATAN, static_cast<int>( ::QgsRasterCalcNode::opATAN), 72},
    {sipName_opCOS, static_cast<int>( ::QgsRasterCalcNode::opCOS), 72},
    {sipName_opDIV, static_cast<int>( ::QgsRasterCalcNode::opDIV), 72},
    {sipName_opEQ, static_cast<int>( ::QgsRasterCalcNode::opEQ), 72},
    {sipName_opGE, static_cast<int>( ::QgsRasterCalcNode::opGE), 72},
    {sipName_opGT, static_cast<int>( ::QgsRasterCalcNode::opGT), 72},
    {sipName_opLE, static_cast<int>( ::QgsRasterCalcNode::opLE), 72},
    {sipName_opLOG, static_cast<int>( ::QgsRasterCalcNode::opLOG), 72},
    {sipName_opLOG10, static_cast<int>( ::QgsRasterCalcNode::opLOG10), 72},
    {sipName_opLT, static_cast<int>( ::QgsRasterCalcNode::opLT), 72},
    {sipName_opMINUS, static_cast<int>( ::QgsRasterCalcNode::opMINUS), 72},
    {sipName_opMUL, static_cast<int>( ::QgsRasterCalcNode::opMUL), 72},
    {sipName_opNE, static_cast<int>( ::QgsRasterCalcNode::opNE), 72},
    {sipName_opNONE, static_cast<int>( ::QgsRasterCalcNode::opNONE), 72},
    {sipName_opOR, static_cast<int>( ::QgsRasterCalcNode::opOR), 72},
    {sipName_opPLUS, static_cast<int>( ::QgsRasterCalcNode::opPLUS), 72},
    {sipName_opPOW, static_cast<int>( ::QgsRasterCalcNode::opPOW), 72},
    {sipName_opSIGN, static_cast<int>( ::QgsRasterCalcNode::opSIGN), 72},
    {sipName_opSIN, static_cast<int>( ::QgsRasterCalcNode::opSIN), 72},
    {sipName_opSQRT, static_cast<int>( ::QgsRasterCalcNode::opSQRT), 72},
    {sipName_opTAN, static_cast<int>( ::QgsRasterCalcNode::opTAN), 72},
    {sipName_tMatrix, static_cast<int>( ::QgsRasterCalcNode::tMatrix), 73},
    {sipName_tNumber, static_cast<int>( ::QgsRasterCalcNode::tNumber), 73},
    {sipName_tOperator, static_cast<int>( ::QgsRasterCalcNode::tOperator), 73},
    {sipName_tRasterRef, static_cast<int>( ::QgsRasterCalcNode::tRasterRef), 73},
};

PyDoc_STRVAR(doc_QgsRasterCalcNode, "QgsRasterCalcNode()\n"
"Constructor for QgsRasterCalcNode.\n"
"\n"
"QgsRasterCalcNode(number: float)\n"
"\n"
"QgsRasterCalcNode(matrix: QgsRasterMatrix)\n"
"\n"
"QgsRasterCalcNode(op: QgsRasterCalcNode.Operator, left: QgsRasterCalcNode, right: QgsRasterCalcNode)\n"
"\n"
"QgsRasterCalcNode(rasterName: str)");


static pyqt5ClassPluginDef plugin_QgsRasterCalcNode = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsRasterCalcNode = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsRasterCalcNode,
        {0},
        &plugin_QgsRasterCalcNode
    },
    {
        sipNameNr_QgsRasterCalcNode,
        {0, 0, 1},
        6, methods_QgsRasterCalcNode,
        28, enummembers_QgsRasterCalcNode,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsRasterCalcNode,
    -1,
    -1,
    0,
    0,
    init_type_QgsRasterCalcNode,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsRasterCalcNode,
    0,
    0,
    0,
    release_QgsRasterCalcNode,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 16 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrastermatrix.sip"
#include "qgsrastermatrix.h"
#line 6432 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"



PyDoc_STRVAR(doc_QgsRasterMatrix_isNumber, "isNumber(self) -> bool\n"
"Returns ``True`` if matrix is 1x1 (=scalar number)");

extern "C" {static PyObject *meth_QgsRasterMatrix_isNumber(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_isNumber(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->isNumber();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_isNumber, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_number, "number(self) -> float");

extern "C" {static PyObject *meth_QgsRasterMatrix_number(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_number(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->number();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_number, doc_QgsRasterMatrix_number);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_setData, "setData(self, cols: int, rows: int, nodataValue: float) -> float");

extern "C" {static PyObject *meth_QgsRasterMatrix_setData(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_setData(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        int a1;
        double a2;
        double a3;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cols,
            sipName_rows,
            sipName_nodataValue,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Biid", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, &a0, &a1, &a3))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setData(a0,a1,&a2,a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_setData, doc_QgsRasterMatrix_setData);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_nColumns, "nColumns(self) -> int");

extern "C" {static PyObject *meth_QgsRasterMatrix_nColumns(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_nColumns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->nColumns();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_nColumns, doc_QgsRasterMatrix_nColumns);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_nRows, "nRows(self) -> int");

extern "C" {static PyObject *meth_QgsRasterMatrix_nRows(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_nRows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->nRows();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_nRows, doc_QgsRasterMatrix_nRows);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_nodataValue, "nodataValue(self) -> float");

extern "C" {static PyObject *meth_QgsRasterMatrix_nodataValue(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_nodataValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->nodataValue();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_nodataValue, doc_QgsRasterMatrix_nodataValue);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_setNodataValue, "setNodataValue(self, d: float)");

extern "C" {static PyObject *meth_QgsRasterMatrix_setNodataValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_setNodataValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_d,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setNodataValue(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_setNodataValue, doc_QgsRasterMatrix_setNodataValue);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_add, "add(self, other: QgsRasterMatrix) -> bool\n"
"Adds another matrix to this one");

extern "C" {static PyObject *meth_QgsRasterMatrix_add(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_add(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->add(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_add, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_subtract, "subtract(self, other: QgsRasterMatrix) -> bool\n"
"Subtracts another matrix from this one");

extern "C" {static PyObject *meth_QgsRasterMatrix_subtract(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_subtract(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->subtract(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_subtract, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_multiply, "multiply(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_multiply(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_multiply(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->multiply(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_multiply, doc_QgsRasterMatrix_multiply);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_divide, "divide(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_divide(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_divide(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->divide(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_divide, doc_QgsRasterMatrix_divide);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_power, "power(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_power(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_power(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->power(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_power, doc_QgsRasterMatrix_power);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_equal, "equal(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_equal(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_equal(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->equal(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_equal, doc_QgsRasterMatrix_equal);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_notEqual, "notEqual(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_notEqual(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_notEqual(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->notEqual(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_notEqual, doc_QgsRasterMatrix_notEqual);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_greaterThan, "greaterThan(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_greaterThan(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_greaterThan(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->greaterThan(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_greaterThan, doc_QgsRasterMatrix_greaterThan);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_lesserThan, "lesserThan(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_lesserThan(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_lesserThan(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->lesserThan(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_lesserThan, doc_QgsRasterMatrix_lesserThan);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_greaterEqual, "greaterEqual(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_greaterEqual(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_greaterEqual(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->greaterEqual(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_greaterEqual, doc_QgsRasterMatrix_greaterEqual);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_lesserEqual, "lesserEqual(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_lesserEqual(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_lesserEqual(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->lesserEqual(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_lesserEqual, doc_QgsRasterMatrix_lesserEqual);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_logicalAnd, "logicalAnd(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_logicalAnd(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_logicalAnd(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->logicalAnd(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_logicalAnd, doc_QgsRasterMatrix_logicalAnd);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_logicalOr, "logicalOr(self, other: QgsRasterMatrix) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_logicalOr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_logicalOr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterMatrix* a0;
         ::QgsRasterMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRasterMatrix, &sipCpp, sipType_QgsRasterMatrix, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->logicalOr(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_logicalOr, doc_QgsRasterMatrix_logicalOr);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_squareRoot, "squareRoot(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_squareRoot(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_squareRoot(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->squareRoot();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_squareRoot, doc_QgsRasterMatrix_squareRoot);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_sinus, "sinus(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_sinus(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_sinus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sinus();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_sinus, doc_QgsRasterMatrix_sinus);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_asinus, "asinus(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_asinus(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_asinus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->asinus();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_asinus, doc_QgsRasterMatrix_asinus);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_cosinus, "cosinus(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_cosinus(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_cosinus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->cosinus();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_cosinus, doc_QgsRasterMatrix_cosinus);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_acosinus, "acosinus(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_acosinus(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_acosinus(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->acosinus();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_acosinus, doc_QgsRasterMatrix_acosinus);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_tangens, "tangens(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_tangens(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_tangens(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->tangens();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_tangens, doc_QgsRasterMatrix_tangens);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_atangens, "atangens(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_atangens(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_atangens(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->atangens();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_atangens, doc_QgsRasterMatrix_atangens);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_changeSign, "changeSign(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_changeSign(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_changeSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->changeSign();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_changeSign, doc_QgsRasterMatrix_changeSign);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_log, "log(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_log(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_log(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->log();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_log, doc_QgsRasterMatrix_log);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterMatrix_log10, "log10(self) -> bool");

extern "C" {static PyObject *meth_QgsRasterMatrix_log10(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterMatrix_log10(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRasterMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterMatrix, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->log10();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterMatrix, sipName_log10, doc_QgsRasterMatrix_log10);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsRasterMatrix(void *, int);}
static void release_QgsRasterMatrix(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsRasterMatrix *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsRasterMatrix(void *, SIP_SSIZE_T, void *);}
static void assign_QgsRasterMatrix(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsRasterMatrix *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsRasterMatrix *>(sipSrc);
}


extern "C" {static void *array_QgsRasterMatrix(SIP_SSIZE_T);}
static void *array_QgsRasterMatrix(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsRasterMatrix[sipNrElem];
}


extern "C" {static void *copy_QgsRasterMatrix(const void *, SIP_SSIZE_T);}
static void *copy_QgsRasterMatrix(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsRasterMatrix(reinterpret_cast<const  ::QgsRasterMatrix *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsRasterMatrix(sipSimpleWrapper *);}
static void dealloc_QgsRasterMatrix(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsRasterMatrix(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsRasterMatrix(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsRasterMatrix(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsRasterMatrix *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterMatrix();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsRasterMatrix* a0;

        static const char *sipKwdList[] = {
            sipName_m,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_QgsRasterMatrix, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterMatrix(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsRasterMatrix[] = {
    {SIP_MLNAME_CAST(sipName_acosinus), meth_QgsRasterMatrix_acosinus, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_acosinus)},
    {SIP_MLNAME_CAST(sipName_add), (PyCFunction)meth_QgsRasterMatrix_add, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_add)},
    {SIP_MLNAME_CAST(sipName_asinus), meth_QgsRasterMatrix_asinus, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_asinus)},
    {SIP_MLNAME_CAST(sipName_atangens), meth_QgsRasterMatrix_atangens, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_atangens)},
    {SIP_MLNAME_CAST(sipName_changeSign), meth_QgsRasterMatrix_changeSign, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_changeSign)},
    {SIP_MLNAME_CAST(sipName_cosinus), meth_QgsRasterMatrix_cosinus, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_cosinus)},
    {SIP_MLNAME_CAST(sipName_divide), (PyCFunction)meth_QgsRasterMatrix_divide, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_divide)},
    {SIP_MLNAME_CAST(sipName_equal), (PyCFunction)meth_QgsRasterMatrix_equal, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_equal)},
    {SIP_MLNAME_CAST(sipName_greaterEqual), (PyCFunction)meth_QgsRasterMatrix_greaterEqual, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_greaterEqual)},
    {SIP_MLNAME_CAST(sipName_greaterThan), (PyCFunction)meth_QgsRasterMatrix_greaterThan, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_greaterThan)},
    {SIP_MLNAME_CAST(sipName_isNumber), meth_QgsRasterMatrix_isNumber, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_isNumber)},
    {SIP_MLNAME_CAST(sipName_lesserEqual), (PyCFunction)meth_QgsRasterMatrix_lesserEqual, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_lesserEqual)},
    {SIP_MLNAME_CAST(sipName_lesserThan), (PyCFunction)meth_QgsRasterMatrix_lesserThan, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_lesserThan)},
    {SIP_MLNAME_CAST(sipName_log), meth_QgsRasterMatrix_log, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_log)},
    {SIP_MLNAME_CAST(sipName_log10), meth_QgsRasterMatrix_log10, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_log10)},
    {SIP_MLNAME_CAST(sipName_logicalAnd), (PyCFunction)meth_QgsRasterMatrix_logicalAnd, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_logicalAnd)},
    {SIP_MLNAME_CAST(sipName_logicalOr), (PyCFunction)meth_QgsRasterMatrix_logicalOr, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_logicalOr)},
    {SIP_MLNAME_CAST(sipName_multiply), (PyCFunction)meth_QgsRasterMatrix_multiply, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_multiply)},
    {SIP_MLNAME_CAST(sipName_nColumns), meth_QgsRasterMatrix_nColumns, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_nColumns)},
    {SIP_MLNAME_CAST(sipName_nRows), meth_QgsRasterMatrix_nRows, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_nRows)},
    {SIP_MLNAME_CAST(sipName_nodataValue), meth_QgsRasterMatrix_nodataValue, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_nodataValue)},
    {SIP_MLNAME_CAST(sipName_notEqual), (PyCFunction)meth_QgsRasterMatrix_notEqual, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_notEqual)},
    {SIP_MLNAME_CAST(sipName_number), meth_QgsRasterMatrix_number, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_number)},
    {SIP_MLNAME_CAST(sipName_power), (PyCFunction)meth_QgsRasterMatrix_power, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_power)},
    {SIP_MLNAME_CAST(sipName_setData), (PyCFunction)meth_QgsRasterMatrix_setData, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_setData)},
    {SIP_MLNAME_CAST(sipName_setNodataValue), (PyCFunction)meth_QgsRasterMatrix_setNodataValue, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_setNodataValue)},
    {SIP_MLNAME_CAST(sipName_sinus), meth_QgsRasterMatrix_sinus, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_sinus)},
    {SIP_MLNAME_CAST(sipName_squareRoot), meth_QgsRasterMatrix_squareRoot, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_squareRoot)},
    {SIP_MLNAME_CAST(sipName_subtract), (PyCFunction)meth_QgsRasterMatrix_subtract, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_subtract)},
    {SIP_MLNAME_CAST(sipName_tangens), meth_QgsRasterMatrix_tangens, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterMatrix_tangens)}
};

static sipEnumMemberDef enummembers_QgsRasterMatrix[] = {
    {sipName_opACOS, static_cast<int>( ::QgsRasterMatrix::opACOS), 78},
    {sipName_opAND, static_cast<int>( ::QgsRasterMatrix::opAND), 79},
    {sipName_opASIN, static_cast<int>( ::QgsRasterMatrix::opASIN), 78},
    {sipName_opATAN, static_cast<int>( ::QgsRasterMatrix::opATAN), 78},
    {sipName_opCOS, static_cast<int>( ::QgsRasterMatrix::opCOS), 78},
    {sipName_opDIV, static_cast<int>( ::QgsRasterMatrix::opDIV), 79},
    {sipName_opEQ, static_cast<int>( ::QgsRasterMatrix::opEQ), 79},
    {sipName_opGE, static_cast<int>( ::QgsRasterMatrix::opGE), 79},
    {sipName_opGT, static_cast<int>( ::QgsRasterMatrix::opGT), 79},
    {sipName_opLE, static_cast<int>( ::QgsRasterMatrix::opLE), 79},
    {sipName_opLOG, static_cast<int>( ::QgsRasterMatrix::opLOG), 78},
    {sipName_opLOG10, static_cast<int>( ::QgsRasterMatrix::opLOG10), 78},
    {sipName_opLT, static_cast<int>( ::QgsRasterMatrix::opLT), 79},
    {sipName_opMINUS, static_cast<int>( ::QgsRasterMatrix::opMINUS), 79},
    {sipName_opMUL, static_cast<int>( ::QgsRasterMatrix::opMUL), 79},
    {sipName_opNE, static_cast<int>( ::QgsRasterMatrix::opNE), 79},
    {sipName_opOR, static_cast<int>( ::QgsRasterMatrix::opOR), 79},
    {sipName_opPLUS, static_cast<int>( ::QgsRasterMatrix::opPLUS), 79},
    {sipName_opPOW, static_cast<int>( ::QgsRasterMatrix::opPOW), 79},
    {sipName_opSIGN, static_cast<int>( ::QgsRasterMatrix::opSIGN), 78},
    {sipName_opSIN, static_cast<int>( ::QgsRasterMatrix::opSIN), 78},
    {sipName_opSQRT, static_cast<int>( ::QgsRasterMatrix::opSQRT), 78},
    {sipName_opTAN, static_cast<int>( ::QgsRasterMatrix::opTAN), 78},
};

PyDoc_STRVAR(doc_QgsRasterMatrix, "QgsRasterMatrix()\n"
"Takes ownership of data array\n"
"\n"
"QgsRasterMatrix(m: QgsRasterMatrix)");


static pyqt5ClassPluginDef plugin_QgsRasterMatrix = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsRasterMatrix = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsRasterMatrix,
        {0},
        &plugin_QgsRasterMatrix
    },
    {
        sipNameNr_QgsRasterMatrix,
        {0, 0, 1},
        30, methods_QgsRasterMatrix,
        23, enummembers_QgsRasterMatrix,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsRasterMatrix,
    -1,
    -1,
    0,
    0,
    init_type_QgsRasterMatrix,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsRasterMatrix,
    assign_QgsRasterMatrix,
    array_QgsRasterMatrix,
    copy_QgsRasterMatrix,
    release_QgsRasterMatrix,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsslopefilter.sip"
#include "qgsslopefilter.h"
#line 7942 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 7946 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 7949 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart2.cpp"


class sipQgsSlopeFilter : public  ::QgsSlopeFilter
{
public:
    sipQgsSlopeFilter(const  ::QString&,const  ::QString&,const  ::QString&);
    sipQgsSlopeFilter(const  ::QgsSlopeFilter&);
    virtual ~sipQgsSlopeFilter();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    float sipProtect_calcFirstDerX(float*,float*,float*,float*,float*,float*,float*,float*,float*);
    float sipProtect_calcFirstDerY(float*,float*,float*,float*,float*,float*,float*,float*,float*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    float processNineCellWindow(float*,float*,float*,float*,float*,float*,float*,float*,float*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsSlopeFilter(const sipQgsSlopeFilter &);
    sipQgsSlopeFilter &operator = (const sipQgsSlopeFilter &);

    char sipPyMethods[1];
};

sipQgsSlopeFilter::sipQgsSlopeFilter(const  ::QString& a0,const  ::QString& a1,const  ::QString& a2):  ::QgsSlopeFilter(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsSlopeFilter::sipQgsSlopeFilter(const  ::QgsSlopeFilter& a0):  ::QgsSlopeFilter(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsSlopeFilter::~sipQgsSlopeFilter()
{
    sipInstanceDestroyed(sipPySelf);
}

float sipQgsSlopeFilter::processNineCellWindow(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_processNineCellWindow);

    if (!sipMeth)
        return  ::QgsSlopeFilter::processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8);

    extern float sipVH__analysis_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, float*,float*,float*,float*,float*,float*,float*,float*,float*);

    return sipVH__analysis_1(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

float sipQgsSlopeFilter::sipProtect_calcFirstDerX(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerX(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}

float sipQgsSlopeFilter::sipProtect_calcFirstDerY(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerY(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}


PyDoc_STRVAR(doc_QgsSlopeFilter_calcFirstDerX, "calcFirstDerX(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in x-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsSlopeFilter_calcFirstDerX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsSlopeFilter_calcFirstDerX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsSlopeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsSlopeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerX(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSlopeFilter, sipName_calcFirstDerX, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsSlopeFilter_calcFirstDerY, "calcFirstDerY(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in y-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsSlopeFilter_calcFirstDerY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsSlopeFilter_calcFirstDerY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsSlopeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsSlopeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerY(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSlopeFilter, sipName_calcFirstDerY, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsSlopeFilter_processNineCellWindow, "processNineCellWindow(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates output value from nine input values. The input values and the output value can be equal to the\n"
"nodata value if not present or outside of the border. Must be implemented by subclasses*");

extern "C" {static PyObject *meth_QgsSlopeFilter_processNineCellWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsSlopeFilter_processNineCellWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
         ::QgsSlopeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsSlopeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsSlopeFilter::processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8) : sipCpp->processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSlopeFilter, sipName_processNineCellWindow, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsSlopeFilter(void *, const sipTypeDef *);}
static void *cast_QgsSlopeFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsSlopeFilter *sipCpp = reinterpret_cast< ::QgsSlopeFilter *>(sipCppV);

    if (targetType == sipType_QgsDerivativeFilter)
        return static_cast< ::QgsDerivativeFilter *>(sipCpp);

    if (targetType == sipType_QgsNineCellFilter)
        return static_cast< ::QgsNineCellFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsSlopeFilter(void *, int);}
static void release_QgsSlopeFilter(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsSlopeFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsSlopeFilter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsSlopeFilter(sipSimpleWrapper *);}
static void dealloc_QgsSlopeFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsSlopeFilter *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsSlopeFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsSlopeFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsSlopeFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsSlopeFilter *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsSlopeFilter(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsSlopeFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsSlopeFilter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsSlopeFilter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsSlopeFilter[] = {{17, 255, 1}};


static PyMethodDef methods_QgsSlopeFilter[] = {
    {SIP_MLNAME_CAST(sipName_calcFirstDerX), (PyCFunction)meth_QgsSlopeFilter_calcFirstDerX, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_calcFirstDerY), (PyCFunction)meth_QgsSlopeFilter_calcFirstDerY, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_processNineCellWindow), (PyCFunction)meth_QgsSlopeFilter_processNineCellWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsSlopeFilter_processNineCellWindow)}
};

PyDoc_STRVAR(doc_QgsSlopeFilter, "\n"
"\n"
"\n"
"Calculates slope values in a window of 3x3 cells based on first order derivatives in x- and y- directions*");


static pyqt5ClassPluginDef plugin_QgsSlopeFilter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsSlopeFilter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsSlopeFilter,
        {0},
        &plugin_QgsSlopeFilter
    },
    {
        sipNameNr_QgsSlopeFilter,
        {0, 0, 1},
        3, methods_QgsSlopeFilter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsSlopeFilter,
    -1,
    -1,
    supers_QgsSlopeFilter,
    0,
    init_type_QgsSlopeFilter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsSlopeFilter,
    0,
    0,
    0,
    release_QgsSlopeFilter,
    cast_QgsSlopeFilter,
    0,
    0,
    0,
    0,
    0,
    0
};

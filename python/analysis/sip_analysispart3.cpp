/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPI_analysis.h"

#line 20 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsruggednessfilter.sip"
#include "qgsruggednessfilter.h"
#line 12 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 16 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


class sipQgsRuggednessFilter : public  ::QgsRuggednessFilter
{
public:
    sipQgsRuggednessFilter(const  ::QString&,const  ::QString&,const  ::QString&);
    sipQgsRuggednessFilter(const  ::QgsRuggednessFilter&);
    virtual ~sipQgsRuggednessFilter();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    float sipProtectVirt_processNineCellWindow(bool,float*,float*,float*,float*,float*,float*,float*,float*,float*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    float processNineCellWindow(float*,float*,float*,float*,float*,float*,float*,float*,float*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsRuggednessFilter(const sipQgsRuggednessFilter &);
    sipQgsRuggednessFilter &operator = (const sipQgsRuggednessFilter &);

    char sipPyMethods[1];
};

sipQgsRuggednessFilter::sipQgsRuggednessFilter(const  ::QString& a0,const  ::QString& a1,const  ::QString& a2):  ::QgsRuggednessFilter(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsRuggednessFilter::sipQgsRuggednessFilter(const  ::QgsRuggednessFilter& a0):  ::QgsRuggednessFilter(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsRuggednessFilter::~sipQgsRuggednessFilter()
{
    sipInstanceDestroyed(sipPySelf);
}

float sipQgsRuggednessFilter::processNineCellWindow(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_processNineCellWindow);

    if (!sipMeth)
        return  ::QgsRuggednessFilter::processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8);

    extern float sipVH__analysis_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, float*,float*,float*,float*,float*,float*,float*,float*,float*);

    return sipVH__analysis_1(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

float sipQgsRuggednessFilter::sipProtectVirt_processNineCellWindow(bool sipSelfWasArg,float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return (sipSelfWasArg ?  ::QgsRuggednessFilter::processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8) : processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8));
}


PyDoc_STRVAR(doc_QgsRuggednessFilter_processNineCellWindow, "processNineCellWindow(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates output value from nine input values. The input values and the output value can be equal to the\n"
"nodata value if not present or outside of the border. Must be implemented by subclasses*");

extern "C" {static PyObject *meth_QgsRuggednessFilter_processNineCellWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRuggednessFilter_processNineCellWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsRuggednessFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsRuggednessFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtectVirt_processNineCellWindow(sipSelfWasArg,&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRuggednessFilter, sipName_processNineCellWindow, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsRuggednessFilter(void *, const sipTypeDef *);}
static void *cast_QgsRuggednessFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsRuggednessFilter *sipCpp = reinterpret_cast< ::QgsRuggednessFilter *>(sipCppV);

    if (targetType == sipType_QgsNineCellFilter)
        return static_cast< ::QgsNineCellFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsRuggednessFilter(void *, int);}
static void release_QgsRuggednessFilter(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsRuggednessFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsRuggednessFilter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsRuggednessFilter(sipSimpleWrapper *);}
static void dealloc_QgsRuggednessFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsRuggednessFilter *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsRuggednessFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsRuggednessFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsRuggednessFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsRuggednessFilter *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsRuggednessFilter(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsRuggednessFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsRuggednessFilter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsRuggednessFilter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsRuggednessFilter[] = {{70, 255, 1}};


static PyMethodDef methods_QgsRuggednessFilter[] = {
    {SIP_MLNAME_CAST(sipName_processNineCellWindow), (PyCFunction)meth_QgsRuggednessFilter_processNineCellWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRuggednessFilter_processNineCellWindow)}
};

PyDoc_STRVAR(doc_QgsRuggednessFilter, "\n"
"\n"
"\n"
"Calculates the ruggedness index based on a 3x3 moving window.\n"
"Algorithm from Riley et al. 1999: A terrain ruggedness index that quantifies topographic heterogeneity*");


static pyqt5ClassPluginDef plugin_QgsRuggednessFilter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsRuggednessFilter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsRuggednessFilter,
        {0},
        &plugin_QgsRuggednessFilter
    },
    {
        sipNameNr_QgsRuggednessFilter,
        {0, 0, 1},
        1, methods_QgsRuggednessFilter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsRuggednessFilter,
    -1,
    -1,
    supers_QgsRuggednessFilter,
    0,
    init_type_QgsRuggednessFilter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsRuggednessFilter,
    0,
    0,
    0,
    release_QgsRuggednessFilter,
    cast_QgsRuggednessFilter,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 20 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrelief.sip"
#include "qgsrelief.h"
#line 331 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 26 "/usr/share/sip/PyQt5/QtGui/qcolor.sip"
#include <qcolor.h>
#line 335 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


/* Call the instance's destructor. */
extern "C" {static void release_QgsRelief_ReliefColor(void *, int);}
static void release_QgsRelief_ReliefColor(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsRelief::ReliefColor *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsRelief_ReliefColor(sipSimpleWrapper *);}
static void dealloc_QgsRelief_ReliefColor(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsRelief_ReliefColor(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsRelief_ReliefColor(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsRelief_ReliefColor(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsRelief::ReliefColor *sipCpp = 0;

    {
        const  ::QColor* a0;
        int a0State = 0;
        double a1;
        double a2;

        static const char *sipKwdList[] = {
            sipName_c,
            sipName_min,
            sipName_max,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1dd", sipType_QColor, &a0, &a0State, &a1, &a2))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRelief::ReliefColor(*a0,a1,a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QColor *>(a0),sipType_QColor,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QColor *>(a0),sipType_QColor,a0State);

            return sipCpp;
        }
    }

    {
        const  ::QgsRelief::ReliefColor* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsRelief_ReliefColor, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRelief::ReliefColor(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_QgsRelief_ReliefColor_color(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsRelief_ReliefColor_color(void *sipSelf, PyObject *, PyObject *)
{
     ::QColor*sipVal;
     ::QgsRelief::ReliefColor *sipCpp = reinterpret_cast< ::QgsRelief::ReliefColor *>(sipSelf);

    sipVal = &sipCpp->color;

    return sipConvertFromType(sipVal, sipType_QColor, NULL);
}


extern "C" {static int varset_QgsRelief_ReliefColor_color(void *, PyObject *, PyObject *);}
static int varset_QgsRelief_ReliefColor_color(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QColor*sipVal;
     ::QgsRelief::ReliefColor *sipCpp = reinterpret_cast< ::QgsRelief::ReliefColor *>(sipSelf);

    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QColor *>(sipForceConvertToType(sipPy,sipType_QColor,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->color = *sipVal;

    sipReleaseType(sipVal, sipType_QColor, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_QgsRelief_ReliefColor_maxElevation(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsRelief_ReliefColor_maxElevation(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsRelief::ReliefColor *sipCpp = reinterpret_cast< ::QgsRelief::ReliefColor *>(sipSelf);

    sipVal = sipCpp->maxElevation;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsRelief_ReliefColor_maxElevation(void *, PyObject *, PyObject *);}
static int varset_QgsRelief_ReliefColor_maxElevation(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsRelief::ReliefColor *sipCpp = reinterpret_cast< ::QgsRelief::ReliefColor *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->maxElevation = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsRelief_ReliefColor_minElevation(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsRelief_ReliefColor_minElevation(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsRelief::ReliefColor *sipCpp = reinterpret_cast< ::QgsRelief::ReliefColor *>(sipSelf);

    sipVal = sipCpp->minElevation;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsRelief_ReliefColor_minElevation(void *, PyObject *, PyObject *);}
static int varset_QgsRelief_ReliefColor_minElevation(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsRelief::ReliefColor *sipCpp = reinterpret_cast< ::QgsRelief::ReliefColor *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->minElevation = sipVal;

    return 0;
}

sipVariableDef variables_QgsRelief_ReliefColor[] = {
    {InstanceVariable, sipName_color, (PyMethodDef *)varget_QgsRelief_ReliefColor_color, (PyMethodDef *)varset_QgsRelief_ReliefColor_color, NULL, NULL},
    {InstanceVariable, sipName_maxElevation, (PyMethodDef *)varget_QgsRelief_ReliefColor_maxElevation, (PyMethodDef *)varset_QgsRelief_ReliefColor_maxElevation, NULL, NULL},
    {InstanceVariable, sipName_minElevation, (PyMethodDef *)varget_QgsRelief_ReliefColor_minElevation, (PyMethodDef *)varset_QgsRelief_ReliefColor_minElevation, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsRelief_ReliefColor, "\1QgsRelief.ReliefColor(c: Union[QColor, Qt.GlobalColor], min: float, max: float)\n"
"QgsRelief.ReliefColor(QgsRelief.ReliefColor)");


static pyqt5ClassPluginDef plugin_QgsRelief_ReliefColor = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsRelief_ReliefColor = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsRelief__ReliefColor,
        {0},
        &plugin_QgsRelief_ReliefColor
    },
    {
        sipNameNr_ReliefColor,
        {80, 255, 0},
        0, 0,
        0, 0,
        3, variables_QgsRelief_ReliefColor,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsRelief_ReliefColor,
    -1,
    -1,
    0,
    0,
    init_type_QgsRelief_ReliefColor,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsRelief_ReliefColor,
    0,
    0,
    0,
    release_QgsRelief_ReliefColor,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 20 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrelief.sip"
#include "qgsrelief.h"
#line 588 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 592 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 595 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 20 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrelief.sip"
#include "qgsrelief.h"
#line 598 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 601 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


PyDoc_STRVAR(doc_QgsRelief_processRaster, "processRaster(self, feedback: QgsFeedback = None) -> int\n"
"Starts the calculation, reads from mInputFile and stores the result in mOutputFile\n"
"\n"
":param feedback: feedback object that receives update and that is checked for cancellation.\n"
"\n"
":return: 0 in case of success*");

extern "C" {static PyObject *meth_QgsRelief_processRaster(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_processRaster(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
         ::QgsRelief *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsRelief, &sipCpp, sipType_QgsFeedback, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->processRaster(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_processRaster, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_zFactor, "zFactor(self) -> float");

extern "C" {static PyObject *meth_QgsRelief_zFactor(PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_zFactor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRelief *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRelief, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->zFactor();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_zFactor, doc_QgsRelief_zFactor);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_setZFactor, "setZFactor(self, factor: float)");

extern "C" {static PyObject *meth_QgsRelief_setZFactor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_setZFactor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsRelief *sipCpp;

        static const char *sipKwdList[] = {
            sipName_factor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsRelief, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setZFactor(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_setZFactor, doc_QgsRelief_setZFactor);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_clearReliefColors, "clearReliefColors(self)");

extern "C" {static PyObject *meth_QgsRelief_clearReliefColors(PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_clearReliefColors(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRelief *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRelief, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->clearReliefColors();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_clearReliefColors, doc_QgsRelief_clearReliefColors);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_addReliefColorClass, "addReliefColorClass(self, color: QgsRelief.ReliefColor)");

extern "C" {static PyObject *meth_QgsRelief_addReliefColorClass(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_addReliefColorClass(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRelief::ReliefColor* a0;
         ::QgsRelief *sipCpp;

        static const char *sipKwdList[] = {
            sipName_color,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsRelief, &sipCpp, sipType_QgsRelief_ReliefColor, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->addReliefColorClass(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_addReliefColorClass, doc_QgsRelief_addReliefColorClass);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_reliefColors, "reliefColors(self) -> object");

extern "C" {static PyObject *meth_QgsRelief_reliefColors(PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_reliefColors(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRelief *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRelief, &sipCpp))
        {
            QList< ::QgsRelief::ReliefColor>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new QList< ::QgsRelief::ReliefColor>(sipCpp->reliefColors());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0100QgsRelief_ReliefColor,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_reliefColors, doc_QgsRelief_reliefColors);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_setReliefColors, "setReliefColors(self, c: Iterable[QgsRelief.ReliefColor])");

extern "C" {static PyObject *meth_QgsRelief_setReliefColors(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_setReliefColors(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const QList< ::QgsRelief::ReliefColor>* a0;
        int a0State = 0;
         ::QgsRelief *sipCpp;

        static const char *sipKwdList[] = {
            sipName_c,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_QgsRelief, &sipCpp, sipType_QList_0100QgsRelief_ReliefColor,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setReliefColors(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QList< ::QgsRelief::ReliefColor> *>(a0),sipType_QList_0100QgsRelief_ReliefColor,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QList< ::QgsRelief::ReliefColor> *>(a0),sipType_QList_0100QgsRelief_ReliefColor,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_setReliefColors, doc_QgsRelief_setReliefColors);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_calculateOptimizedReliefClasses, "calculateOptimizedReliefClasses(self) -> List[QgsRelief.ReliefColor]\n"
"Calculates class breaks according with the method of Buenzli (2011) using an iterative algorithm for segmented regression\n"
"\n"
":return: true in case of success*");

extern "C" {static PyObject *meth_QgsRelief_calculateOptimizedReliefClasses(PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_calculateOptimizedReliefClasses(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsRelief *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRelief, &sipCpp))
        {
            QList< ::QgsRelief::ReliefColor>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new QList< ::QgsRelief::ReliefColor>(sipCpp->calculateOptimizedReliefClasses());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0100QgsRelief_ReliefColor,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_calculateOptimizedReliefClasses, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRelief_exportFrequencyDistributionToCsv, "exportFrequencyDistributionToCsv(self, file: str) -> bool\n"
"Write frequency of elevation values to file for manual inspection");

extern "C" {static PyObject *meth_QgsRelief_exportFrequencyDistributionToCsv(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRelief_exportFrequencyDistributionToCsv(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QgsRelief *sipCpp;

        static const char *sipKwdList[] = {
            sipName_file,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_QgsRelief, &sipCpp, sipType_QString,&a0, &a0State))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->exportFrequencyDistributionToCsv(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRelief, sipName_exportFrequencyDistributionToCsv, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsRelief(void *, int);}
static void release_QgsRelief(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsRelief *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsRelief(sipSimpleWrapper *);}
static void dealloc_QgsRelief(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsRelief(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsRelief(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsRelief(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsRelief *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRelief(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsRelief[] = {
    {SIP_MLNAME_CAST(sipName_addReliefColorClass), (PyCFunction)meth_QgsRelief_addReliefColorClass, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRelief_addReliefColorClass)},
    {SIP_MLNAME_CAST(sipName_calculateOptimizedReliefClasses), meth_QgsRelief_calculateOptimizedReliefClasses, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRelief_calculateOptimizedReliefClasses)},
    {SIP_MLNAME_CAST(sipName_clearReliefColors), meth_QgsRelief_clearReliefColors, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRelief_clearReliefColors)},
    {SIP_MLNAME_CAST(sipName_exportFrequencyDistributionToCsv), (PyCFunction)meth_QgsRelief_exportFrequencyDistributionToCsv, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRelief_exportFrequencyDistributionToCsv)},
    {SIP_MLNAME_CAST(sipName_processRaster), (PyCFunction)meth_QgsRelief_processRaster, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRelief_processRaster)},
    {SIP_MLNAME_CAST(sipName_reliefColors), meth_QgsRelief_reliefColors, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRelief_reliefColors)},
    {SIP_MLNAME_CAST(sipName_setReliefColors), (PyCFunction)meth_QgsRelief_setReliefColors, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRelief_setReliefColors)},
    {SIP_MLNAME_CAST(sipName_setZFactor), (PyCFunction)meth_QgsRelief_setZFactor, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRelief_setZFactor)},
    {SIP_MLNAME_CAST(sipName_zFactor), meth_QgsRelief_zFactor, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRelief_zFactor)}
};

PyDoc_STRVAR(doc_QgsRelief, "\n"
"\n"
"Produces colored relief rasters from DEM*");


static pyqt5ClassPluginDef plugin_QgsRelief = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsRelief = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsRelief,
        {0},
        &plugin_QgsRelief
    },
    {
        sipNameNr_QgsRelief,
        {0, 0, 1},
        9, methods_QgsRelief,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsRelief,
    -1,
    -1,
    0,
    0,
    init_type_QgsRelief,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsRelief,
    0,
    0,
    0,
    release_QgsRelief,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 53 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrastercalculator.sip"
#include "qgsrastercalculator.h"
#line 1147 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 1151 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 26 "core/auto_generated/geometry/qgsrectangle.sip"
#include "qgsrectangle.h"
#line 1154 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 1157 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrastercalculator.sip"
#include "qgsrastercalculator.h"
#line 1160 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 49 "core/auto_generated/qgscoordinatetransformcontext.sip"
#include "qgscoordinatetransformcontext.h"
#line 1163 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 157 "core/auto_generated/qgscoordinatereferencesystem.sip"
#include "qgscoordinatereferencesystem.h"
#line 1166 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 1169 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


PyDoc_STRVAR(doc_QgsRasterCalculator_processCalculation, "processCalculation(self, feedback: QgsFeedback = None) -> QgsRasterCalculator.Result\n"
"Starts the calculation and writes a new raster.\n"
"\n"
"The optional ``feedback`` argument can be used for progress reporting and cancellation support.\n"
"\n"
":return: QgsRasterCalculator.Success in case of success. If an error is encountered then\n"
"         a description of the error can be obtained by calling lastError().");

extern "C" {static PyObject *meth_QgsRasterCalculator_processCalculation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalculator_processCalculation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
         ::QgsRasterCalculator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsRasterCalculator, &sipCpp, sipType_QgsFeedback, &a0))
        {
             ::QgsRasterCalculator::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->processCalculation(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsRasterCalculator_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalculator, sipName_processCalculation, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsRasterCalculator_lastError, "lastError(self) -> str\n"
"Returns a description of the last error encountered.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsRasterCalculator_lastError(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalculator_lastError(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsRasterCalculator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsRasterCalculator, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->lastError());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalculator, sipName_lastError, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsRasterCalculator(void *, int);}
static void release_QgsRasterCalculator(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsRasterCalculator *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsRasterCalculator(sipSimpleWrapper *);}
static void dealloc_QgsRasterCalculator(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsRasterCalculator(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsRasterCalculator(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsRasterCalculator(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsRasterCalculator *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;
        const  ::QgsRectangle* a3;
        int a4;
        int a5;
        const QVector< ::QgsRasterCalculatorEntry>* a6;
        int a6State = 0;
        const  ::QgsCoordinateTransformContext* a7;

        static const char *sipKwdList[] = {
            sipName_formulaString,
            sipName_outputFile,
            sipName_outputFormat,
            sipName_outputExtent,
            sipName_nOutputColumns,
            sipName_nOutputRows,
            sipName_rasterEntries,
            sipName_transformContext,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1J9iiJ1J9", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State, sipType_QgsRectangle, &a3, &a4, &a5, sipType_QVector_0100QgsRasterCalculatorEntry,&a6, &a6State, sipType_QgsCoordinateTransformContext, &a7))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalculator(*a0,*a1,*a2,*a3,a4,a5,*a6,*a7);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a6),sipType_QVector_0100QgsRasterCalculatorEntry,a6State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a6),sipType_QVector_0100QgsRasterCalculatorEntry,a6State);

            return sipCpp;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;
        const  ::QgsRectangle* a3;
        const  ::QgsCoordinateReferenceSystem* a4;
        int a5;
        int a6;
        const QVector< ::QgsRasterCalculatorEntry>* a7;
        int a7State = 0;
        const  ::QgsCoordinateTransformContext* a8;

        static const char *sipKwdList[] = {
            sipName_formulaString,
            sipName_outputFile,
            sipName_outputFormat,
            sipName_outputExtent,
            sipName_outputCrs,
            sipName_nOutputColumns,
            sipName_nOutputRows,
            sipName_rasterEntries,
            sipName_transformContext,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1J9J9iiJ1J9", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State, sipType_QgsRectangle, &a3, sipType_QgsCoordinateReferenceSystem, &a4, &a5, &a6, sipType_QVector_0100QgsRasterCalculatorEntry,&a7, &a7State, sipType_QgsCoordinateTransformContext, &a8))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalculator(*a0,*a1,*a2,*a3,*a4,a5,a6,*a7,*a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a7),sipType_QVector_0100QgsRasterCalculatorEntry,a7State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a7),sipType_QVector_0100QgsRasterCalculatorEntry,a7State);

            return sipCpp;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;
        const  ::QgsRectangle* a3;
        int a4;
        int a5;
        const QVector< ::QgsRasterCalculatorEntry>* a6;
        int a6State = 0;

        static const char *sipKwdList[] = {
            sipName_formulaString,
            sipName_outputFile,
            sipName_outputFormat,
            sipName_outputExtent,
            sipName_nOutputColumns,
            sipName_nOutputRows,
            sipName_rasterEntries,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1J9iiJ1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State, sipType_QgsRectangle, &a3, &a4, &a5, sipType_QVector_0100QgsRasterCalculatorEntry,&a6, &a6State))
        {
            if (sipDeprecated(sipName_QgsRasterCalculator,NULL) < 0)
                return NULL;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalculator(*a0,*a1,*a2,*a3,a4,a5,*a6);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a6),sipType_QVector_0100QgsRasterCalculatorEntry,a6State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a6),sipType_QVector_0100QgsRasterCalculatorEntry,a6State);

            return sipCpp;
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;
        const  ::QgsRectangle* a3;
        const  ::QgsCoordinateReferenceSystem* a4;
        int a5;
        int a6;
        const QVector< ::QgsRasterCalculatorEntry>* a7;
        int a7State = 0;

        static const char *sipKwdList[] = {
            sipName_formulaString,
            sipName_outputFile,
            sipName_outputFormat,
            sipName_outputExtent,
            sipName_outputCrs,
            sipName_nOutputColumns,
            sipName_nOutputRows,
            sipName_rasterEntries,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1J9J9iiJ1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State, sipType_QgsRectangle, &a3, sipType_QgsCoordinateReferenceSystem, &a4, &a5, &a6, sipType_QVector_0100QgsRasterCalculatorEntry,&a7, &a7State))
        {
            if (sipDeprecated(sipName_QgsRasterCalculator,NULL) < 0)
                return NULL;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalculator(*a0,*a1,*a2,*a3,*a4,a5,a6,*a7);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a7),sipType_QVector_0100QgsRasterCalculatorEntry,a7State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast<QVector< ::QgsRasterCalculatorEntry> *>(a7),sipType_QVector_0100QgsRasterCalculatorEntry,a7State);

            return sipCpp;
        }
    }

    {
        const  ::QgsRasterCalculator* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsRasterCalculator, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalculator(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsRasterCalculator[] = {
    {SIP_MLNAME_CAST(sipName_lastError), meth_QgsRasterCalculator_lastError, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterCalculator_lastError)},
    {SIP_MLNAME_CAST(sipName_processCalculation), (PyCFunction)meth_QgsRasterCalculator_processCalculation, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsRasterCalculator_processCalculation)}
};

static sipEnumMemberDef enummembers_QgsRasterCalculator[] = {
    {sipName_BandError, static_cast<int>( ::QgsRasterCalculator::BandError), 75},
    {sipName_Canceled, static_cast<int>( ::QgsRasterCalculator::Canceled), 75},
    {sipName_CreateOutputError, static_cast<int>( ::QgsRasterCalculator::CreateOutputError), 75},
    {sipName_InputLayerError, static_cast<int>( ::QgsRasterCalculator::InputLayerError), 75},
    {sipName_MemoryError, static_cast<int>( ::QgsRasterCalculator::MemoryError), 75},
    {sipName_ParserError, static_cast<int>( ::QgsRasterCalculator::ParserError), 75},
    {sipName_Success, static_cast<int>( ::QgsRasterCalculator::Success), 75},
};

PyDoc_STRVAR(doc_QgsRasterCalculator, "QgsRasterCalculator(formulaString: str, outputFile: str, outputFormat: str, outputExtent: QgsRectangle, nOutputColumns: int, nOutputRows: int, rasterEntries: Iterable[QgsRasterCalculatorEntry], transformContext: QgsCoordinateTransformContext)\n"
"QgsRasterCalculator constructor.\n"
"\n"
":param formulaString: formula for raster calculation\n"
":param outputFile: output file path\n"
":param outputFormat: output file format\n"
":param outputExtent: output extent. CRS for output is taken from first entry in rasterEntries.\n"
":param nOutputColumns: number of columns in output raster\n"
":param nOutputRows: number of rows in output raster\n"
":param rasterEntries: list of referenced raster layers\n"
":param transformContext: coordinate transformation context\n"
"\n"
".. versionadded:: 3.8\n"
"\n"
"QgsRasterCalculator(formulaString: str, outputFile: str, outputFormat: str, outputExtent: QgsRectangle, outputCrs: QgsCoordinateReferenceSystem, nOutputColumns: int, nOutputRows: int, rasterEntries: Iterable[QgsRasterCalculatorEntry], transformContext: QgsCoordinateTransformContext)\n"
"QgsRasterCalculator constructor.\n"
"\n"
":param formulaString: formula for raster calculation\n"
":param outputFile: output file path\n"
":param outputFormat: output file format\n"
":param outputExtent: output extent, CRS is specified by outputCrs parameter\n"
":param outputCrs: destination CRS for output raster\n"
":param nOutputColumns: number of columns in output raster\n"
":param nOutputRows: number of rows in output raster\n"
":param rasterEntries: list of referenced raster layers\n"
":param transformContext: coordinate transformation context\n"
"\n"
".. versionadded:: 3.8\n"
"\n"
"QgsRasterCalculator(formulaString: str, outputFile: str, outputFormat: str, outputExtent: QgsRectangle, nOutputColumns: int, nOutputRows: int, rasterEntries: Iterable[QgsRasterCalculatorEntry])\n"
"QgsRasterCalculator constructor.\n"
"\n"
":param formulaString: formula for raster calculation\n"
":param outputFile: output file path\n"
":param outputFormat: output file format\n"
":param outputExtent: output extent. CRS for output is taken from first entry in rasterEntries.\n"
":param nOutputColumns: number of columns in output raster\n"
":param nOutputRows: number of rows in output raster\n"
":param rasterEntries: list of referenced raster layers\n"
"\n"
".. deprecated:: since QGIS 3.8, use the version with transformContext instead\n"
"\n"
"QgsRasterCalculator(formulaString: str, outputFile: str, outputFormat: str, outputExtent: QgsRectangle, outputCrs: QgsCoordinateReferenceSystem, nOutputColumns: int, nOutputRows: int, rasterEntries: Iterable[QgsRasterCalculatorEntry])\n"
"QgsRasterCalculator constructor.\n"
"\n"
":param formulaString: formula for raster calculation\n"
":param outputFile: output file path\n"
":param outputFormat: output file format\n"
":param outputExtent: output extent, CRS is specified by outputCrs parameter\n"
":param outputCrs: destination CRS for output raster\n"
":param nOutputColumns: number of columns in output raster\n"
":param nOutputRows: number of rows in output raster\n"
":param rasterEntries: list of referenced raster layers\n"
"\n"
".. deprecated:: since QGIS 3.8, use the version with transformContext instead\n"
"\n"
".. versionadded:: 2.10\n"
"\n"
"QgsRasterCalculator(QgsRasterCalculator)\n"
"\n"
"Performs raster layer calculations.");


static pyqt5ClassPluginDef plugin_QgsRasterCalculator = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsRasterCalculator = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsRasterCalculator,
        {0},
        &plugin_QgsRasterCalculator
    },
    {
        sipNameNr_QgsRasterCalculator,
        {0, 0, 1},
        2, methods_QgsRasterCalculator,
        7, enummembers_QgsRasterCalculator,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsRasterCalculator,
    -1,
    -1,
    0,
    0,
    init_type_QgsRasterCalculator,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsRasterCalculator,
    0,
    0,
    0,
    release_QgsRasterCalculator,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsrastercalculator.sip"
#include "qgsrastercalculator.h"
#line 1680 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 81 "core/auto_generated/raster/qgsrasterlayer.sip"
#include "qgsrasterlayer.h"
#line 1684 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 1687 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 1690 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


PyDoc_STRVAR(doc_QgsRasterCalculatorEntry_rasterEntries, "rasterEntries() -> object\n"
"Creates a list of raster entries from the current project.\n"
"\n"
"If there is more than one layer with the same data source\n"
"only one of them is added to the list, duplicate names are\n"
"also handled by appending an _n integer to the base name.\n"
"\n"
":return: the list of raster entries form the current project\n"
"\n"
".. versionadded:: 3.6");

extern "C" {static PyObject *meth_QgsRasterCalculatorEntry_rasterEntries(PyObject *, PyObject *);}
static PyObject *meth_QgsRasterCalculatorEntry_rasterEntries(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            QVector< ::QgsRasterCalculatorEntry>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new QVector< ::QgsRasterCalculatorEntry>( ::QgsRasterCalculatorEntry::rasterEntries());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVector_0100QgsRasterCalculatorEntry,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsRasterCalculatorEntry, sipName_rasterEntries, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsRasterCalculatorEntry(void *, int);}
static void release_QgsRasterCalculatorEntry(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsRasterCalculatorEntry(void *, SIP_SSIZE_T, void *);}
static void assign_QgsRasterCalculatorEntry(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipSrc);
}


extern "C" {static void *array_QgsRasterCalculatorEntry(SIP_SSIZE_T);}
static void *array_QgsRasterCalculatorEntry(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsRasterCalculatorEntry[sipNrElem];
}


extern "C" {static void *copy_QgsRasterCalculatorEntry(const void *, SIP_SSIZE_T);}
static void *copy_QgsRasterCalculatorEntry(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsRasterCalculatorEntry(reinterpret_cast<const  ::QgsRasterCalculatorEntry *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsRasterCalculatorEntry(sipSimpleWrapper *);}
static void dealloc_QgsRasterCalculatorEntry(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsRasterCalculatorEntry(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsRasterCalculatorEntry(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsRasterCalculatorEntry(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsRasterCalculatorEntry *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalculatorEntry();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsRasterCalculatorEntry* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsRasterCalculatorEntry, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsRasterCalculatorEntry(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsRasterCalculatorEntry[] = {
    {SIP_MLNAME_CAST(sipName_rasterEntries), meth_QgsRasterCalculatorEntry_rasterEntries, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsRasterCalculatorEntry_rasterEntries)}
};


extern "C" {static PyObject *varget_QgsRasterCalculatorEntry_bandNumber(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsRasterCalculatorEntry_bandNumber(void *sipSelf, PyObject *, PyObject *)
{
    int sipVal;
     ::QgsRasterCalculatorEntry *sipCpp = reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipSelf);

    sipVal = sipCpp->bandNumber;

    return SIPLong_FromLong(sipVal);
}


extern "C" {static int varset_QgsRasterCalculatorEntry_bandNumber(void *, PyObject *, PyObject *);}
static int varset_QgsRasterCalculatorEntry_bandNumber(void *sipSelf, PyObject *sipPy, PyObject *)
{
    int sipVal;
     ::QgsRasterCalculatorEntry *sipCpp = reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipSelf);

    sipVal = sipLong_AsInt(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->bandNumber = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsRasterCalculatorEntry_raster(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsRasterCalculatorEntry_raster(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsRasterLayer*sipVal;
     ::QgsRasterCalculatorEntry *sipCpp = reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipSelf);

    sipVal = sipCpp->raster;

    return sipConvertFromType(sipVal, sipType_QgsRasterLayer, NULL);
}


extern "C" {static int varset_QgsRasterCalculatorEntry_raster(void *, PyObject *, PyObject *);}
static int varset_QgsRasterCalculatorEntry_raster(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsRasterLayer*sipVal;
     ::QgsRasterCalculatorEntry *sipCpp = reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QgsRasterLayer *>(sipForceConvertToType(sipPy,sipType_QgsRasterLayer,NULL,0,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->raster = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsRasterCalculatorEntry_ref(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsRasterCalculatorEntry_ref(void *sipSelf, PyObject *, PyObject *)
{
     ::QString*sipVal;
     ::QgsRasterCalculatorEntry *sipCpp = reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipSelf);

    sipVal = &sipCpp->ref;

    return sipConvertFromType(sipVal, sipType_QString, NULL);
}


extern "C" {static int varset_QgsRasterCalculatorEntry_ref(void *, PyObject *, PyObject *);}
static int varset_QgsRasterCalculatorEntry_ref(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QString*sipVal;
     ::QgsRasterCalculatorEntry *sipCpp = reinterpret_cast< ::QgsRasterCalculatorEntry *>(sipSelf);

    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QString *>(sipForceConvertToType(sipPy,sipType_QString,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->ref = *sipVal;

    sipReleaseType(sipVal, sipType_QString, sipValState);

    return 0;
}

sipVariableDef variables_QgsRasterCalculatorEntry[] = {
    {InstanceVariable, sipName_bandNumber, (PyMethodDef *)varget_QgsRasterCalculatorEntry_bandNumber, (PyMethodDef *)varset_QgsRasterCalculatorEntry_bandNumber, NULL, NULL},
    {InstanceVariable, sipName_raster, (PyMethodDef *)varget_QgsRasterCalculatorEntry_raster, (PyMethodDef *)varset_QgsRasterCalculatorEntry_raster, NULL, NULL},
    {InstanceVariable, sipName_ref, (PyMethodDef *)varget_QgsRasterCalculatorEntry_ref, (PyMethodDef *)varset_QgsRasterCalculatorEntry_ref, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsRasterCalculatorEntry, "\n"
"\n"
"\n"
"Represents an individual raster layer/band number entry within a raster calculation.\n"
"\n"
".. versionadded:: 2.18");


static pyqt5ClassPluginDef plugin_QgsRasterCalculatorEntry = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsRasterCalculatorEntry = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsRasterCalculatorEntry,
        {0},
        &plugin_QgsRasterCalculatorEntry
    },
    {
        sipNameNr_QgsRasterCalculatorEntry,
        {0, 0, 1},
        1, methods_QgsRasterCalculatorEntry,
        0, 0,
        3, variables_QgsRasterCalculatorEntry,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsRasterCalculatorEntry,
    -1,
    -1,
    0,
    0,
    init_type_QgsRasterCalculatorEntry,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsRasterCalculatorEntry,
    assign_QgsRasterCalculatorEntry,
    array_QgsRasterCalculatorEntry,
    copy_QgsRasterCalculatorEntry,
    release_QgsRasterCalculatorEntry,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 23 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgskde.sip"
#include "qgskde.h"
#line 2007 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 23 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgskde.sip"
#include "qgskde.h"
#line 2011 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 2014 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 22 "core/auto_generated/qgsfeaturesource.sip"
#include "qgsfeaturesource.h"
#line 2017 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


/* Call the instance's destructor. */
extern "C" {static void release_QgsKernelDensityEstimation_Parameters(void *, int);}
static void release_QgsKernelDensityEstimation_Parameters(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsKernelDensityEstimation_Parameters(void *, SIP_SSIZE_T, void *);}
static void assign_QgsKernelDensityEstimation_Parameters(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSrc);
}


extern "C" {static void *array_QgsKernelDensityEstimation_Parameters(SIP_SSIZE_T);}
static void *array_QgsKernelDensityEstimation_Parameters(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsKernelDensityEstimation::Parameters[sipNrElem];
}


extern "C" {static void *copy_QgsKernelDensityEstimation_Parameters(const void *, SIP_SSIZE_T);}
static void *copy_QgsKernelDensityEstimation_Parameters(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsKernelDensityEstimation::Parameters(reinterpret_cast<const  ::QgsKernelDensityEstimation::Parameters *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsKernelDensityEstimation_Parameters(sipSimpleWrapper *);}
static void dealloc_QgsKernelDensityEstimation_Parameters(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsKernelDensityEstimation_Parameters(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsKernelDensityEstimation_Parameters(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsKernelDensityEstimation_Parameters(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsKernelDensityEstimation::Parameters *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsKernelDensityEstimation::Parameters();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsKernelDensityEstimation::Parameters* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsKernelDensityEstimation_Parameters, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsKernelDensityEstimation::Parameters(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_decayRatio(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_decayRatio(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = sipCpp->decayRatio;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_decayRatio(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_decayRatio(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->decayRatio = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_outputValues(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_outputValues(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsKernelDensityEstimation::OutputValues sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = sipCpp->outputValues;

    return sipConvertFromEnum(static_cast<int>(sipVal), sipType_QgsKernelDensityEstimation_OutputValues);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_outputValues(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_outputValues(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsKernelDensityEstimation::OutputValues sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = ( ::QgsKernelDensityEstimation::OutputValues)sipConvertToEnum(sipPy, sipType_QgsKernelDensityEstimation_OutputValues);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->outputValues = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_pixelSize(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_pixelSize(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = sipCpp->pixelSize;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_pixelSize(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_pixelSize(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->pixelSize = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_radius(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_radius(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = sipCpp->radius;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_radius(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_radius(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->radius = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_radiusField(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_radiusField(void *sipSelf, PyObject *, PyObject *)
{
     ::QString*sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = &sipCpp->radiusField;

    return sipConvertFromType(sipVal, sipType_QString, NULL);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_radiusField(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_radiusField(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QString*sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QString *>(sipForceConvertToType(sipPy,sipType_QString,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->radiusField = *sipVal;

    sipReleaseType(sipVal, sipType_QString, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_shape(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_shape(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsKernelDensityEstimation::KernelShape sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = sipCpp->shape;

    return sipConvertFromEnum(static_cast<int>(sipVal), sipType_QgsKernelDensityEstimation_KernelShape);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_shape(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_shape(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsKernelDensityEstimation::KernelShape sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = ( ::QgsKernelDensityEstimation::KernelShape)sipConvertToEnum(sipPy, sipType_QgsKernelDensityEstimation_KernelShape);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->shape = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_source(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_source(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsFeatureSource*sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = sipCpp->source;

    return sipConvertFromType(sipVal, sipType_QgsFeatureSource, NULL);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_source(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_source(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsFeatureSource*sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QgsFeatureSource *>(sipForceConvertToType(sipPy,sipType_QgsFeatureSource,NULL,0,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->source = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsKernelDensityEstimation_Parameters_weightField(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsKernelDensityEstimation_Parameters_weightField(void *sipSelf, PyObject *, PyObject *)
{
     ::QString*sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    sipVal = &sipCpp->weightField;

    return sipConvertFromType(sipVal, sipType_QString, NULL);
}


extern "C" {static int varset_QgsKernelDensityEstimation_Parameters_weightField(void *, PyObject *, PyObject *);}
static int varset_QgsKernelDensityEstimation_Parameters_weightField(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QString*sipVal;
     ::QgsKernelDensityEstimation::Parameters *sipCpp = reinterpret_cast< ::QgsKernelDensityEstimation::Parameters *>(sipSelf);

    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QString *>(sipForceConvertToType(sipPy,sipType_QString,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->weightField = *sipVal;

    sipReleaseType(sipVal, sipType_QString, sipValState);

    return 0;
}

sipVariableDef variables_QgsKernelDensityEstimation_Parameters[] = {
    {InstanceVariable, sipName_decayRatio, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_decayRatio, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_decayRatio, NULL, NULL},
    {InstanceVariable, sipName_outputValues, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_outputValues, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_outputValues, NULL, NULL},
    {InstanceVariable, sipName_pixelSize, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_pixelSize, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_pixelSize, NULL, NULL},
    {InstanceVariable, sipName_radius, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_radius, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_radius, NULL, NULL},
    {InstanceVariable, sipName_radiusField, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_radiusField, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_radiusField, NULL, NULL},
    {InstanceVariable, sipName_shape, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_shape, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_shape, NULL, NULL},
    {InstanceVariable, sipName_source, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_source, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_source, NULL, NULL},
    {InstanceVariable, sipName_weightField, (PyMethodDef *)varget_QgsKernelDensityEstimation_Parameters_weightField, (PyMethodDef *)varset_QgsKernelDensityEstimation_Parameters_weightField, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsKernelDensityEstimation_Parameters, "\1QgsKernelDensityEstimation.Parameters()\n"
"QgsKernelDensityEstimation.Parameters(QgsKernelDensityEstimation.Parameters)");


static pyqt5ClassPluginDef plugin_QgsKernelDensityEstimation_Parameters = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsKernelDensityEstimation_Parameters = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsKernelDensityEstimation__Parameters,
        {0},
        &plugin_QgsKernelDensityEstimation_Parameters
    },
    {
        sipNameNr_Parameters,
        {59, 255, 0},
        0, 0,
        0, 0,
        8, variables_QgsKernelDensityEstimation_Parameters,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsKernelDensityEstimation_Parameters,
    -1,
    -1,
    0,
    0,
    init_type_QgsKernelDensityEstimation_Parameters,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsKernelDensityEstimation_Parameters,
    assign_QgsKernelDensityEstimation_Parameters,
    array_QgsKernelDensityEstimation_Parameters,
    copy_QgsKernelDensityEstimation_Parameters,
    release_QgsKernelDensityEstimation_Parameters,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 23 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgskde.sip"
#include "qgskde.h"
#line 2435 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 23 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgskde.sip"
#include "qgskde.h"
#line 2439 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 2442 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 2448 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


PyDoc_STRVAR(doc_QgsKernelDensityEstimation_run, "run(self) -> QgsKernelDensityEstimation.Result\n"
"Runs the KDE calculation across the whole layer at once. Either call this method, or manually\n"
"call run(), addFeature() and finalise() separately.");

extern "C" {static PyObject *meth_QgsKernelDensityEstimation_run(PyObject *, PyObject *);}
static PyObject *meth_QgsKernelDensityEstimation_run(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsKernelDensityEstimation *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsKernelDensityEstimation, &sipCpp))
        {
             ::QgsKernelDensityEstimation::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->run();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsKernelDensityEstimation_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsKernelDensityEstimation, sipName_run, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsKernelDensityEstimation_prepare, "prepare(self) -> QgsKernelDensityEstimation.Result\n"
"Prepares the output file for writing and setups up the surface calculation. This must be called\n"
"before adding features via addFeature().\n"
"\n"
".. seealso:: :py:func:`addFeature`\n"
"\n"
".. seealso:: :py:func:`finalise`");

extern "C" {static PyObject *meth_QgsKernelDensityEstimation_prepare(PyObject *, PyObject *);}
static PyObject *meth_QgsKernelDensityEstimation_prepare(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsKernelDensityEstimation *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsKernelDensityEstimation, &sipCpp))
        {
             ::QgsKernelDensityEstimation::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->prepare();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsKernelDensityEstimation_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsKernelDensityEstimation, sipName_prepare, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsKernelDensityEstimation_addFeature, "addFeature(self, feature: QgsFeature) -> QgsKernelDensityEstimation.Result\n"
"Adds a single feature to the KDE surface. prepare() must be called before adding features.\n"
"\n"
".. seealso:: :py:func:`prepare`\n"
"\n"
".. seealso:: :py:func:`finalise`");

extern "C" {static PyObject *meth_QgsKernelDensityEstimation_addFeature(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsKernelDensityEstimation_addFeature(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsFeature* a0;
         ::QgsKernelDensityEstimation *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feature,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsKernelDensityEstimation, &sipCpp, sipType_QgsFeature, &a0))
        {
             ::QgsKernelDensityEstimation::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->addFeature(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsKernelDensityEstimation_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsKernelDensityEstimation, sipName_addFeature, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsKernelDensityEstimation_finalise, "finalise(self) -> QgsKernelDensityEstimation.Result\n"
"Finalises the output file. Must be called after adding all features via addFeature().\n"
"\n"
".. seealso:: :py:func:`prepare`\n"
"\n"
".. seealso:: :py:func:`addFeature`");

extern "C" {static PyObject *meth_QgsKernelDensityEstimation_finalise(PyObject *, PyObject *);}
static PyObject *meth_QgsKernelDensityEstimation_finalise(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsKernelDensityEstimation *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsKernelDensityEstimation, &sipCpp))
        {
             ::QgsKernelDensityEstimation::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->finalise();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsKernelDensityEstimation_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsKernelDensityEstimation, sipName_finalise, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsKernelDensityEstimation(void *, int);}
static void release_QgsKernelDensityEstimation(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsKernelDensityEstimation *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsKernelDensityEstimation(sipSimpleWrapper *);}
static void dealloc_QgsKernelDensityEstimation(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsKernelDensityEstimation(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsKernelDensityEstimation(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsKernelDensityEstimation(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsKernelDensityEstimation *sipCpp = 0;

    {
        const  ::QgsKernelDensityEstimation::Parameters* a0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_parameters,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J1J1", sipType_QgsKernelDensityEstimation_Parameters, &a0, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsKernelDensityEstimation(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsKernelDensityEstimation[] = {
    {SIP_MLNAME_CAST(sipName_addFeature), (PyCFunction)meth_QgsKernelDensityEstimation_addFeature, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsKernelDensityEstimation_addFeature)},
    {SIP_MLNAME_CAST(sipName_finalise), meth_QgsKernelDensityEstimation_finalise, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsKernelDensityEstimation_finalise)},
    {SIP_MLNAME_CAST(sipName_prepare), meth_QgsKernelDensityEstimation_prepare, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsKernelDensityEstimation_prepare)},
    {SIP_MLNAME_CAST(sipName_run), meth_QgsKernelDensityEstimation_run, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsKernelDensityEstimation_run)}
};

static sipEnumMemberDef enummembers_QgsKernelDensityEstimation[] = {
    {sipName_DriverError, static_cast<int>( ::QgsKernelDensityEstimation::DriverError), 63},
    {sipName_FileCreationError, static_cast<int>( ::QgsKernelDensityEstimation::FileCreationError), 63},
    {sipName_InvalidParameters, static_cast<int>( ::QgsKernelDensityEstimation::InvalidParameters), 63},
    {sipName_KernelEpanechnikov, static_cast<int>( ::QgsKernelDensityEstimation::KernelEpanechnikov), 60},
    {sipName_KernelQuartic, static_cast<int>( ::QgsKernelDensityEstimation::KernelQuartic), 60},
    {sipName_KernelTriangular, static_cast<int>( ::QgsKernelDensityEstimation::KernelTriangular), 60},
    {sipName_KernelTriweight, static_cast<int>( ::QgsKernelDensityEstimation::KernelTriweight), 60},
    {sipName_KernelUniform, static_cast<int>( ::QgsKernelDensityEstimation::KernelUniform), 60},
    {sipName_OutputRaw, static_cast<int>( ::QgsKernelDensityEstimation::OutputRaw), 61},
    {sipName_OutputScaled, static_cast<int>( ::QgsKernelDensityEstimation::OutputScaled), 61},
    {sipName_RasterIoError, static_cast<int>( ::QgsKernelDensityEstimation::RasterIoError), 63},
    {sipName_Success, static_cast<int>( ::QgsKernelDensityEstimation::Success), 63},
};

PyDoc_STRVAR(doc_QgsKernelDensityEstimation, "QgsKernelDensityEstimation(parameters: QgsKernelDensityEstimation.Parameters, outputFile: str, outputFormat: str)\n"
"Constructor for QgsKernelDensityEstimation. Requires a Parameters object specifying the options to use\n"
"to generate the surface. The output path and file format are also required.\n"
"\n"
"Performs Kernel Density Estimation (\"heatmap\") calculations on a vector layer.\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsKernelDensityEstimation = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsKernelDensityEstimation = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsKernelDensityEstimation,
        {0},
        &plugin_QgsKernelDensityEstimation
    },
    {
        sipNameNr_QgsKernelDensityEstimation,
        {0, 0, 1},
        4, methods_QgsKernelDensityEstimation,
        12, enummembers_QgsKernelDensityEstimation,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsKernelDensityEstimation,
    -1,
    -1,
    0,
    0,
    init_type_QgsKernelDensityEstimation,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsKernelDensityEstimation,
    0,
    0,
    0,
    release_QgsKernelDensityEstimation,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 16 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgshillshadefilter.sip"
#include "qgshillshadefilter.h"
#line 2793 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 2797 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 2800 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


class sipQgsHillshadeFilter : public  ::QgsHillshadeFilter
{
public:
    sipQgsHillshadeFilter(const  ::QString&,const  ::QString&,const  ::QString&,double,double);
    sipQgsHillshadeFilter(const  ::QgsHillshadeFilter&);
    virtual ~sipQgsHillshadeFilter();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    float sipProtect_calcFirstDerX(float*,float*,float*,float*,float*,float*,float*,float*,float*);
    float sipProtect_calcFirstDerY(float*,float*,float*,float*,float*,float*,float*,float*,float*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    float processNineCellWindow(float*,float*,float*,float*,float*,float*,float*,float*,float*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsHillshadeFilter(const sipQgsHillshadeFilter &);
    sipQgsHillshadeFilter &operator = (const sipQgsHillshadeFilter &);

    char sipPyMethods[1];
};

sipQgsHillshadeFilter::sipQgsHillshadeFilter(const  ::QString& a0,const  ::QString& a1,const  ::QString& a2,double a3,double a4):  ::QgsHillshadeFilter(a0,a1,a2,a3,a4), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsHillshadeFilter::sipQgsHillshadeFilter(const  ::QgsHillshadeFilter& a0):  ::QgsHillshadeFilter(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsHillshadeFilter::~sipQgsHillshadeFilter()
{
    sipInstanceDestroyed(sipPySelf);
}

float sipQgsHillshadeFilter::processNineCellWindow(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_processNineCellWindow);

    if (!sipMeth)
        return  ::QgsHillshadeFilter::processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8);

    extern float sipVH__analysis_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, float*,float*,float*,float*,float*,float*,float*,float*,float*);

    return sipVH__analysis_1(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

float sipQgsHillshadeFilter::sipProtect_calcFirstDerX(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerX(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}

float sipQgsHillshadeFilter::sipProtect_calcFirstDerY(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerY(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}


PyDoc_STRVAR(doc_QgsHillshadeFilter_calcFirstDerX, "calcFirstDerX(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in x-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsHillshadeFilter_calcFirstDerX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsHillshadeFilter_calcFirstDerX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsHillshadeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsHillshadeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerX(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsHillshadeFilter, sipName_calcFirstDerX, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsHillshadeFilter_calcFirstDerY, "calcFirstDerY(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in y-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsHillshadeFilter_calcFirstDerY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsHillshadeFilter_calcFirstDerY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsHillshadeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsHillshadeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerY(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsHillshadeFilter, sipName_calcFirstDerY, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsHillshadeFilter_processNineCellWindow, "processNineCellWindow(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates output value from nine input values. The input values and the output value can be equal to the\n"
"nodata value if not present or outside of the border. Must be implemented by subclasses*");

extern "C" {static PyObject *meth_QgsHillshadeFilter_processNineCellWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsHillshadeFilter_processNineCellWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
         ::QgsHillshadeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsHillshadeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsHillshadeFilter::processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8) : sipCpp->processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsHillshadeFilter, sipName_processNineCellWindow, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsHillshadeFilter_lightAzimuth, "lightAzimuth(self) -> float");

extern "C" {static PyObject *meth_QgsHillshadeFilter_lightAzimuth(PyObject *, PyObject *);}
static PyObject *meth_QgsHillshadeFilter_lightAzimuth(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsHillshadeFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsHillshadeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->lightAzimuth();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble((double)sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsHillshadeFilter, sipName_lightAzimuth, doc_QgsHillshadeFilter_lightAzimuth);

    return NULL;
}


PyDoc_STRVAR(doc_QgsHillshadeFilter_setLightAzimuth, "setLightAzimuth(self, azimuth: float)");

extern "C" {static PyObject *meth_QgsHillshadeFilter_setLightAzimuth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsHillshadeFilter_setLightAzimuth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
         ::QgsHillshadeFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_azimuth,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bf", &sipSelf, sipType_QgsHillshadeFilter, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setLightAzimuth(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsHillshadeFilter, sipName_setLightAzimuth, doc_QgsHillshadeFilter_setLightAzimuth);

    return NULL;
}


PyDoc_STRVAR(doc_QgsHillshadeFilter_lightAngle, "lightAngle(self) -> float");

extern "C" {static PyObject *meth_QgsHillshadeFilter_lightAngle(PyObject *, PyObject *);}
static PyObject *meth_QgsHillshadeFilter_lightAngle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsHillshadeFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsHillshadeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->lightAngle();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble((double)sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsHillshadeFilter, sipName_lightAngle, doc_QgsHillshadeFilter_lightAngle);

    return NULL;
}


PyDoc_STRVAR(doc_QgsHillshadeFilter_setLightAngle, "setLightAngle(self, angle: float)");

extern "C" {static PyObject *meth_QgsHillshadeFilter_setLightAngle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsHillshadeFilter_setLightAngle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
         ::QgsHillshadeFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_angle,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bf", &sipSelf, sipType_QgsHillshadeFilter, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setLightAngle(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsHillshadeFilter, sipName_setLightAngle, doc_QgsHillshadeFilter_setLightAngle);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsHillshadeFilter(void *, const sipTypeDef *);}
static void *cast_QgsHillshadeFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsHillshadeFilter *sipCpp = reinterpret_cast< ::QgsHillshadeFilter *>(sipCppV);

    if (targetType == sipType_QgsDerivativeFilter)
        return static_cast< ::QgsDerivativeFilter *>(sipCpp);

    if (targetType == sipType_QgsNineCellFilter)
        return static_cast< ::QgsNineCellFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsHillshadeFilter(void *, int);}
static void release_QgsHillshadeFilter(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsHillshadeFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsHillshadeFilter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsHillshadeFilter(sipSimpleWrapper *);}
static void dealloc_QgsHillshadeFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsHillshadeFilter *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsHillshadeFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsHillshadeFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsHillshadeFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsHillshadeFilter *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;
        double a3 = 300;
        double a4 = 40;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
            sipName_lightAzimuth,
            sipName_lightAngle,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1|dd", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State, &a3, &a4))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsHillshadeFilter(*a0,*a1,*a2,a3,a4);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsHillshadeFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsHillshadeFilter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsHillshadeFilter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsHillshadeFilter[] = {{17, 255, 1}};


static PyMethodDef methods_QgsHillshadeFilter[] = {
    {SIP_MLNAME_CAST(sipName_calcFirstDerX), (PyCFunction)meth_QgsHillshadeFilter_calcFirstDerX, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_calcFirstDerY), (PyCFunction)meth_QgsHillshadeFilter_calcFirstDerY, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_lightAngle), meth_QgsHillshadeFilter_lightAngle, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsHillshadeFilter_lightAngle)},
    {SIP_MLNAME_CAST(sipName_lightAzimuth), meth_QgsHillshadeFilter_lightAzimuth, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsHillshadeFilter_lightAzimuth)},
    {SIP_MLNAME_CAST(sipName_processNineCellWindow), (PyCFunction)meth_QgsHillshadeFilter_processNineCellWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsHillshadeFilter_processNineCellWindow)},
    {SIP_MLNAME_CAST(sipName_setLightAngle), (PyCFunction)meth_QgsHillshadeFilter_setLightAngle, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsHillshadeFilter_setLightAngle)},
    {SIP_MLNAME_CAST(sipName_setLightAzimuth), (PyCFunction)meth_QgsHillshadeFilter_setLightAzimuth, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsHillshadeFilter_setLightAzimuth)}
};

PyDoc_STRVAR(doc_QgsHillshadeFilter, "\1QgsHillshadeFilter(inputFile: str, outputFile: str, outputFormat: str, lightAzimuth: float = 300, lightAngle: float = 40)\n"
"QgsHillshadeFilter(QgsHillshadeFilter)");


static pyqt5ClassPluginDef plugin_QgsHillshadeFilter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsHillshadeFilter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsHillshadeFilter,
        {0},
        &plugin_QgsHillshadeFilter
    },
    {
        sipNameNr_QgsHillshadeFilter,
        {0, 0, 1},
        7, methods_QgsHillshadeFilter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsHillshadeFilter,
    -1,
    -1,
    supers_QgsHillshadeFilter,
    0,
    init_type_QgsHillshadeFilter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsHillshadeFilter,
    0,
    0,
    0,
    release_QgsHillshadeFilter,
    cast_QgsHillshadeFilter,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 20 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsexiftools.sip"
#include "qgsexiftools.h"
#line 46 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsexiftools.sip"
#include "qgsexiftools.h"
#line 3400 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"



/* Call the instance's destructor. */
extern "C" {static void release_QgsExifTools_GeoTagDetails(void *, int);}
static void release_QgsExifTools_GeoTagDetails(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsExifTools::GeoTagDetails *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsExifTools_GeoTagDetails(void *, SIP_SSIZE_T, void *);}
static void assign_QgsExifTools_GeoTagDetails(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsExifTools::GeoTagDetails *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsExifTools::GeoTagDetails *>(sipSrc);
}


extern "C" {static void *array_QgsExifTools_GeoTagDetails(SIP_SSIZE_T);}
static void *array_QgsExifTools_GeoTagDetails(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsExifTools::GeoTagDetails[sipNrElem];
}


extern "C" {static void *copy_QgsExifTools_GeoTagDetails(const void *, SIP_SSIZE_T);}
static void *copy_QgsExifTools_GeoTagDetails(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsExifTools::GeoTagDetails(reinterpret_cast<const  ::QgsExifTools::GeoTagDetails *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsExifTools_GeoTagDetails(sipSimpleWrapper *);}
static void dealloc_QgsExifTools_GeoTagDetails(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsExifTools_GeoTagDetails(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsExifTools_GeoTagDetails(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsExifTools_GeoTagDetails(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsExifTools::GeoTagDetails *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsExifTools::GeoTagDetails();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsExifTools::GeoTagDetails* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsExifTools_GeoTagDetails, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsExifTools::GeoTagDetails(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_QgsExifTools_GeoTagDetails_elevation(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsExifTools_GeoTagDetails_elevation(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsExifTools::GeoTagDetails *sipCpp = reinterpret_cast< ::QgsExifTools::GeoTagDetails *>(sipSelf);

    sipVal = sipCpp->elevation;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsExifTools_GeoTagDetails_elevation(void *, PyObject *, PyObject *);}
static int varset_QgsExifTools_GeoTagDetails_elevation(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsExifTools::GeoTagDetails *sipCpp = reinterpret_cast< ::QgsExifTools::GeoTagDetails *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->elevation = sipVal;

    return 0;
}

sipVariableDef variables_QgsExifTools_GeoTagDetails[] = {
    {InstanceVariable, sipName_elevation, (PyMethodDef *)varget_QgsExifTools_GeoTagDetails_elevation, (PyMethodDef *)varset_QgsExifTools_GeoTagDetails_elevation, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsExifTools_GeoTagDetails, "\n"
"\n"
"\n"
"Extended image geotag details.\n"
"\n"
".. versionadded:: 3.6");


static pyqt5ClassPluginDef plugin_QgsExifTools_GeoTagDetails = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsExifTools_GeoTagDetails = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsExifTools__GeoTagDetails,
        {0},
        &plugin_QgsExifTools_GeoTagDetails
    },
    {
        sipNameNr_GeoTagDetails,
        {18, 255, 0},
        0, 0,
        0, 0,
        1, variables_QgsExifTools_GeoTagDetails,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsExifTools_GeoTagDetails,
    -1,
    -1,
    0,
    0,
    init_type_QgsExifTools_GeoTagDetails,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsExifTools_GeoTagDetails,
    assign_QgsExifTools_GeoTagDetails,
    array_QgsExifTools_GeoTagDetails,
    copy_QgsExifTools_GeoTagDetails,
    release_QgsExifTools_GeoTagDetails,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 20 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsexiftools.sip"
#include "qgsexiftools.h"
#line 3599 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 3603 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 3606 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 20 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsexiftools.sip"
#include "qgsexiftools.h"
#line 46 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsexiftools.sip"
#include "qgsexiftools.h"
#line 3611 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 22 "core/auto_generated/geometry/qgspoint.sip"
#include "qgspoint.h"
#line 3614 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


PyDoc_STRVAR(doc_QgsExifTools_getGeoTag, "getGeoTag(imagePath: str) -> Tuple[QgsPoint, bool]\n"
"Returns the geotagged coordinate stored in the image at ``imagePath``.\n"
"\n"
"If a geotag was found, ``ok`` will be set to ``True``.\n"
"\n"
"If the image contains an elevation tag then the returned point will contain\n"
"the elevation as a z value.\n"
"\n"
".. seealso:: :py:func:`geoTagImage`");

extern "C" {static PyObject *meth_QgsExifTools_getGeoTag(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsExifTools_getGeoTag(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
        bool a1;

        static const char *sipKwdList[] = {
            sipName_imagePath,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J1", sipType_QString,&a0, &a0State))
        {
             ::QgsPoint*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsPoint( ::QgsExifTools::getGeoTag(*a0,a1));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_QgsPoint,NULL);
            return sipBuildResult(0,"(Rb)",sipResObj,a1);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsExifTools, sipName_getGeoTag, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsExifTools_geoTagImage, "geoTagImage(imagePath: str, location: QgsPointXY, details: QgsExifTools.GeoTagDetails = QgsExifTools.GeoTagDetails()) -> bool\n"
"Writes geotags to the image at ``imagePath``.\n"
"\n"
"The ``location`` argument indicates the GPS location to write to the image, as a WGS84 latitude/longitude coordinate.\n"
"\n"
"If desired, extended GPS tags (such as elevation) can be specified via the ``details`` argument.\n"
"\n"
"Returns ``True`` if writing was successful.\n"
"\n"
".. seealso:: :py:func:`getGeoTag`");

extern "C" {static PyObject *meth_QgsExifTools_geoTagImage(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsExifTools_geoTagImage(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QgsPointXY* a1;
        const  ::QgsExifTools::GeoTagDetails& a2def = QgsExifTools::GeoTagDetails();
        const  ::QgsExifTools::GeoTagDetails* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_imagePath,
            sipName_location,
            sipName_details,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J1J9|J9", sipType_QString,&a0, &a0State, sipType_QgsPointXY, &a1, sipType_QgsExifTools_GeoTagDetails, &a2))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes =  ::QgsExifTools::geoTagImage(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsExifTools, sipName_geoTagImage, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsExifTools(void *, int);}
static void release_QgsExifTools(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsExifTools *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsExifTools(void *, SIP_SSIZE_T, void *);}
static void assign_QgsExifTools(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsExifTools *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsExifTools *>(sipSrc);
}


extern "C" {static void *array_QgsExifTools(SIP_SSIZE_T);}
static void *array_QgsExifTools(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsExifTools[sipNrElem];
}


extern "C" {static void *copy_QgsExifTools(const void *, SIP_SSIZE_T);}
static void *copy_QgsExifTools(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsExifTools(reinterpret_cast<const  ::QgsExifTools *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsExifTools(sipSimpleWrapper *);}
static void dealloc_QgsExifTools(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsExifTools(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsExifTools(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsExifTools(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsExifTools *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsExifTools();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsExifTools* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsExifTools, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsExifTools(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsExifTools[] = {
    {SIP_MLNAME_CAST(sipName_geoTagImage), (PyCFunction)meth_QgsExifTools_geoTagImage, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsExifTools_geoTagImage)},
    {SIP_MLNAME_CAST(sipName_getGeoTag), (PyCFunction)meth_QgsExifTools_getGeoTag, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsExifTools_getGeoTag)}
};

PyDoc_STRVAR(doc_QgsExifTools, "\n"
"\n"
"\n"
"Contains utilities for working with EXIF tags in images.\n"
"\n"
".. versionadded:: 3.6");


static pyqt5ClassPluginDef plugin_QgsExifTools = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsExifTools = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsExifTools,
        {0},
        &plugin_QgsExifTools
    },
    {
        sipNameNr_QgsExifTools,
        {0, 0, 1},
        2, methods_QgsExifTools,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsExifTools,
    -1,
    -1,
    0,
    0,
    init_type_QgsExifTools,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsExifTools,
    assign_QgsExifTools,
    array_QgsExifTools,
    copy_QgsExifTools,
    release_QgsExifTools,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 23 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsninecellfilter.sip"
#include "qgsninecellfilter.h"
#line 3903 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 3907 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 3910 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


class sipQgsNineCellFilter : public  ::QgsNineCellFilter
{
public:
    sipQgsNineCellFilter(const  ::QString&,const  ::QString&,const  ::QString&);
    sipQgsNineCellFilter(const  ::QgsNineCellFilter&);
    virtual ~sipQgsNineCellFilter();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    float processNineCellWindow(float*,float*,float*,float*,float*,float*,float*,float*,float*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsNineCellFilter(const sipQgsNineCellFilter &);
    sipQgsNineCellFilter &operator = (const sipQgsNineCellFilter &);

    char sipPyMethods[1];
};

sipQgsNineCellFilter::sipQgsNineCellFilter(const  ::QString& a0,const  ::QString& a1,const  ::QString& a2):  ::QgsNineCellFilter(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNineCellFilter::sipQgsNineCellFilter(const  ::QgsNineCellFilter& a0):  ::QgsNineCellFilter(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNineCellFilter::~sipQgsNineCellFilter()
{
    sipInstanceDestroyed(sipPySelf);
}

float sipQgsNineCellFilter::processNineCellWindow(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QgsNineCellFilter,sipName_processNineCellWindow);

    if (!sipMeth)
        return 0;

    extern float sipVH__analysis_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, float*,float*,float*,float*,float*,float*,float*,float*,float*);

    return sipVH__analysis_1(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4, a5, a6, a7, a8);
}


PyDoc_STRVAR(doc_QgsNineCellFilter_processRaster, "processRaster(self, feedback: QgsFeedback = None) -> int\n"
"Starts the calculation, reads from mInputFile and stores the result in mOutputFile\n"
"\n"
":param feedback: feedback object that receives update and that is checked for cancellation.\n"
"\n"
":return: 0 in case of success");

extern "C" {static PyObject *meth_QgsNineCellFilter_processRaster(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_processRaster(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
         ::QgsNineCellFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsNineCellFilter, &sipCpp, sipType_QgsFeedback, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->processRaster(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_processRaster, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_cellSizeX, "cellSizeX(self) -> float");

extern "C" {static PyObject *meth_QgsNineCellFilter_cellSizeX(PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_cellSizeX(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsNineCellFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsNineCellFilter, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->cellSizeX();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_cellSizeX, doc_QgsNineCellFilter_cellSizeX);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_setCellSizeX, "setCellSizeX(self, size: float)");

extern "C" {static PyObject *meth_QgsNineCellFilter_setCellSizeX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_setCellSizeX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsNineCellFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsNineCellFilter, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setCellSizeX(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_setCellSizeX, doc_QgsNineCellFilter_setCellSizeX);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_cellSizeY, "cellSizeY(self) -> float");

extern "C" {static PyObject *meth_QgsNineCellFilter_cellSizeY(PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_cellSizeY(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsNineCellFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsNineCellFilter, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->cellSizeY();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_cellSizeY, doc_QgsNineCellFilter_cellSizeY);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_setCellSizeY, "setCellSizeY(self, size: float)");

extern "C" {static PyObject *meth_QgsNineCellFilter_setCellSizeY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_setCellSizeY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsNineCellFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsNineCellFilter, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setCellSizeY(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_setCellSizeY, doc_QgsNineCellFilter_setCellSizeY);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_zFactor, "zFactor(self) -> float");

extern "C" {static PyObject *meth_QgsNineCellFilter_zFactor(PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_zFactor(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsNineCellFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsNineCellFilter, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->zFactor();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_zFactor, doc_QgsNineCellFilter_zFactor);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_setZFactor, "setZFactor(self, factor: float)");

extern "C" {static PyObject *meth_QgsNineCellFilter_setZFactor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_setZFactor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsNineCellFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_factor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsNineCellFilter, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setZFactor(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_setZFactor, doc_QgsNineCellFilter_setZFactor);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_inputNodataValue, "inputNodataValue(self) -> float");

extern "C" {static PyObject *meth_QgsNineCellFilter_inputNodataValue(PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_inputNodataValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsNineCellFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsNineCellFilter, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->inputNodataValue();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_inputNodataValue, doc_QgsNineCellFilter_inputNodataValue);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_setInputNodataValue, "setInputNodataValue(self, value: float)");

extern "C" {static PyObject *meth_QgsNineCellFilter_setInputNodataValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_setInputNodataValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsNineCellFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsNineCellFilter, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setInputNodataValue(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_setInputNodataValue, doc_QgsNineCellFilter_setInputNodataValue);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_outputNodataValue, "outputNodataValue(self) -> float");

extern "C" {static PyObject *meth_QgsNineCellFilter_outputNodataValue(PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_outputNodataValue(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsNineCellFilter *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsNineCellFilter, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->outputNodataValue();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_outputNodataValue, doc_QgsNineCellFilter_outputNodataValue);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_setOutputNodataValue, "setOutputNodataValue(self, value: float)");

extern "C" {static PyObject *meth_QgsNineCellFilter_setOutputNodataValue(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_setOutputNodataValue(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsNineCellFilter *sipCpp;

        static const char *sipKwdList[] = {
            sipName_value,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsNineCellFilter, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setOutputNodataValue(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_setOutputNodataValue, doc_QgsNineCellFilter_setOutputNodataValue);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNineCellFilter_processNineCellWindow, "processNineCellWindow(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates output value from nine input values. The input values and the output\n"
"value can be equal to the nodata value if not present or outside of the border.\n"
"Must be implemented by subclasses.\n"
"\n"
"First index of the input cell is the row, second index is the column\n"
"\n"
":param x11: surrounding cell top left\n"
":param x21: surrounding cell central left\n"
":param x31: surrounding cell bottom left\n"
":param x12: surrounding cell top central\n"
":param x22: the central cell for which the value will be calculated\n"
":param x32: surrounding cell bottom central\n"
":param x13: surrounding cell top right\n"
":param x23: surrounding cell central right\n"
":param x33: surrounding cell bottom right\n"
"\n"
":return: the calculated cell value for the central cell x22");

extern "C" {static PyObject *meth_QgsNineCellFilter_processNineCellWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNineCellFilter_processNineCellWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
         ::QgsNineCellFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsNineCellFilter, &sipCpp))
        {
            float sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsNineCellFilter, sipName_processNineCellWindow);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNineCellFilter, sipName_processNineCellWindow, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsNineCellFilter(void *, int);}
static void release_QgsNineCellFilter(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsNineCellFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsNineCellFilter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsNineCellFilter(sipSimpleWrapper *);}
static void dealloc_QgsNineCellFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsNineCellFilter *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsNineCellFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsNineCellFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsNineCellFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsNineCellFilter *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNineCellFilter(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsNineCellFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsNineCellFilter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNineCellFilter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsNineCellFilter[] = {
    {SIP_MLNAME_CAST(sipName_cellSizeX), meth_QgsNineCellFilter_cellSizeX, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_cellSizeX)},
    {SIP_MLNAME_CAST(sipName_cellSizeY), meth_QgsNineCellFilter_cellSizeY, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_cellSizeY)},
    {SIP_MLNAME_CAST(sipName_inputNodataValue), meth_QgsNineCellFilter_inputNodataValue, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_inputNodataValue)},
    {SIP_MLNAME_CAST(sipName_outputNodataValue), meth_QgsNineCellFilter_outputNodataValue, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_outputNodataValue)},
    {SIP_MLNAME_CAST(sipName_processNineCellWindow), (PyCFunction)meth_QgsNineCellFilter_processNineCellWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_processNineCellWindow)},
    {SIP_MLNAME_CAST(sipName_processRaster), (PyCFunction)meth_QgsNineCellFilter_processRaster, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_processRaster)},
    {SIP_MLNAME_CAST(sipName_setCellSizeX), (PyCFunction)meth_QgsNineCellFilter_setCellSizeX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_setCellSizeX)},
    {SIP_MLNAME_CAST(sipName_setCellSizeY), (PyCFunction)meth_QgsNineCellFilter_setCellSizeY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_setCellSizeY)},
    {SIP_MLNAME_CAST(sipName_setInputNodataValue), (PyCFunction)meth_QgsNineCellFilter_setInputNodataValue, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_setInputNodataValue)},
    {SIP_MLNAME_CAST(sipName_setOutputNodataValue), (PyCFunction)meth_QgsNineCellFilter_setOutputNodataValue, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_setOutputNodataValue)},
    {SIP_MLNAME_CAST(sipName_setZFactor), (PyCFunction)meth_QgsNineCellFilter_setZFactor, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_setZFactor)},
    {SIP_MLNAME_CAST(sipName_zFactor), meth_QgsNineCellFilter_zFactor, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsNineCellFilter_zFactor)}
};

PyDoc_STRVAR(doc_QgsNineCellFilter, "QgsNineCellFilter(inputFile: str, outputFile: str, outputFormat: str)\n"
"Constructor that takes input file, output file and output format (GDAL string)\n"
"\n"
"QgsNineCellFilter(QgsNineCellFilter)\n"
"\n"
"Base class for raster analysis methods that work with a 3x3 cell filter and calculate the value of each cell based on\n"
"the cell value and the eight neighbour cells. Common examples are slope and aspect calculation in DEMs. Subclasses only implement\n"
"the method that calculates the new value from the nine values. Everything else (reading file, writing file) is done by this subclass*");


static pyqt5ClassPluginDef plugin_QgsNineCellFilter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsNineCellFilter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsNineCellFilter,
        {0},
        &plugin_QgsNineCellFilter
    },
    {
        sipNameNr_QgsNineCellFilter,
        {0, 0, 1},
        12, methods_QgsNineCellFilter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsNineCellFilter,
    -1,
    -1,
    0,
    0,
    init_type_QgsNineCellFilter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsNineCellFilter,
    0,
    0,
    0,
    release_QgsNineCellFilter,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsaspectfilter.sip"
#include "qgsaspectfilter.h"
#line 4701 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 4705 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 4708 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


class sipQgsAspectFilter : public  ::QgsAspectFilter
{
public:
    sipQgsAspectFilter(const  ::QString&,const  ::QString&,const  ::QString&);
    sipQgsAspectFilter(const  ::QgsAspectFilter&);
    virtual ~sipQgsAspectFilter();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    float sipProtect_calcFirstDerX(float*,float*,float*,float*,float*,float*,float*,float*,float*);
    float sipProtect_calcFirstDerY(float*,float*,float*,float*,float*,float*,float*,float*,float*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    float processNineCellWindow(float*,float*,float*,float*,float*,float*,float*,float*,float*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsAspectFilter(const sipQgsAspectFilter &);
    sipQgsAspectFilter &operator = (const sipQgsAspectFilter &);

    char sipPyMethods[1];
};

sipQgsAspectFilter::sipQgsAspectFilter(const  ::QString& a0,const  ::QString& a1,const  ::QString& a2):  ::QgsAspectFilter(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsAspectFilter::sipQgsAspectFilter(const  ::QgsAspectFilter& a0):  ::QgsAspectFilter(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsAspectFilter::~sipQgsAspectFilter()
{
    sipInstanceDestroyed(sipPySelf);
}

float sipQgsAspectFilter::processNineCellWindow(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_processNineCellWindow);

    if (!sipMeth)
        return  ::QgsAspectFilter::processNineCellWindow(a0,a1,a2,a3,a4,a5,a6,a7,a8);

    extern float sipVH__analysis_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, float*,float*,float*,float*,float*,float*,float*,float*,float*);

    return sipVH__analysis_1(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

float sipQgsAspectFilter::sipProtect_calcFirstDerX(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerX(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}

float sipQgsAspectFilter::sipProtect_calcFirstDerY(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerY(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}


PyDoc_STRVAR(doc_QgsAspectFilter_calcFirstDerX, "calcFirstDerX(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in x-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsAspectFilter_calcFirstDerX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAspectFilter_calcFirstDerX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsAspectFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsAspectFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerX(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAspectFilter, sipName_calcFirstDerX, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAspectFilter_calcFirstDerY, "calcFirstDerY(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in y-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsAspectFilter_calcFirstDerY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAspectFilter_calcFirstDerY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsAspectFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsAspectFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerY(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAspectFilter, sipName_calcFirstDerY, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAspectFilter_processNineCellWindow, "processNineCellWindow(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates output value from nine input values. The input values and the output value can be equal to the\n"
"nodata value if not present or outside of the border. Must be implemented by subclasses*");

extern "C" {static PyObject *meth_QgsAspectFilter_processNineCellWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAspectFilter_processNineCellWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
         ::QgsAspectFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsAspectFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsAspectFilter::processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8) : sipCpp->processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAspectFilter, sipName_processNineCellWindow, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsAspectFilter(void *, const sipTypeDef *);}
static void *cast_QgsAspectFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsAspectFilter *sipCpp = reinterpret_cast< ::QgsAspectFilter *>(sipCppV);

    if (targetType == sipType_QgsDerivativeFilter)
        return static_cast< ::QgsDerivativeFilter *>(sipCpp);

    if (targetType == sipType_QgsNineCellFilter)
        return static_cast< ::QgsNineCellFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsAspectFilter(void *, int);}
static void release_QgsAspectFilter(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsAspectFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsAspectFilter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsAspectFilter(sipSimpleWrapper *);}
static void dealloc_QgsAspectFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsAspectFilter *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsAspectFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsAspectFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsAspectFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsAspectFilter *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsAspectFilter(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsAspectFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsAspectFilter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsAspectFilter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsAspectFilter[] = {{17, 255, 1}};


static PyMethodDef methods_QgsAspectFilter[] = {
    {SIP_MLNAME_CAST(sipName_calcFirstDerX), (PyCFunction)meth_QgsAspectFilter_calcFirstDerX, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_calcFirstDerY), (PyCFunction)meth_QgsAspectFilter_calcFirstDerY, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_processNineCellWindow), (PyCFunction)meth_QgsAspectFilter_processNineCellWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAspectFilter_processNineCellWindow)}
};

PyDoc_STRVAR(doc_QgsAspectFilter, "\n"
"\n"
"\n"
"Calculates aspect values in a window of 3x3 cells based on first order derivatives in x- and y- directions. Direction is clockwise starting from north*");


static pyqt5ClassPluginDef plugin_QgsAspectFilter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsAspectFilter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsAspectFilter,
        {0},
        &plugin_QgsAspectFilter
    },
    {
        sipNameNr_QgsAspectFilter,
        {0, 0, 1},
        3, methods_QgsAspectFilter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsAspectFilter,
    -1,
    -1,
    supers_QgsAspectFilter,
    0,
    init_type_QgsAspectFilter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsAspectFilter,
    0,
    0,
    0,
    release_QgsAspectFilter,
    cast_QgsAspectFilter,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsderivativefilter.sip"
#include "qgsderivativefilter.h"
#line 5130 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 5134 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 5137 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


class sipQgsDerivativeFilter : public  ::QgsDerivativeFilter
{
public:
    sipQgsDerivativeFilter(const  ::QString&,const  ::QString&,const  ::QString&);
    sipQgsDerivativeFilter(const  ::QgsDerivativeFilter&);
    virtual ~sipQgsDerivativeFilter();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    float sipProtect_calcFirstDerX(float*,float*,float*,float*,float*,float*,float*,float*,float*);
    float sipProtect_calcFirstDerY(float*,float*,float*,float*,float*,float*,float*,float*,float*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    float processNineCellWindow(float*,float*,float*,float*,float*,float*,float*,float*,float*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsDerivativeFilter(const sipQgsDerivativeFilter &);
    sipQgsDerivativeFilter &operator = (const sipQgsDerivativeFilter &);

    char sipPyMethods[1];
};

sipQgsDerivativeFilter::sipQgsDerivativeFilter(const  ::QString& a0,const  ::QString& a1,const  ::QString& a2):  ::QgsDerivativeFilter(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsDerivativeFilter::sipQgsDerivativeFilter(const  ::QgsDerivativeFilter& a0):  ::QgsDerivativeFilter(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsDerivativeFilter::~sipQgsDerivativeFilter()
{
    sipInstanceDestroyed(sipPySelf);
}

float sipQgsDerivativeFilter::processNineCellWindow(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_QgsDerivativeFilter,sipName_processNineCellWindow);

    if (!sipMeth)
        return 0;

    extern float sipVH__analysis_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, float*,float*,float*,float*,float*,float*,float*,float*,float*);

    return sipVH__analysis_1(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

float sipQgsDerivativeFilter::sipProtect_calcFirstDerX(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerX(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}

float sipQgsDerivativeFilter::sipProtect_calcFirstDerY(float*a0,float*a1,float*a2,float*a3,float*a4,float*a5,float*a6,float*a7,float*a8)
{
    return  ::QgsDerivativeFilter::calcFirstDerY(a0,a1,a2,a3,a4,a5,a6,a7,a8);
}


PyDoc_STRVAR(doc_QgsDerivativeFilter_processNineCellWindow, "processNineCellWindow(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]");

extern "C" {static PyObject *meth_QgsDerivativeFilter_processNineCellWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsDerivativeFilter_processNineCellWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
         ::QgsDerivativeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsDerivativeFilter, &sipCpp))
        {
            float sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsDerivativeFilter, sipName_processNineCellWindow);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->processNineCellWindow(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsDerivativeFilter, sipName_processNineCellWindow, doc_QgsDerivativeFilter_processNineCellWindow);

    return NULL;
}


PyDoc_STRVAR(doc_QgsDerivativeFilter_calcFirstDerX, "calcFirstDerX(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in x-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsDerivativeFilter_calcFirstDerX(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsDerivativeFilter_calcFirstDerX(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsDerivativeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsDerivativeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerX(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsDerivativeFilter, sipName_calcFirstDerX, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsDerivativeFilter_calcFirstDerY, "calcFirstDerY(self) -> Tuple[float, float, float, float, float, float, float, float, float, float]\n"
"Calculates the first order derivative in y-direction according to Horn (1981)");

extern "C" {static PyObject *meth_QgsDerivativeFilter_calcFirstDerY(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsDerivativeFilter_calcFirstDerY(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        float a0;
        float a1;
        float a2;
        float a3;
        float a4;
        float a5;
        float a6;
        float a7;
        float a8;
        sipQgsDerivativeFilter *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsDerivativeFilter, &sipCpp))
        {
            float sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_calcFirstDerY(&a0,&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(ffffffffff)",sipRes,a0,a1,a2,a3,a4,a5,a6,a7,a8);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsDerivativeFilter, sipName_calcFirstDerY, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsDerivativeFilter(void *, const sipTypeDef *);}
static void *cast_QgsDerivativeFilter(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsDerivativeFilter *sipCpp = reinterpret_cast< ::QgsDerivativeFilter *>(sipCppV);

    if (targetType == sipType_QgsNineCellFilter)
        return static_cast< ::QgsNineCellFilter *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsDerivativeFilter(void *, int);}
static void release_QgsDerivativeFilter(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsDerivativeFilter *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsDerivativeFilter *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsDerivativeFilter(sipSimpleWrapper *);}
static void dealloc_QgsDerivativeFilter(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsDerivativeFilter *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsDerivativeFilter(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsDerivativeFilter(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsDerivativeFilter(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsDerivativeFilter *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;
        const  ::QString* a2;
        int a2State = 0;

        static const char *sipKwdList[] = {
            sipName_inputFile,
            sipName_outputFile,
            sipName_outputFormat,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QString,&a2, &a2State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsDerivativeFilter(*a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsDerivativeFilter* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsDerivativeFilter, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsDerivativeFilter(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsDerivativeFilter[] = {{70, 255, 1}};


static PyMethodDef methods_QgsDerivativeFilter[] = {
    {SIP_MLNAME_CAST(sipName_calcFirstDerX), (PyCFunction)meth_QgsDerivativeFilter_calcFirstDerX, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsDerivativeFilter_calcFirstDerX)},
    {SIP_MLNAME_CAST(sipName_calcFirstDerY), (PyCFunction)meth_QgsDerivativeFilter_calcFirstDerY, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsDerivativeFilter_calcFirstDerY)},
    {SIP_MLNAME_CAST(sipName_processNineCellWindow), (PyCFunction)meth_QgsDerivativeFilter_processNineCellWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsDerivativeFilter_processNineCellWindow)}
};

PyDoc_STRVAR(doc_QgsDerivativeFilter, "\n"
"\n"
"\n"
"Adds the ability to calculate derivatives in x- and y-directions. Needs to be subclassed (e.g. for slope and aspect)*");


static pyqt5ClassPluginDef plugin_QgsDerivativeFilter = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsDerivativeFilter = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsDerivativeFilter,
        {0},
        &plugin_QgsDerivativeFilter
    },
    {
        sipNameNr_QgsDerivativeFilter,
        {0, 0, 1},
        3, methods_QgsDerivativeFilter,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsDerivativeFilter,
    -1,
    -1,
    supers_QgsDerivativeFilter,
    0,
    init_type_QgsDerivativeFilter,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsDerivativeFilter,
    0,
    0,
    0,
    release_QgsDerivativeFilter,
    cast_QgsDerivativeFilter,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 5561 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"



class sipQgsAlignRaster_ProgressHandler : public  ::QgsAlignRaster::ProgressHandler
{
public:
    sipQgsAlignRaster_ProgressHandler();
    sipQgsAlignRaster_ProgressHandler(const  ::QgsAlignRaster::ProgressHandler&);
    virtual ~sipQgsAlignRaster_ProgressHandler();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool progress(double);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsAlignRaster_ProgressHandler(const sipQgsAlignRaster_ProgressHandler &);
    sipQgsAlignRaster_ProgressHandler &operator = (const sipQgsAlignRaster_ProgressHandler &);

    char sipPyMethods[1];
};

sipQgsAlignRaster_ProgressHandler::sipQgsAlignRaster_ProgressHandler():  ::QgsAlignRaster::ProgressHandler(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsAlignRaster_ProgressHandler::sipQgsAlignRaster_ProgressHandler(const  ::QgsAlignRaster::ProgressHandler& a0):  ::QgsAlignRaster::ProgressHandler(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsAlignRaster_ProgressHandler::~sipQgsAlignRaster_ProgressHandler()
{
    sipInstanceDestroyed(sipPySelf);
}

bool sipQgsAlignRaster_ProgressHandler::progress(double a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_ProgressHandler,sipName_progress);

    if (!sipMeth)
        return 0;

    extern bool sipVH__analysis_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, double);

    return sipVH__analysis_0(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QgsAlignRaster_ProgressHandler_progress, "progress(self, complete: float) -> bool\n"
"Method to be overridden for progress reporting.\n"
"\n"
":param complete: Overall progress of the alignment operation\n"
"\n"
":return: ``False`` if the execution should be canceled, ``True`` otherwise");

extern "C" {static PyObject *meth_QgsAlignRaster_ProgressHandler_progress(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_ProgressHandler_progress(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        double a0;
         ::QgsAlignRaster::ProgressHandler *sipCpp;

        static const char *sipKwdList[] = {
            sipName_complete,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsAlignRaster_ProgressHandler, &sipCpp, &a0))
        {
            bool sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ProgressHandler, sipName_progress);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->progress(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ProgressHandler, sipName_progress, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsAlignRaster_ProgressHandler(void *, int);}
static void release_QgsAlignRaster_ProgressHandler(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsAlignRaster_ProgressHandler *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsAlignRaster::ProgressHandler *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsAlignRaster_ProgressHandler(sipSimpleWrapper *);}
static void dealloc_QgsAlignRaster_ProgressHandler(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsAlignRaster_ProgressHandler *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsAlignRaster_ProgressHandler(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsAlignRaster_ProgressHandler(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsAlignRaster_ProgressHandler(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsAlignRaster_ProgressHandler *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsAlignRaster_ProgressHandler();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsAlignRaster::ProgressHandler* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsAlignRaster_ProgressHandler, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsAlignRaster_ProgressHandler(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsAlignRaster_ProgressHandler[] = {
    {SIP_MLNAME_CAST(sipName_progress), (PyCFunction)meth_QgsAlignRaster_ProgressHandler_progress, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_ProgressHandler_progress)}
};

PyDoc_STRVAR(doc_QgsAlignRaster_ProgressHandler, "\1QgsAlignRaster.ProgressHandler()\n"
"QgsAlignRaster.ProgressHandler(QgsAlignRaster.ProgressHandler)");


static pyqt5ClassPluginDef plugin_QgsAlignRaster_ProgressHandler = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsAlignRaster_ProgressHandler = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsAlignRaster__ProgressHandler,
        {0},
        &plugin_QgsAlignRaster_ProgressHandler
    },
    {
        sipNameNr_ProgressHandler,
        {10, 255, 0},
        1, methods_QgsAlignRaster_ProgressHandler,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsAlignRaster_ProgressHandler,
    -1,
    -1,
    0,
    0,
    init_type_QgsAlignRaster_ProgressHandler,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsAlignRaster_ProgressHandler,
    0,
    0,
    0,
    release_QgsAlignRaster_ProgressHandler,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 5832 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 5836 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 5840 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


/* Call the instance's destructor. */
extern "C" {static void release_QgsAlignRaster_Item(void *, int);}
static void release_QgsAlignRaster_Item(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsAlignRaster::Item *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsAlignRaster_Item(sipSimpleWrapper *);}
static void dealloc_QgsAlignRaster_Item(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsAlignRaster_Item(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsAlignRaster_Item(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsAlignRaster_Item(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsAlignRaster::Item *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString* a1;
        int a1State = 0;

        static const char *sipKwdList[] = {
            sipName_input,
            sipName_output,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J1", sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsAlignRaster::Item(*a0,*a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);

            return sipCpp;
        }
    }

    {
        const  ::QgsAlignRaster::Item* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsAlignRaster_Item, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsAlignRaster::Item(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_QgsAlignRaster_Item_inputFilename(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsAlignRaster_Item_inputFilename(void *sipSelf, PyObject *, PyObject *)
{
     ::QString*sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = &sipCpp->inputFilename;

    return sipConvertFromType(sipVal, sipType_QString, NULL);
}


extern "C" {static int varset_QgsAlignRaster_Item_inputFilename(void *, PyObject *, PyObject *);}
static int varset_QgsAlignRaster_Item_inputFilename(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QString*sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QString *>(sipForceConvertToType(sipPy,sipType_QString,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->inputFilename = *sipVal;

    sipReleaseType(sipVal, sipType_QString, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_QgsAlignRaster_Item_outputFilename(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsAlignRaster_Item_outputFilename(void *sipSelf, PyObject *, PyObject *)
{
     ::QString*sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = &sipCpp->outputFilename;

    return sipConvertFromType(sipVal, sipType_QString, NULL);
}


extern "C" {static int varset_QgsAlignRaster_Item_outputFilename(void *, PyObject *, PyObject *);}
static int varset_QgsAlignRaster_Item_outputFilename(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QString*sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    int sipValState;
    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::QString *>(sipForceConvertToType(sipPy,sipType_QString,NULL,SIP_NOT_NONE,&sipValState,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->outputFilename = *sipVal;

    sipReleaseType(sipVal, sipType_QString, sipValState);

    return 0;
}


extern "C" {static PyObject *varget_QgsAlignRaster_Item_resampleMethod(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsAlignRaster_Item_resampleMethod(void *sipSelf, PyObject *, PyObject *)
{
     ::QgsAlignRaster::ResampleAlg sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = sipCpp->resampleMethod;

    return sipConvertFromEnum(static_cast<int>(sipVal), sipType_QgsAlignRaster_ResampleAlg);
}


extern "C" {static int varset_QgsAlignRaster_Item_resampleMethod(void *, PyObject *, PyObject *);}
static int varset_QgsAlignRaster_Item_resampleMethod(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::QgsAlignRaster::ResampleAlg sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = ( ::QgsAlignRaster::ResampleAlg)sipConvertToEnum(sipPy, sipType_QgsAlignRaster_ResampleAlg);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->resampleMethod = sipVal;

    return 0;
}


extern "C" {static PyObject *varget_QgsAlignRaster_Item_rescaleValues(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsAlignRaster_Item_rescaleValues(void *sipSelf, PyObject *, PyObject *)
{
    bool sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = sipCpp->rescaleValues;

    return PyBool_FromLong(sipVal);
}


extern "C" {static int varset_QgsAlignRaster_Item_rescaleValues(void *, PyObject *, PyObject *);}
static int varset_QgsAlignRaster_Item_rescaleValues(void *sipSelf, PyObject *sipPy, PyObject *)
{
    int sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = sipConvertToBool(sipPy);

    if (sipVal < 0)
        return -1;

    sipCpp->rescaleValues = static_cast<bool>(sipVal);

    return 0;
}


extern "C" {static PyObject *varget_QgsAlignRaster_Item_srcCellSizeInDestCRS(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsAlignRaster_Item_srcCellSizeInDestCRS(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = sipCpp->srcCellSizeInDestCRS;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static int varset_QgsAlignRaster_Item_srcCellSizeInDestCRS(void *, PyObject *, PyObject *);}
static int varset_QgsAlignRaster_Item_srcCellSizeInDestCRS(void *sipSelf, PyObject *sipPy, PyObject *)
{
    double sipVal;
     ::QgsAlignRaster::Item *sipCpp = reinterpret_cast< ::QgsAlignRaster::Item *>(sipSelf);

    sipVal = PyFloat_AsDouble(sipPy);

    if (PyErr_Occurred() != NULL)
        return -1;

    sipCpp->srcCellSizeInDestCRS = sipVal;

    return 0;
}

sipVariableDef variables_QgsAlignRaster_Item[] = {
    {InstanceVariable, sipName_inputFilename, (PyMethodDef *)varget_QgsAlignRaster_Item_inputFilename, (PyMethodDef *)varset_QgsAlignRaster_Item_inputFilename, NULL, NULL},
    {InstanceVariable, sipName_outputFilename, (PyMethodDef *)varget_QgsAlignRaster_Item_outputFilename, (PyMethodDef *)varset_QgsAlignRaster_Item_outputFilename, NULL, NULL},
    {InstanceVariable, sipName_resampleMethod, (PyMethodDef *)varget_QgsAlignRaster_Item_resampleMethod, (PyMethodDef *)varset_QgsAlignRaster_Item_resampleMethod, NULL, NULL},
    {InstanceVariable, sipName_rescaleValues, (PyMethodDef *)varget_QgsAlignRaster_Item_rescaleValues, (PyMethodDef *)varset_QgsAlignRaster_Item_rescaleValues, NULL, NULL},
    {InstanceVariable, sipName_srcCellSizeInDestCRS, (PyMethodDef *)varget_QgsAlignRaster_Item_srcCellSizeInDestCRS, (PyMethodDef *)varset_QgsAlignRaster_Item_srcCellSizeInDestCRS, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsAlignRaster_Item, "\1QgsAlignRaster.Item(input: str, output: str)\n"
"QgsAlignRaster.Item(QgsAlignRaster.Item)");


static pyqt5ClassPluginDef plugin_QgsAlignRaster_Item = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsAlignRaster_Item = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsAlignRaster__Item,
        {0},
        &plugin_QgsAlignRaster_Item
    },
    {
        sipNameNr_Item,
        {10, 255, 0},
        0, 0,
        0, 0,
        5, variables_QgsAlignRaster_Item,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsAlignRaster_Item,
    -1,
    -1,
    0,
    0,
    init_type_QgsAlignRaster_Item,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsAlignRaster_Item,
    0,
    0,
    0,
    release_QgsAlignRaster_Item,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 6160 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 6164 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 95 "/usr/share/sip/PyQt5/QtCore/qpoint.sip"
#include <qpoint.h>
#line 6167 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 26 "core/auto_generated/geometry/qgsrectangle.sip"
#include "qgsrectangle.h"
#line 6170 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 97 "/usr/share/sip/PyQt5/QtCore/qsize.sip"
#include <qsize.h>
#line 6173 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qsize.sip"
#include <qsize.h>
#line 6176 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_isValid, "isValid(self) -> bool\n"
"Check whether the given path is a valid raster");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_isValid(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_isValid(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->isValid();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_isValid, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_crs, "crs(self) -> str\n"
"Returns the CRS in WKT format");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_crs(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_crs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->crs());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_crs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_rasterSize, "rasterSize(self) -> QSize\n"
"Returns the size of the raster grid in pixels");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_rasterSize(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_rasterSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
             ::QSize*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QSize(sipCpp->rasterSize());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_rasterSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_bandCount, "bandCount(self) -> int\n"
"Returns the number of raster bands in the file");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_bandCount(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_bandCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->bandCount();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_bandCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_cellSize, "cellSize(self) -> QSizeF\n"
"Returns the cell size in map units");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_cellSize(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_cellSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
             ::QSizeF*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QSizeF(sipCpp->cellSize());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QSizeF,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_cellSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_gridOffset, "gridOffset(self) -> QPointF\n"
"Returns the grid offset");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_gridOffset(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_gridOffset(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
             ::QPointF*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QPointF(sipCpp->gridOffset());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QPointF,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_gridOffset, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_extent, "extent(self) -> QgsRectangle\n"
"Returns the extent of the raster");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_extent(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_extent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
             ::QgsRectangle*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsRectangle(sipCpp->extent());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsRectangle,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_extent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_origin, "origin(self) -> QPointF\n"
"Returns the origin of the raster");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_origin(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_origin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
             ::QPointF*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QPointF(sipCpp->origin());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QPointF,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_origin, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_dump, "dump(self)\n"
"Write contents of the object to standard error stream - for debugging");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_dump(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_dump(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->dump();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_dump, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo_identify, "identify(self, mx: float, my: float) -> float\n"
"Gets raster value at the given coordinates (from the first band)");

extern "C" {static PyObject *meth_QgsAlignRaster_RasterInfo_identify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_RasterInfo_identify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
         ::QgsAlignRaster::RasterInfo *sipCpp;

        static const char *sipKwdList[] = {
            sipName_mx,
            sipName_my,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd", &sipSelf, sipType_QgsAlignRaster_RasterInfo, &sipCpp, &a0, &a1))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->identify(a0,a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RasterInfo, sipName_identify, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsAlignRaster_RasterInfo(void *, int);}
static void release_QgsAlignRaster_RasterInfo(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsAlignRaster::RasterInfo *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsAlignRaster_RasterInfo(sipSimpleWrapper *);}
static void dealloc_QgsAlignRaster_RasterInfo(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsAlignRaster_RasterInfo(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsAlignRaster_RasterInfo(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsAlignRaster_RasterInfo(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsAlignRaster::RasterInfo *sipCpp = 0;

    {
        const  ::QString* a0;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_layerpath,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1", sipType_QString,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsAlignRaster::RasterInfo(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsAlignRaster_RasterInfo[] = {
    {SIP_MLNAME_CAST(sipName_bandCount), meth_QgsAlignRaster_RasterInfo_bandCount, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_bandCount)},
    {SIP_MLNAME_CAST(sipName_cellSize), meth_QgsAlignRaster_RasterInfo_cellSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_cellSize)},
    {SIP_MLNAME_CAST(sipName_crs), meth_QgsAlignRaster_RasterInfo_crs, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_crs)},
    {SIP_MLNAME_CAST(sipName_dump), meth_QgsAlignRaster_RasterInfo_dump, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_dump)},
    {SIP_MLNAME_CAST(sipName_extent), meth_QgsAlignRaster_RasterInfo_extent, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_extent)},
    {SIP_MLNAME_CAST(sipName_gridOffset), meth_QgsAlignRaster_RasterInfo_gridOffset, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_gridOffset)},
    {SIP_MLNAME_CAST(sipName_identify), (PyCFunction)meth_QgsAlignRaster_RasterInfo_identify, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_identify)},
    {SIP_MLNAME_CAST(sipName_isValid), meth_QgsAlignRaster_RasterInfo_isValid, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_isValid)},
    {SIP_MLNAME_CAST(sipName_origin), meth_QgsAlignRaster_RasterInfo_origin, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_origin)},
    {SIP_MLNAME_CAST(sipName_rasterSize), meth_QgsAlignRaster_RasterInfo_rasterSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_RasterInfo_rasterSize)}
};

PyDoc_STRVAR(doc_QgsAlignRaster_RasterInfo, "QgsAlignRaster.RasterInfo(layerpath: str)\n"
"Construct raster info with a path to a raster file");


static pyqt5ClassPluginDef plugin_QgsAlignRaster_RasterInfo = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsAlignRaster_RasterInfo = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsAlignRaster__RasterInfo,
        {0},
        &plugin_QgsAlignRaster_RasterInfo
    },
    {
        sipNameNr_RasterInfo,
        {10, 255, 0},
        10, methods_QgsAlignRaster_RasterInfo,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsAlignRaster_RasterInfo,
    -1,
    -1,
    0,
    0,
    init_type_QgsAlignRaster_RasterInfo,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsAlignRaster_RasterInfo,
    0,
    0,
    0,
    release_QgsAlignRaster_RasterInfo,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 6734 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 6739 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 6742 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 97 "/usr/share/sip/PyQt5/QtCore/qsize.sip"
#include <qsize.h>
#line 6745 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 95 "/usr/share/sip/PyQt5/QtCore/qpoint.sip"
#include <qpoint.h>
#line 6748 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 26 "core/auto_generated/geometry/qgsrectangle.sip"
#include "qgsrectangle.h"
#line 6751 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 6755 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qsize.sip"
#include <qsize.h>
#line 6758 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 6761 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"
#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/raster/qgsalignraster.sip"
#include "qgsalignraster.h"
#include <gdal_version.h>
#line 6765 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


class sipQgsAlignRaster : public  ::QgsAlignRaster
{
public:
    sipQgsAlignRaster();
    sipQgsAlignRaster(const  ::QgsAlignRaster&);
    ~sipQgsAlignRaster();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    bool sipProtect_createAndWarp(const  ::QgsAlignRaster::Item&);
    static bool sipProtect_suggestedWarpOutput(const  ::QgsAlignRaster::RasterInfo&,const  ::QString&, ::QSizeF*, ::QPointF*, ::QgsRectangle*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsAlignRaster(const sipQgsAlignRaster &);
    sipQgsAlignRaster &operator = (const sipQgsAlignRaster &);
};

sipQgsAlignRaster::sipQgsAlignRaster():  ::QgsAlignRaster(), sipPySelf(0)
{
}

sipQgsAlignRaster::sipQgsAlignRaster(const  ::QgsAlignRaster& a0):  ::QgsAlignRaster(a0), sipPySelf(0)
{
}

sipQgsAlignRaster::~sipQgsAlignRaster()
{
    sipInstanceDestroyed(sipPySelf);
}

bool sipQgsAlignRaster::sipProtect_createAndWarp(const  ::QgsAlignRaster::Item& a0)
{
    return  ::QgsAlignRaster::createAndWarp(a0);
}

bool sipQgsAlignRaster::sipProtect_suggestedWarpOutput(const  ::QgsAlignRaster::RasterInfo& a0,const  ::QString& a1, ::QSizeF*a2, ::QPointF*a3, ::QgsRectangle*a4)
{
    return  ::QgsAlignRaster::suggestedWarpOutput(a0,a1,a2,a3,a4);
}


PyDoc_STRVAR(doc_QgsAlignRaster_setProgressHandler, "setProgressHandler(self, progressHandler: QgsAlignRaster.ProgressHandler)\n"
"Assign a progress handler instance. Does not take ownership. ``None`` can be passed.");

extern "C" {static PyObject *meth_QgsAlignRaster_setProgressHandler(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_setProgressHandler(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsAlignRaster::ProgressHandler* a0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_progressHandler,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QgsAlignRaster_ProgressHandler, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setProgressHandler(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_setProgressHandler, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_progressHandler, "progressHandler(self) -> QgsAlignRaster.ProgressHandler\n"
"Gets associated progress handler. May be ``None`` (default)");

extern "C" {static PyObject *meth_QgsAlignRaster_progressHandler(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_progressHandler(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QgsAlignRaster::ProgressHandler*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->progressHandler();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QgsAlignRaster_ProgressHandler,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_progressHandler, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_setRasters, "setRasters(self, list: object)\n"
"Sets list of rasters that will be aligned");

extern "C" {static PyObject *meth_QgsAlignRaster_setRasters(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_setRasters(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::List* a0;
        int a0State = 0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_list,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QList_0100QgsAlignRaster_Item,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setRasters(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QgsAlignRaster::List *>(a0),sipType_QList_0100QgsAlignRaster_Item,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QgsAlignRaster::List *>(a0),sipType_QList_0100QgsAlignRaster_Item,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_setRasters, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_rasters, "rasters(self) -> object\n"
"Gets list of rasters that will be aligned");

extern "C" {static PyObject *meth_QgsAlignRaster_rasters(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_rasters(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QgsAlignRaster::List*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsAlignRaster::List(sipCpp->rasters());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0100QgsAlignRaster_Item,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_rasters, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_setGridOffset, "setGridOffset(self, offset: Union[QPointF, QPoint])");

extern "C" {static PyObject *meth_QgsAlignRaster_setGridOffset(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_setGridOffset(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QPointF* a0;
        int a0State = 0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_offset,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QPointF, &a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setGridOffset(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(a0,sipType_QPointF,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_QPointF,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_setGridOffset, doc_QgsAlignRaster_setGridOffset);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_gridOffset, "gridOffset(self) -> QPointF");

extern "C" {static PyObject *meth_QgsAlignRaster_gridOffset(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_gridOffset(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QPointF*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QPointF(sipCpp->gridOffset());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QPointF,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_gridOffset, doc_QgsAlignRaster_gridOffset);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_setCellSize, "setCellSize(self, x: float, y: float)\n"
"Sets output cell size\n"
"\n"
"setCellSize(self, size: QSizeF)\n"
"Sets output cell size");

extern "C" {static PyObject *meth_QgsAlignRaster_setCellSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_setCellSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd", &sipSelf, sipType_QgsAlignRaster, &sipCpp, &a0, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setCellSize(a0,a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::QSizeF* a0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QSizeF, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setCellSize(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_setCellSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_cellSize, "cellSize(self) -> QSizeF\n"
"Gets output cell size");

extern "C" {static PyObject *meth_QgsAlignRaster_cellSize(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_cellSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QSizeF*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QSizeF(sipCpp->cellSize());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QSizeF,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_cellSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_setDestinationCrs, "setDestinationCrs(self, crsWkt: str)\n"
"Sets the output CRS in WKT format");

extern "C" {static PyObject *meth_QgsAlignRaster_setDestinationCrs(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_setDestinationCrs(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_crsWkt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QString,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setDestinationCrs(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_setDestinationCrs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_destinationCrs, "destinationCrs(self) -> str\n"
"Gets the output CRS in WKT format");

extern "C" {static PyObject *meth_QgsAlignRaster_destinationCrs(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_destinationCrs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->destinationCrs());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_destinationCrs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_setClipExtent, "setClipExtent(self, xmin: float, ymin: float, xmax: float, ymax: float)\n"
"Configure clipping extent (region of interest).\n"
"No extra clipping is done if the rectangle is null\n"
"\n"
"setClipExtent(self, extent: QgsRectangle)\n"
"Configure clipping extent (region of interest).\n"
"No extra clipping is done if the rectangle is null");

extern "C" {static PyObject *meth_QgsAlignRaster_setClipExtent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_setClipExtent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        double a2;
        double a3;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_xmin,
            sipName_ymin,
            sipName_xmax,
            sipName_ymax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdddd", &sipSelf, sipType_QgsAlignRaster, &sipCpp, &a0, &a1, &a2, &a3))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setClipExtent(a0,a1,a2,a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::QgsRectangle* a0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_extent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QgsRectangle, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setClipExtent(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_setClipExtent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_clipExtent, "clipExtent(self) -> QgsRectangle\n"
"Gets clipping extent (region of interest).\n"
"No extra clipping is done if the rectangle is null");

extern "C" {static PyObject *meth_QgsAlignRaster_clipExtent(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_clipExtent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QgsRectangle*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsRectangle(sipCpp->clipExtent());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsRectangle,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_clipExtent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_setParametersFromRaster, "setParametersFromRaster(self, rasterInfo: QgsAlignRaster.RasterInfo, customCRSWkt: str = '', customCellSize: QSizeF = QSizeF(), customGridOffset: Union[QPointF, QPoint] = QPointF(-1,-1)) -> bool\n"
"Set destination CRS, cell size and grid offset from a raster file.\n"
"The user may provide custom values for some of the parameters - in such case\n"
"only the remaining parameters are calculated.\n"
"\n"
"If default CRS is used, the parameters are set according to the raster file's geo-transform.\n"
"If a custom CRS is provided, suggested reprojection is calculated first (using GDAL) in order\n"
"to determine suitable defaults for cell size and grid offset.\n"
"\n"
":return: ``True`` on success (may fail if it is not possible to reproject raster to given CRS)\n"
"\n"
"setParametersFromRaster(self, filename: str, customCRSWkt: str = '', customCellSize: QSizeF = QSizeF(), customGridOffset: Union[QPointF, QPoint] = QPointF(-1,-1)) -> bool\n"
"Overridden variant for convenience, taking filename instead RasterInfo object.\n"
"See the other variant for details.");

extern "C" {static PyObject *meth_QgsAlignRaster_setParametersFromRaster(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_setParametersFromRaster(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo* a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
         ::QSizeF a2def = QSizeF();
         ::QSizeF* a2 = &a2def;
         ::QPointF a3def = QPointF(-1,-1);
         ::QPointF* a3 = &a3def;
        int a3State = 0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rasterInfo,
            sipName_customCRSWkt,
            sipName_customCellSize,
            sipName_customGridOffset,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9|J1J9J1", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QgsAlignRaster_RasterInfo, &a0, sipType_QString,&a1, &a1State, sipType_QSizeF, &a2, sipType_QPointF, &a3, &a3State))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->setParametersFromRaster(*a0,*a1,*a2,*a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a3,sipType_QPointF,a3State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a3,sipType_QPointF,a3State);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::QString* a0;
        int a0State = 0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
         ::QSizeF a2def = QSizeF();
         ::QSizeF* a2 = &a2def;
         ::QPointF a3def = QPointF(-1,-1);
         ::QPointF* a3 = &a3def;
        int a3State = 0;
         ::QgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_filename,
            sipName_customCRSWkt,
            sipName_customCellSize,
            sipName_customGridOffset,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1|J1J9J1", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QString,&a0, &a0State, sipType_QString,&a1, &a1State, sipType_QSizeF, &a2, sipType_QPointF, &a3, &a3State))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->setParametersFromRaster(*a0,*a1,*a2,*a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a3,sipType_QPointF,a3State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a3,sipType_QPointF,a3State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_setParametersFromRaster, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_checkInputParameters, "checkInputParameters(self) -> bool\n"
"Determine destination extent from the input rasters and calculate derived values\n"
"\n"
":return: ``True`` on success, sets error on error (see errorMessage())");

extern "C" {static PyObject *meth_QgsAlignRaster_checkInputParameters(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_checkInputParameters(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->checkInputParameters();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_checkInputParameters, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_alignedRasterSize, "alignedRasterSize(self) -> QSize\n"
"Returns the expected size of the resulting aligned raster\n"
"\n"
".. note::\n"
"\n"
"   first need to run checkInputParameters() which returns with success");

extern "C" {static PyObject *meth_QgsAlignRaster_alignedRasterSize(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_alignedRasterSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QSize*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QSize(sipCpp->alignedRasterSize());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_alignedRasterSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_alignedRasterExtent, "alignedRasterExtent(self) -> QgsRectangle\n"
"Returns the expected extent of the resulting aligned raster\n"
"\n"
".. note::\n"
"\n"
"   first need to run checkInputParameters() which returns with success");

extern "C" {static PyObject *meth_QgsAlignRaster_alignedRasterExtent(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_alignedRasterExtent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QgsRectangle*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsRectangle(sipCpp->alignedRasterExtent());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsRectangle,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_alignedRasterExtent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_run, "run(self) -> bool\n"
"Run the alignment process\n"
"\n"
":return: ``True`` on success, sets error on error (see errorMessage())");

extern "C" {static PyObject *meth_QgsAlignRaster_run(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_run(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->run();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_run, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_errorMessage, "errorMessage(self) -> str\n"
"Returns the error from a previous run() call.\n"
"Error message is empty if run() succeeded (returned ``True``)");

extern "C" {static PyObject *meth_QgsAlignRaster_errorMessage(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_errorMessage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->errorMessage());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_errorMessage, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_dump, "dump(self)\n"
"write contents of the object to standard error stream - for debugging");

extern "C" {static PyObject *meth_QgsAlignRaster_dump(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_dump(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->dump();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_dump, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_suggestedReferenceLayer, "suggestedReferenceLayer(self) -> int\n"
"Returns the index of the layer which has smallest cell size (returns -1 on error)");

extern "C" {static PyObject *meth_QgsAlignRaster_suggestedReferenceLayer(PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_suggestedReferenceLayer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsAlignRaster, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->suggestedReferenceLayer();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_suggestedReferenceLayer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_createAndWarp, "createAndWarp(self, raster: QgsAlignRaster.Item) -> bool\n"
"Internal function for processing of one raster (1. create output, 2. do the alignment)");

extern "C" {static PyObject *meth_QgsAlignRaster_createAndWarp(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_createAndWarp(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::Item* a0;
        sipQgsAlignRaster *sipCpp;

        static const char *sipKwdList[] = {
            sipName_raster,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsAlignRaster, &sipCpp, sipType_QgsAlignRaster_Item, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_createAndWarp(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_createAndWarp, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAlignRaster_suggestedWarpOutput, "suggestedWarpOutput(info: QgsAlignRaster.RasterInfo, destWkt: str, cellSize: QSizeF = None, gridOffset: Union[QPointF, QPoint] = None, rect: QgsRectangle = None) -> bool\n"
"Determine suggested output of raster warp to a different CRS. Returns ``True`` on success");

extern "C" {static PyObject *meth_QgsAlignRaster_suggestedWarpOutput(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsAlignRaster_suggestedWarpOutput(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsAlignRaster::RasterInfo* a0;
        const  ::QString* a1;
        int a1State = 0;
         ::QSizeF* a2 = 0;
         ::QPointF* a3 = 0;
        int a3State = 0;
         ::QgsRectangle* a4 = 0;

        static const char *sipKwdList[] = {
            sipName_info,
            sipName_destWkt,
            sipName_cellSize,
            sipName_gridOffset,
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J1|J8J0J8", sipType_QgsAlignRaster_RasterInfo, &a0, sipType_QString,&a1, &a1State, sipType_QSizeF, &a2, sipType_QPointF, &a3, &a3State, sipType_QgsRectangle, &a4))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipQgsAlignRaster::sipProtect_suggestedWarpOutput(*a0,*a1,a2,a3,a4);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a3,sipType_QPointF,a3State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a3,sipType_QPointF,a3State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAlignRaster, sipName_suggestedWarpOutput, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsAlignRaster(void *, int);}
static void release_QgsAlignRaster(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsAlignRaster *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsAlignRaster *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsAlignRaster(void *, SIP_SSIZE_T, void *);}
static void assign_QgsAlignRaster(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsAlignRaster *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsAlignRaster *>(sipSrc);
}


extern "C" {static void *array_QgsAlignRaster(SIP_SSIZE_T);}
static void *array_QgsAlignRaster(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsAlignRaster[sipNrElem];
}


extern "C" {static void *copy_QgsAlignRaster(const void *, SIP_SSIZE_T);}
static void *copy_QgsAlignRaster(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsAlignRaster(reinterpret_cast<const  ::QgsAlignRaster *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsAlignRaster(sipSimpleWrapper *);}
static void dealloc_QgsAlignRaster(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsAlignRaster *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsAlignRaster(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsAlignRaster(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsAlignRaster(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsAlignRaster *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsAlignRaster();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsAlignRaster* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsAlignRaster, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsAlignRaster(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsAlignRaster[] = {
    {SIP_MLNAME_CAST(sipName_alignedRasterExtent), meth_QgsAlignRaster_alignedRasterExtent, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_alignedRasterExtent)},
    {SIP_MLNAME_CAST(sipName_alignedRasterSize), meth_QgsAlignRaster_alignedRasterSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_alignedRasterSize)},
    {SIP_MLNAME_CAST(sipName_cellSize), meth_QgsAlignRaster_cellSize, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_cellSize)},
    {SIP_MLNAME_CAST(sipName_checkInputParameters), meth_QgsAlignRaster_checkInputParameters, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_checkInputParameters)},
    {SIP_MLNAME_CAST(sipName_clipExtent), meth_QgsAlignRaster_clipExtent, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_clipExtent)},
    {SIP_MLNAME_CAST(sipName_createAndWarp), (PyCFunction)meth_QgsAlignRaster_createAndWarp, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_createAndWarp)},
    {SIP_MLNAME_CAST(sipName_destinationCrs), meth_QgsAlignRaster_destinationCrs, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_destinationCrs)},
    {SIP_MLNAME_CAST(sipName_dump), meth_QgsAlignRaster_dump, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_dump)},
    {SIP_MLNAME_CAST(sipName_errorMessage), meth_QgsAlignRaster_errorMessage, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_errorMessage)},
    {SIP_MLNAME_CAST(sipName_gridOffset), meth_QgsAlignRaster_gridOffset, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_gridOffset)},
    {SIP_MLNAME_CAST(sipName_progressHandler), meth_QgsAlignRaster_progressHandler, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_progressHandler)},
    {SIP_MLNAME_CAST(sipName_rasters), meth_QgsAlignRaster_rasters, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_rasters)},
    {SIP_MLNAME_CAST(sipName_run), meth_QgsAlignRaster_run, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_run)},
    {SIP_MLNAME_CAST(sipName_setCellSize), (PyCFunction)meth_QgsAlignRaster_setCellSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_setCellSize)},
    {SIP_MLNAME_CAST(sipName_setClipExtent), (PyCFunction)meth_QgsAlignRaster_setClipExtent, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_setClipExtent)},
    {SIP_MLNAME_CAST(sipName_setDestinationCrs), (PyCFunction)meth_QgsAlignRaster_setDestinationCrs, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_setDestinationCrs)},
    {SIP_MLNAME_CAST(sipName_setGridOffset), (PyCFunction)meth_QgsAlignRaster_setGridOffset, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_setGridOffset)},
    {SIP_MLNAME_CAST(sipName_setParametersFromRaster), (PyCFunction)meth_QgsAlignRaster_setParametersFromRaster, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_setParametersFromRaster)},
    {SIP_MLNAME_CAST(sipName_setProgressHandler), (PyCFunction)meth_QgsAlignRaster_setProgressHandler, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_setProgressHandler)},
    {SIP_MLNAME_CAST(sipName_setRasters), (PyCFunction)meth_QgsAlignRaster_setRasters, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_setRasters)},
    {SIP_MLNAME_CAST(sipName_suggestedReferenceLayer), meth_QgsAlignRaster_suggestedReferenceLayer, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAlignRaster_suggestedReferenceLayer)},
    {SIP_MLNAME_CAST(sipName_suggestedWarpOutput), (PyCFunction)meth_QgsAlignRaster_suggestedWarpOutput, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsAlignRaster_suggestedWarpOutput)}
};

static sipEnumMemberDef enummembers_QgsAlignRaster[] = {
    {sipName_RA_Average, static_cast<int>( ::QgsAlignRaster::RA_Average), 14},
    {sipName_RA_Bilinear, static_cast<int>( ::QgsAlignRaster::RA_Bilinear), 14},
    {sipName_RA_Cubic, static_cast<int>( ::QgsAlignRaster::RA_Cubic), 14},
    {sipName_RA_CubicSpline, static_cast<int>( ::QgsAlignRaster::RA_CubicSpline), 14},
    {sipName_RA_Lanczos, static_cast<int>( ::QgsAlignRaster::RA_Lanczos), 14},
    {sipName_RA_Max, static_cast<int>( ::QgsAlignRaster::RA_Max), 14},
    {sipName_RA_Median, static_cast<int>( ::QgsAlignRaster::RA_Median), 14},
    {sipName_RA_Min, static_cast<int>( ::QgsAlignRaster::RA_Min), 14},
    {sipName_RA_Mode, static_cast<int>( ::QgsAlignRaster::RA_Mode), 14},
    {sipName_RA_NearestNeighbour, static_cast<int>( ::QgsAlignRaster::RA_NearestNeighbour), 14},
    {sipName_RA_Q1, static_cast<int>( ::QgsAlignRaster::RA_Q1), 14},
    {sipName_RA_Q3, static_cast<int>( ::QgsAlignRaster::RA_Q3), 14},
};

PyDoc_STRVAR(doc_QgsAlignRaster, "\n"
"\n"
"\n"
"QgsAlignRaster takes one or more raster layers and warps (resamples) them\n"
"so they have the same:\n"
"- coordinate reference system\n"
"- cell size and raster size\n"
"- offset of the raster grid\n"
"\n"
".. versionadded:: 2.12");


static pyqt5ClassPluginDef plugin_QgsAlignRaster = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsAlignRaster = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsAlignRaster,
        {0},
        &plugin_QgsAlignRaster
    },
    {
        sipNameNr_QgsAlignRaster,
        {0, 0, 1},
        22, methods_QgsAlignRaster,
        12, enummembers_QgsAlignRaster,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsAlignRaster,
    -1,
    -1,
    0,
    0,
    init_type_QgsAlignRaster,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsAlignRaster,
    assign_QgsAlignRaster,
    array_QgsAlignRaster,
    copy_QgsAlignRaster,
    release_QgsAlignRaster,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 24 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/qgsanalysis.sip"
#include "qgsanalysis.h"
#line 8157 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"

#line 30 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckregistry.sip"
#include "qgsgeometrycheckregistry.h"
#line 8161 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart3.cpp"


PyDoc_STRVAR(doc_QgsAnalysis_instance, "instance() -> QgsAnalysis\n"
"Returns a pointer to the singleton instance.");

extern "C" {static PyObject *meth_QgsAnalysis_instance(PyObject *, PyObject *);}
static PyObject *meth_QgsAnalysis_instance(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::QgsAnalysis*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes =  ::QgsAnalysis::instance();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QgsAnalysis,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAnalysis, sipName_instance, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsAnalysis_geometryCheckRegistry, "geometryCheckRegistry() -> QgsGeometryCheckRegistry\n"
"Returns the global geometry checker registry, used for managing all geometry check factories.");

extern "C" {static PyObject *meth_QgsAnalysis_geometryCheckRegistry(PyObject *, PyObject *);}
static PyObject *meth_QgsAnalysis_geometryCheckRegistry(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::QgsGeometryCheckRegistry*sipRes;
            PyObject *sipResObj;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes =  ::QgsAnalysis::geometryCheckRegistry();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipResObj = sipConvertFromType(sipRes,sipType_QgsGeometryCheckRegistry,NULL);

            sipKeepReference(NULL, -1, sipResObj);

            return sipResObj;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsAnalysis, sipName_geometryCheckRegistry, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsAnalysis(void *, int);}
static void release_QgsAnalysis(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsAnalysis *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsAnalysis(sipSimpleWrapper *);}
static void dealloc_QgsAnalysis(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsAnalysis(sipGetAddress(sipSelf), 0);
    }
}


static PyMethodDef methods_QgsAnalysis[] = {
    {SIP_MLNAME_CAST(sipName_geometryCheckRegistry), meth_QgsAnalysis_geometryCheckRegistry, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAnalysis_geometryCheckRegistry)},
    {SIP_MLNAME_CAST(sipName_instance), meth_QgsAnalysis_instance, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsAnalysis_instance)}
};

PyDoc_STRVAR(doc_QgsAnalysis, "QgsAnalysis is a singleton class containing various registry and other global members\n"
"related to analysis classes.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsAnalysis = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsAnalysis = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsAnalysis,
        {0},
        &plugin_QgsAnalysis
    },
    {
        sipNameNr_QgsAnalysis,
        {0, 0, 1},
        2, methods_QgsAnalysis,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsAnalysis,
    -1,
    -1,
    0,
    0,
    0,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsAnalysis,
    0,
    0,
    0,
    release_QgsAnalysis,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

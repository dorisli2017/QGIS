/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPI_analysis.h"

#line 109 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheck.sip"
#include "qgsgeometrycheck.h"
#line 12 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 26 "/usr/share/sip/PyQt5/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 16 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qpycore_qmap.sip"
#include <qmap.h>
#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 25 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 36 "/usr/share/sip/PyQt5/QtCore/qstringlist.sip"
#include <qstringlist.h>
#line 28 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 773 "core/conversions.sip"
#include <QMap>
#line 31 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsfeaturepool.sip"
#include "qgsfeaturepool.h"
#line 34 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 149 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 37 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerror.sip"
#include "qgsgeometrycheckerror.h"
#line 40 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 43 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 109 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheck.sip"
#include "qgsgeometrycheck.h"
#line 46 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 109 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheck.sip"
#include "qgsgeometrycheck.h"
#line 49 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 1726 "core/conversions.sip"
#include <qgswkbtypes.h>
#line 52 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 24 "core/auto_generated/geometry/qgswkbtypes.sip"
#include "qgswkbtypes.h"
#line 55 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 305 "core/auto_generated/qgsvectorlayer.sip"
#include "qgsvectorlayer.h"
#line 58 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsGeometryCheck : public  ::QgsGeometryCheck
{
public:
    sipQgsGeometryCheck(const  ::QgsGeometryCheckContext*,const  ::QVariantMap&);
    sipQgsGeometryCheck(const  ::QgsGeometryCheck&);
    virtual ~sipQgsGeometryCheck();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QgsGeometryCheck::CheckType checkType() const;
     ::QString id() const;
     ::QString description() const;
     ::QStringList resolutionMethods() const;
    void collectErrors(const QMap< ::QString, ::QgsFeaturePool*>&,QList< ::QgsGeometryCheckError*>&, ::QStringList&, ::QgsFeedback*,const  ::QgsGeometryCheck::LayerFeatureIds&) const;
     ::QgsGeometryCheck::Flags flags() const;
     ::QList< ::QgsWkbTypes::GeometryType> compatibleGeometryTypes() const;
    bool isCompatible( ::QgsVectorLayer*) const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsGeometryCheck(const sipQgsGeometryCheck &);
    sipQgsGeometryCheck &operator = (const sipQgsGeometryCheck &);

    char sipPyMethods[8];
};

sipQgsGeometryCheck::sipQgsGeometryCheck(const  ::QgsGeometryCheckContext*a0,const  ::QVariantMap& a1):  ::QgsGeometryCheck(a0,a1), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometryCheck::sipQgsGeometryCheck(const  ::QgsGeometryCheck& a0):  ::QgsGeometryCheck(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometryCheck::~sipQgsGeometryCheck()
{
    sipInstanceDestroyed(sipPySelf);
}

 ::QgsGeometryCheck::CheckType sipQgsGeometryCheck::checkType() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,sipName_QgsGeometryCheck,sipName_checkType);

    if (!sipMeth)
        return  ::QgsGeometryCheck::FeatureNodeCheck;

    extern  ::QgsGeometryCheck::CheckType sipVH__analysis_32(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_32(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QString sipQgsGeometryCheck::id() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,sipName_QgsGeometryCheck,sipName_id);

    if (!sipMeth)
        return  ::QString();

    extern  ::QString sipVH__analysis_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_20(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QString sipQgsGeometryCheck::description() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[2]),sipPySelf,sipName_QgsGeometryCheck,sipName_description);

    if (!sipMeth)
        return  ::QString();

    extern  ::QString sipVH__analysis_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_20(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QStringList sipQgsGeometryCheck::resolutionMethods() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[3]),sipPySelf,sipName_QgsGeometryCheck,sipName_resolutionMethods);

    if (!sipMeth)
        return  ::QStringList();

    extern  ::QStringList sipVH__analysis_31(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_31(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQgsGeometryCheck::collectErrors(const QMap< ::QString, ::QgsFeaturePool*>& a0,QList< ::QgsGeometryCheckError*>& a1, ::QStringList& a2, ::QgsFeedback*a3,const  ::QgsGeometryCheck::LayerFeatureIds& a4) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[4]),sipPySelf,sipName_QgsGeometryCheck,sipName_collectErrors);

    if (!sipMeth)
        return;

    extern void sipVH__analysis_30(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const QMap< ::QString, ::QgsFeaturePool*>&,QList< ::QgsGeometryCheckError*>&, ::QStringList&, ::QgsFeedback*,const  ::QgsGeometryCheck::LayerFeatureIds&);

    sipVH__analysis_30(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4);
}

 ::QgsGeometryCheck::Flags sipQgsGeometryCheck::flags() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,NULL,sipName_flags);

    if (!sipMeth)
        return  ::QgsGeometryCheck::flags();

    extern  ::QgsGeometryCheck::Flags sipVH__analysis_29(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_29(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QList< ::QgsWkbTypes::GeometryType> sipQgsGeometryCheck::compatibleGeometryTypes() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[6]),sipPySelf,sipName_QgsGeometryCheck,sipName_compatibleGeometryTypes);

    if (!sipMeth)
        return  ::QList< ::QgsWkbTypes::GeometryType>();

    extern  ::QList< ::QgsWkbTypes::GeometryType> sipVH__analysis_28(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_28(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQgsGeometryCheck::isCompatible( ::QgsVectorLayer*a0) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[7]),sipPySelf,NULL,sipName_isCompatible);

    if (!sipMeth)
        return  ::QgsGeometryCheck::isCompatible(a0);

    extern bool sipVH__analysis_27(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QgsVectorLayer*);

    return sipVH__analysis_27(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QgsGeometryCheck_isCompatible, "isCompatible(self, layer: QgsVectorLayer) -> bool\n"
"Returns if this geometry check is compatible with ``layer``.\n"
"By default it checks for the geometry type in ``compatibleGeometryTypes``().\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_isCompatible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_isCompatible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QgsVectorLayer* a0;
        const  ::QgsGeometryCheck *sipCpp;

        static const char *sipKwdList[] = {
            sipName_layer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsGeometryCheck, &sipCpp, sipType_QgsVectorLayer, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsGeometryCheck::isCompatible(a0) : sipCpp->isCompatible(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_isCompatible, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_compatibleGeometryTypes, "compatibleGeometryTypes(self) -> object\n"
"A list of geometry types for which this check can be performed.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_compatibleGeometryTypes(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_compatibleGeometryTypes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::QgsGeometryCheck *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheck, &sipCpp))
        {
             ::QList< ::QgsWkbTypes::GeometryType>*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsGeometryCheck, sipName_compatibleGeometryTypes);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QList< ::QgsWkbTypes::GeometryType>(sipCpp->compatibleGeometryTypes());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_0100QgsWkbTypes_GeometryType,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_compatibleGeometryTypes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_flags, "flags(self) -> QgsGeometryCheck.Flags\n"
"Flags for this geometry check.");

extern "C" {static PyObject *meth_QgsGeometryCheck_flags(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_flags(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsGeometryCheck *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheck, &sipCpp))
        {
             ::QgsGeometryCheck::Flags*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometryCheck::Flags((sipSelfWasArg ? sipCpp-> ::QgsGeometryCheck::flags() : sipCpp->flags()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGeometryCheck_Flags,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_flags, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_collectErrors, "collectErrors(self, featurePools: object, errors: object, messages: Iterable[str], feedback: QgsFeedback, ids: QgsGeometryCheck.LayerFeatureIds = QgsGeometryCheck.LayerFeatureIds()) -> Tuple[object, List[str]]\n"
"The main worker method.\n"
"Check all features available from ``featurePools`` and write errors found to ``errors``.\n"
"Other status messages can be written to ``messages``.\n"
"Progress should be reported to ``feedback``. Only features and layers listed in ``ids`` should be checked.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_collectErrors(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_collectErrors(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const QMap< ::QString, ::QgsFeaturePool*>* a0;
        int a0State = 0;
        QList< ::QgsGeometryCheckError*>* a1;
        int a1State = 0;
         ::QStringList* a2;
        int a2State = 0;
         ::QgsFeedback* a3;
        const  ::QgsGeometryCheck::LayerFeatureIds& a4def = QgsGeometryCheck::LayerFeatureIds();
        const  ::QgsGeometryCheck::LayerFeatureIds* a4 = &a4def;
        const  ::QgsGeometryCheck *sipCpp;

        static const char *sipKwdList[] = {
            sipName_featurePools,
            sipName_errors,
            sipName_messages,
            sipName_feedback,
            sipName_ids,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1J1J8|J9", &sipSelf, sipType_QgsGeometryCheck, &sipCpp, sipType_QMap_0100QString_0101QgsFeaturePool,&a0, &a0State, sipType_QList_0101QgsGeometryCheckError,&a1, &a1State, sipType_QStringList,&a2, &a2State, sipType_QgsFeedback, &a3, sipType_QgsGeometryCheck_LayerFeatureIds, &a4))
        {
            PyObject *sipResObj;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsGeometryCheck, sipName_collectErrors);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->collectErrors(*a0,*a1,*a2,a3,*a4);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QMap< ::QString, ::QgsFeaturePool*> *>(a0),sipType_QMap_0100QString_0101QgsFeaturePool,a0State);
            sipReleaseType(a1,sipType_QList_0101QgsGeometryCheckError,a1State);
            sipReleaseType(a2,sipType_QStringList,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipResObj = sipBuildResult(0,"(DD)",a1,sipType_QList_0101QgsGeometryCheckError,NULL,a2,sipType_QStringList,NULL);
            sipReleaseType(const_cast<QMap< ::QString, ::QgsFeaturePool*> *>(a0),sipType_QMap_0100QString_0101QgsFeaturePool,a0State);
            sipReleaseType(a1,sipType_QList_0101QgsGeometryCheckError,a1State);
            sipReleaseType(a2,sipType_QStringList,a2State);

            return sipResObj;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_collectErrors, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_resolutionMethods, "resolutionMethods(self) -> List[str]\n"
"Returns a list of descriptions for available resolutions for errors. The index will be passed as ``method`` to :py:func:`fixError`.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_resolutionMethods(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_resolutionMethods(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::QgsGeometryCheck *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheck, &sipCpp))
        {
             ::QStringList*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsGeometryCheck, sipName_resolutionMethods);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QStringList(sipCpp->resolutionMethods());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QStringList,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_resolutionMethods, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_description, "description(self) -> str\n"
"Returns a human readable description for this check.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_description(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_description(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::QgsGeometryCheck *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheck, &sipCpp))
        {
             ::QString*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsGeometryCheck, sipName_description);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->description());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_description, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_id, "id(self) -> str\n"
"Returns an id for this check.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_id(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_id(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::QgsGeometryCheck *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheck, &sipCpp))
        {
             ::QString*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsGeometryCheck, sipName_id);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->id());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_id, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_checkType, "checkType(self) -> QgsGeometryCheck.CheckType\n"
"Returns the check type.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_checkType(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_checkType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::QgsGeometryCheck *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheck, &sipCpp))
        {
             ::QgsGeometryCheck::CheckType sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsGeometryCheck, sipName_checkType);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->checkType();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsGeometryCheck_CheckType);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_checkType, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheck_context, "context(self) -> QgsGeometryCheckContext\n"
"Returns the context\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsGeometryCheck_context(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheck_context(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheck *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheck, &sipCpp))
        {
            const  ::QgsGeometryCheckContext*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->context();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(const_cast< ::QgsGeometryCheckContext *>(sipRes),sipType_QgsGeometryCheckContext,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheck, sipName_context, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometryCheck(void *, int);}
static void release_QgsGeometryCheck(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsGeometryCheck *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsGeometryCheck *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGeometryCheck(sipSimpleWrapper *);}
static void dealloc_QgsGeometryCheck(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsGeometryCheck *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometryCheck(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsGeometryCheck(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometryCheck(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsGeometryCheck *sipCpp = 0;

    {
        const  ::QgsGeometryCheckContext* a0;
        const  ::QVariantMap* a1;
        int a1State = 0;

        static const char *sipKwdList[] = {
            sipName_context,
            sipName_configuration,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J1", sipType_QgsGeometryCheckContext, &a0, sipType_QMap_0100QString_0100QVariant,&a1, &a1State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometryCheck(a0,*a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QVariantMap *>(a1),sipType_QMap_0100QString_0100QVariant,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QVariantMap *>(a1),sipType_QMap_0100QString_0100QVariant,a1State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsGeometryCheck* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGeometryCheck, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometryCheck(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGeometryCheck[] = {
    {SIP_MLNAME_CAST(sipName_checkType), meth_QgsGeometryCheck_checkType, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_checkType)},
    {SIP_MLNAME_CAST(sipName_collectErrors), (PyCFunction)meth_QgsGeometryCheck_collectErrors, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_collectErrors)},
    {SIP_MLNAME_CAST(sipName_compatibleGeometryTypes), meth_QgsGeometryCheck_compatibleGeometryTypes, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_compatibleGeometryTypes)},
    {SIP_MLNAME_CAST(sipName_context), meth_QgsGeometryCheck_context, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_context)},
    {SIP_MLNAME_CAST(sipName_description), meth_QgsGeometryCheck_description, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_description)},
    {SIP_MLNAME_CAST(sipName_flags), meth_QgsGeometryCheck_flags, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_flags)},
    {SIP_MLNAME_CAST(sipName_id), meth_QgsGeometryCheck_id, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_id)},
    {SIP_MLNAME_CAST(sipName_isCompatible), (PyCFunction)meth_QgsGeometryCheck_isCompatible, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_isCompatible)},
    {SIP_MLNAME_CAST(sipName_resolutionMethods), meth_QgsGeometryCheck_resolutionMethods, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheck_resolutionMethods)}
};

static sipEnumMemberDef enummembers_QgsGeometryCheck[] = {
    {sipName_AvailableInValidation, static_cast<int>( ::QgsGeometryCheck::AvailableInValidation), 26},
    {sipName_ChangeAdded, static_cast<int>( ::QgsGeometryCheck::ChangeAdded), 23},
    {sipName_ChangeChanged, static_cast<int>( ::QgsGeometryCheck::ChangeChanged), 23},
    {sipName_ChangeFeature, static_cast<int>( ::QgsGeometryCheck::ChangeFeature), 24},
    {sipName_ChangeNode, static_cast<int>( ::QgsGeometryCheck::ChangeNode), 24},
    {sipName_ChangePart, static_cast<int>( ::QgsGeometryCheck::ChangePart), 24},
    {sipName_ChangeRemoved, static_cast<int>( ::QgsGeometryCheck::ChangeRemoved), 23},
    {sipName_ChangeRing, static_cast<int>( ::QgsGeometryCheck::ChangeRing), 24},
    {sipName_FeatureCheck, static_cast<int>( ::QgsGeometryCheck::FeatureCheck), 25},
    {sipName_FeatureNodeCheck, static_cast<int>( ::QgsGeometryCheck::FeatureNodeCheck), 25},
    {sipName_LayerCheck, static_cast<int>( ::QgsGeometryCheck::LayerCheck), 25},
};


extern "C" {static PyObject *varget_QgsGeometryCheck_staticMetaObject(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsGeometryCheck_staticMetaObject(void *, PyObject *, PyObject *)
{
    const  ::QMetaObject*sipVal;

    sipVal = new  ::QMetaObject( ::QgsGeometryCheck::staticMetaObject);

    return sipConvertFromNewType(const_cast< ::QMetaObject *>(sipVal), sipType_QMetaObject, NULL);
}

sipVariableDef variables_QgsGeometryCheck[] = {
    {ClassVariable, sipName_staticMetaObject, (PyMethodDef *)varget_QgsGeometryCheck_staticMetaObject, NULL, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsGeometryCheck, "QgsGeometryCheck(context: QgsGeometryCheckContext, configuration: Dict[str, Any])\n"
"Create a new geometry check.\n"
"\n"
"QgsGeometryCheck(QgsGeometryCheck)\n"
"\n"
"This class implements a geometry check.\n"
"\n"
"Geometry checks run over a set of features and can detect errors like topological\n"
"or other issues which are reported in the geometry validation panel in QGIS and\n"
"help a user to create valid geometries.\n"
"\n"
"Implementing a custom geometry check consists of the following parts\n"
"\n"
"### Writing the check\n"
"\n"
"A new subclass of QgsGeometryCheck needs to be written and at least the following\n"
"abstract methods need to be implemented:\n"
"\n"
"- `compatibleGeometryTypes()`\n"
"\n"
"A list of geometry types to which this check applies\n"
"\n"
"- `resolutionMethods()`\n"
"\n"
"A list of names for (automated) resolution methods that can be used to fix errors of this type\n"
"\n"
"- `description()`\n"
"\n"
"A description for the geometry check.\n"
"\n"
"- `id()`\n"
"\n"
"A unique id for this check.\n"
"\n"
"- `checkType()`\n"
"\n"
"One of QgsGeometryCheck.LayerCheck, QgsGeometryCheck.FeatureCheck,QgsGeometryCheck.FeatureNodeCheck\n"
"\n"
"- \\link collectErrors() `collectErrors(featurePools, errors, messages, feedback, ids)`\\endlink\n"
"\n"
"This method will be called to validate geometries. All geometries which should be validated are passed\n"
"into this method with the parameter ids and should be retrieved from the available featurePools to make\n"
"use of caching. New errors should be appended to the error list and other message strings to messages.\n"
"The method needs to return a tuple (errors, messages).\n"
"\n"
"### Creating a geometry check factory\n"
"\n"
"A Geometry check factory manages meta information for checks. There will always be one single\n"
"geometry check factory created per check type, but it's possible that multiple QgsGeometryCheck\n"
"instances are created and used in parallel.\n"
"\n"
"A new subclass of QgsGeometryCheckFactory needs to be written and at least the following\n"
"abstract methods need to be implemented:\n"
"\n"
"- \\link QgsGeometryCheckFactory.createGeometryCheck() `createGeometryCheck(context, configuration)`\\endlink\n"
"\n"
"Needs to return a new subclassed QgsGeometryCheck object that has been written in the previous step.\n"
"\n"
"- \\link QgsGeometryCheckFactory.id() `id()\\endlink\n"
"\n"
"A unique id for this geometry check.\n"
"\n"
"- \\link QgsGeometryCheckFactory.description() `description()\\endlink\n"
"\n"
"A description for this geometry check that can be presented to the user for more explanation.\n"
"\n"
"- \\link QgsGeometryCheckFactory.isCompatible() `QgsGeometryCheckFactory.isCompatible(layer)`\\endlink\n"
"\n"
"Returns a boolean that determines if this check is available for a given layer. This often\n"
"checks for the geometry type of the layer.\n"
"\n"
"- \\link QgsGeometryCheckFactory.flags() `flags()`\\endlink\n"
"\n"
"Returns additional flags for a geometry check. If unsure return QgsGeometryCheck.AvailableInValidation.\n"
"\n"
"- \\link QgsGeometryCheckFactory.checkType() `checkType()`\\endlink\n"
"\n"
"Returns the type of this geometry check.\n"
"\n"
"### Registering the geometry check\n"
"\n"
"Finally the geometry check factory needs to be registered in QGIS, so the system\n"
"is aware of the available geometry checks.\n"
"\n"
".. code-block:: python\n"
"\n"
"     # Make sure you always keep a\n"
"     checkFactory = MyGeometryCheckFactory()\n"
"     QgsAnalysis.geometryCheckRegistry().registerGeometryCheck(checkFactory)\n"
"\n"
".. note::\n"
"\n"
"   This class is a technology preview and unstable API.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsGeometryCheck = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometryCheck = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometryCheck,
        {0},
        &plugin_QgsGeometryCheck
    },
    {
        sipNameNr_QgsGeometryCheck,
        {0, 0, 1},
        9, methods_QgsGeometryCheck,
        11, enummembers_QgsGeometryCheck,
        1, variables_QgsGeometryCheck,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometryCheck,
    -1,
    -1,
    0,
    0,
    init_type_QgsGeometryCheck,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometryCheck,
    0,
    0,
    0,
    release_QgsGeometryCheck,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 97 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgssinglegeometrycheck.sip"
#include "qgssinglegeometrycheck.h"
#line 986 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 28 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgssinglegeometrycheck.sip"
#include "qgssinglegeometrycheck.h"
#line 990 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 42 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 995 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtGui/qicon.sip"
#include <qicon.h>
#line 998 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerror.sip"
#include "qgsgeometrycheckerror.h"
#line 1001 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 1004 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 1007 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 1010 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "core/auto_generated/geometry/qgsrectangle.sip"
#include "qgsrectangle.h"
#line 1013 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 45 "core/auto_generated/geometry/qgsgeometry.sip"
#include "qgsgeometry.h"
#line 1016 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 109 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheck.sip"
#include "qgsgeometrycheck.h"
#line 1019 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsGeometryCheckErrorSingle : public  ::QgsGeometryCheckErrorSingle
{
public:
    sipQgsGeometryCheckErrorSingle( ::QgsSingleGeometryCheckError*,const  ::QgsGeometryCheckerUtils::LayerFeature&);
    sipQgsGeometryCheckErrorSingle(const  ::QgsGeometryCheckErrorSingle&);
    virtual ~sipQgsGeometryCheckErrorSingle();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QgsRectangle affectedAreaBBox() const;
     ::QString description() const;
    bool isEqual( ::QgsGeometryCheckError*) const;
    bool closeMatch( ::QgsGeometryCheckError*) const;
    void update(const  ::QgsGeometryCheckError*);
     ::QIcon icon() const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsGeometryCheckErrorSingle(const sipQgsGeometryCheckErrorSingle &);
    sipQgsGeometryCheckErrorSingle &operator = (const sipQgsGeometryCheckErrorSingle &);

    char sipPyMethods[6];
};

sipQgsGeometryCheckErrorSingle::sipQgsGeometryCheckErrorSingle( ::QgsSingleGeometryCheckError*a0,const  ::QgsGeometryCheckerUtils::LayerFeature& a1):  ::QgsGeometryCheckErrorSingle(a0,a1), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometryCheckErrorSingle::sipQgsGeometryCheckErrorSingle(const  ::QgsGeometryCheckErrorSingle& a0):  ::QgsGeometryCheckErrorSingle(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometryCheckErrorSingle::~sipQgsGeometryCheckErrorSingle()
{
    sipInstanceDestroyed(sipPySelf);
}

 ::QgsRectangle sipQgsGeometryCheckErrorSingle::affectedAreaBBox() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,NULL,sipName_affectedAreaBBox);

    if (!sipMeth)
        return  ::QgsGeometryCheckErrorSingle::affectedAreaBBox();

    extern  ::QgsRectangle sipVH__analysis_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_21(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QString sipQgsGeometryCheckErrorSingle::description() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_description);

    if (!sipMeth)
        return  ::QgsGeometryCheckErrorSingle::description();

    extern  ::QString sipVH__analysis_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_20(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQgsGeometryCheckErrorSingle::isEqual( ::QgsGeometryCheckError*a0) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[2]),sipPySelf,NULL,sipName_isEqual);

    if (!sipMeth)
        return  ::QgsGeometryCheckErrorSingle::isEqual(a0);

    extern bool sipVH__analysis_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QgsGeometryCheckError*);

    return sipVH__analysis_22(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQgsGeometryCheckErrorSingle::closeMatch( ::QgsGeometryCheckError*a0) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[3]),sipPySelf,NULL,sipName_closeMatch);

    if (!sipMeth)
        return  ::QgsGeometryCheckErrorSingle::closeMatch(a0);

    extern bool sipVH__analysis_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QgsGeometryCheckError*);

    return sipVH__analysis_22(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGeometryCheckErrorSingle::update(const  ::QgsGeometryCheckError*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_update);

    if (!sipMeth)
    {
         ::QgsGeometryCheckErrorSingle::update(a0);
        return;
    }

    extern void sipVH__analysis_23(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QgsGeometryCheckError*);

    sipVH__analysis_23(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::QIcon sipQgsGeometryCheckErrorSingle::icon() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,NULL,sipName_icon);

    if (!sipMeth)
        return  ::QgsGeometryCheckErrorSingle::icon();

    extern  ::QIcon sipVH__analysis_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_24(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_QgsGeometryCheckErrorSingle_singleError, "singleError(self) -> QgsSingleGeometryCheckError\n"
"The underlying single error.");

extern "C" {static PyObject *meth_QgsGeometryCheckErrorSingle_singleError(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckErrorSingle_singleError(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckErrorSingle *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckErrorSingle, &sipCpp))
        {
             ::QgsSingleGeometryCheckError*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->singleError();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QgsSingleGeometryCheckError,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckErrorSingle, sipName_singleError, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsGeometryCheckErrorSingle(void *, const sipTypeDef *);}
static void *cast_QgsGeometryCheckErrorSingle(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsGeometryCheckErrorSingle *sipCpp = reinterpret_cast< ::QgsGeometryCheckErrorSingle *>(sipCppV);

    if (targetType == sipType_QgsGeometryCheckError)
        return static_cast< ::QgsGeometryCheckError *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometryCheckErrorSingle(void *, int);}
static void release_QgsGeometryCheckErrorSingle(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsGeometryCheckErrorSingle *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsGeometryCheckErrorSingle *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGeometryCheckErrorSingle(sipSimpleWrapper *);}
static void dealloc_QgsGeometryCheckErrorSingle(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsGeometryCheckErrorSingle *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometryCheckErrorSingle(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsGeometryCheckErrorSingle(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometryCheckErrorSingle(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsGeometryCheckErrorSingle *sipCpp = 0;

    {
         ::QgsSingleGeometryCheckError* a0;
        const  ::QgsGeometryCheckerUtils::LayerFeature* a1;

        static const char *sipKwdList[] = {
            sipName_singleError,
            sipName_layerFeature,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J9", sipType_QgsSingleGeometryCheckError, &a0, sipType_QgsGeometryCheckerUtils_LayerFeature, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometryCheckErrorSingle(a0,*a1);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsGeometryCheckErrorSingle* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGeometryCheckErrorSingle, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometryCheckErrorSingle(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsGeometryCheckErrorSingle[] = {{30, 255, 1}};


static PyMethodDef methods_QgsGeometryCheckErrorSingle[] = {
    {SIP_MLNAME_CAST(sipName_singleError), meth_QgsGeometryCheckErrorSingle_singleError, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckErrorSingle_singleError)}
};

PyDoc_STRVAR(doc_QgsGeometryCheckErrorSingle, "QgsGeometryCheckErrorSingle(singleError: QgsSingleGeometryCheckError, layerFeature: QgsGeometryCheckerUtils.LayerFeature)\n"
"Creates a new error for a :py:class:`QgsSingleGeometryCheck`.\n"
"\n"
"QgsGeometryCheckErrorSingle(QgsGeometryCheckErrorSingle)\n"
"\n"
"\n"
"Wraps a QgsSingleGeometryError into a standard :py:class:`QgsGeometryCheckError`.\n"
"The single error can be obtained via singleError.\n"
"\n"
".. note::\n"
"\n"
"   This class is a technology preview and unstable API.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsGeometryCheckErrorSingle = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometryCheckErrorSingle = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometryCheckErrorSingle,
        {0},
        &plugin_QgsGeometryCheckErrorSingle
    },
    {
        sipNameNr_QgsGeometryCheckErrorSingle,
        {0, 0, 1},
        1, methods_QgsGeometryCheckErrorSingle,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometryCheckErrorSingle,
    -1,
    -1,
    supers_QgsGeometryCheckErrorSingle,
    0,
    init_type_QgsGeometryCheckErrorSingle,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometryCheckErrorSingle,
    0,
    0,
    0,
    release_QgsGeometryCheckErrorSingle,
    cast_QgsGeometryCheckErrorSingle,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 28 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgssinglegeometrycheck.sip"
#include "qgssinglegeometrycheck.h"
#line 1392 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 127 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgssinglegeometrycheck.sip"
#include "qgssinglegeometrycheck.h"
#line 1396 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 45 "core/auto_generated/geometry/qgsgeometry.sip"
#include "qgsgeometry.h"
#line 1399 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 1402 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsSingleGeometryCheckError : public  ::QgsSingleGeometryCheckError
{
public:
    sipQgsSingleGeometryCheckError(const  ::QgsSingleGeometryCheck*,const  ::QgsGeometry&,const  ::QgsGeometry&,const  ::QgsVertexId&);
    sipQgsSingleGeometryCheckError(const  ::QgsSingleGeometryCheckError&);
    virtual ~sipQgsSingleGeometryCheckError();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QString description() const;
    bool isEqual(const  ::QgsSingleGeometryCheckError*) const;
    void update(const  ::QgsSingleGeometryCheckError*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsSingleGeometryCheckError(const sipQgsSingleGeometryCheckError &);
    sipQgsSingleGeometryCheckError &operator = (const sipQgsSingleGeometryCheckError &);

    char sipPyMethods[3];
};

sipQgsSingleGeometryCheckError::sipQgsSingleGeometryCheckError(const  ::QgsSingleGeometryCheck*a0,const  ::QgsGeometry& a1,const  ::QgsGeometry& a2,const  ::QgsVertexId& a3):  ::QgsSingleGeometryCheckError(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsSingleGeometryCheckError::sipQgsSingleGeometryCheckError(const  ::QgsSingleGeometryCheckError& a0):  ::QgsSingleGeometryCheckError(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsSingleGeometryCheckError::~sipQgsSingleGeometryCheckError()
{
    sipInstanceDestroyed(sipPySelf);
}

 ::QString sipQgsSingleGeometryCheckError::description() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,NULL,sipName_description);

    if (!sipMeth)
        return  ::QgsSingleGeometryCheckError::description();

    extern  ::QString sipVH__analysis_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_20(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

bool sipQgsSingleGeometryCheckError::isEqual(const  ::QgsSingleGeometryCheckError*a0) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_isEqual);

    if (!sipMeth)
        return  ::QgsSingleGeometryCheckError::isEqual(a0);

    extern bool sipVH__analysis_26(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QgsSingleGeometryCheckError*);

    return sipVH__analysis_26(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsSingleGeometryCheckError::update(const  ::QgsSingleGeometryCheckError*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_update);

    if (!sipMeth)
    {
         ::QgsSingleGeometryCheckError::update(a0);
        return;
    }

    extern void sipVH__analysis_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QgsSingleGeometryCheckError*);

    sipVH__analysis_25(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QgsSingleGeometryCheckError_update, "update(self, other: QgsSingleGeometryCheckError)\n"
"Update this error with the information from ``other``.\n"
"Will be used to update existing errors whenever they are re-checked.");

extern "C" {static PyObject *meth_QgsSingleGeometryCheckError_update(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsSingleGeometryCheckError_update(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsSingleGeometryCheckError* a0;
         ::QgsSingleGeometryCheckError *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsSingleGeometryCheckError, &sipCpp, sipType_QgsSingleGeometryCheckError, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsSingleGeometryCheckError::update(a0) : sipCpp->update(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSingleGeometryCheckError, sipName_update, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsSingleGeometryCheckError_isEqual, "isEqual(self, other: QgsSingleGeometryCheckError) -> bool\n"
"Check if this error is equal to ``other``.\n"
"Is reimplemented by subclasses with additional information, comparison\n"
"of base information is done in parent class.");

extern "C" {static PyObject *meth_QgsSingleGeometryCheckError_isEqual(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsSingleGeometryCheckError_isEqual(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsSingleGeometryCheckError* a0;
        const  ::QgsSingleGeometryCheckError *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsSingleGeometryCheckError, &sipCpp, sipType_QgsSingleGeometryCheckError, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsSingleGeometryCheckError::isEqual(a0) : sipCpp->isEqual(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSingleGeometryCheckError, sipName_isEqual, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsSingleGeometryCheckError_description, "description(self) -> str\n"
"A human readable description of this error.");

extern "C" {static PyObject *meth_QgsSingleGeometryCheckError_description(PyObject *, PyObject *);}
static PyObject *meth_QgsSingleGeometryCheckError_description(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsSingleGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsSingleGeometryCheckError, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString((sipSelfWasArg ? sipCpp-> ::QgsSingleGeometryCheckError::description() : sipCpp->description()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSingleGeometryCheckError, sipName_description, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsSingleGeometryCheckError_check, "check(self) -> QgsSingleGeometryCheck\n"
"The check that created this error.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsSingleGeometryCheckError_check(PyObject *, PyObject *);}
static PyObject *meth_QgsSingleGeometryCheckError_check(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsSingleGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsSingleGeometryCheckError, &sipCpp))
        {
            const  ::QgsSingleGeometryCheck*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->check();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(const_cast< ::QgsSingleGeometryCheck *>(sipRes),sipType_QgsSingleGeometryCheck,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSingleGeometryCheckError, sipName_check, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsSingleGeometryCheckError_errorLocation, "errorLocation(self) -> QgsGeometry\n"
"The exact location of the error.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsSingleGeometryCheckError_errorLocation(PyObject *, PyObject *);}
static PyObject *meth_QgsSingleGeometryCheckError_errorLocation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsSingleGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsSingleGeometryCheckError, &sipCpp))
        {
             ::QgsGeometry*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometry(sipCpp->errorLocation());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGeometry,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSingleGeometryCheckError, sipName_errorLocation, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsSingleGeometryCheckError_vertexId, "vertexId(self) -> QgsVertexId\n"
"The vertex id of the error. May be invalid depending on the check.\n"
"\n"
".. versionadded:: 3.4");

extern "C" {static PyObject *meth_QgsSingleGeometryCheckError_vertexId(PyObject *, PyObject *);}
static PyObject *meth_QgsSingleGeometryCheckError_vertexId(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsSingleGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsSingleGeometryCheckError, &sipCpp))
        {
             ::QgsVertexId*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsVertexId(sipCpp->vertexId());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsVertexId,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsSingleGeometryCheckError, sipName_vertexId, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsSingleGeometryCheckError(void *, int);}
static void release_QgsSingleGeometryCheckError(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsSingleGeometryCheckError *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsSingleGeometryCheckError *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsSingleGeometryCheckError(sipSimpleWrapper *);}
static void dealloc_QgsSingleGeometryCheckError(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsSingleGeometryCheckError *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsSingleGeometryCheckError(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsSingleGeometryCheckError(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsSingleGeometryCheckError(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsSingleGeometryCheckError *sipCpp = 0;

    {
        const  ::QgsSingleGeometryCheck* a0;
        const  ::QgsGeometry* a1;
        const  ::QgsGeometry* a2;
        const  ::QgsVertexId& a3def = QgsVertexId();
        const  ::QgsVertexId* a3 = &a3def;

        static const char *sipKwdList[] = {
            sipName_check,
            sipName_geometry,
            sipName_errorLocation,
            sipName_vertexId,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J9J9|J9", sipType_QgsSingleGeometryCheck, &a0, sipType_QgsGeometry, &a1, sipType_QgsGeometry, &a2, sipType_QgsVertexId, &a3))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsSingleGeometryCheckError(a0,*a1,*a2,*a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsSingleGeometryCheckError* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsSingleGeometryCheckError, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsSingleGeometryCheckError(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsSingleGeometryCheckError[] = {
    {SIP_MLNAME_CAST(sipName_check), meth_QgsSingleGeometryCheckError_check, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsSingleGeometryCheckError_check)},
    {SIP_MLNAME_CAST(sipName_description), meth_QgsSingleGeometryCheckError_description, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsSingleGeometryCheckError_description)},
    {SIP_MLNAME_CAST(sipName_errorLocation), meth_QgsSingleGeometryCheckError_errorLocation, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsSingleGeometryCheckError_errorLocation)},
    {SIP_MLNAME_CAST(sipName_isEqual), (PyCFunction)meth_QgsSingleGeometryCheckError_isEqual, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsSingleGeometryCheckError_isEqual)},
    {SIP_MLNAME_CAST(sipName_update), (PyCFunction)meth_QgsSingleGeometryCheckError_update, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsSingleGeometryCheckError_update)},
    {SIP_MLNAME_CAST(sipName_vertexId), meth_QgsSingleGeometryCheckError_vertexId, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsSingleGeometryCheckError_vertexId)}
};

PyDoc_STRVAR(doc_QgsSingleGeometryCheckError, "QgsSingleGeometryCheckError(check: QgsSingleGeometryCheck, geometry: QgsGeometry, errorLocation: QgsGeometry, vertexId: QgsVertexId = QgsVertexId())\n"
"Creates a new single geometry check error.\n"
"\n"
"QgsSingleGeometryCheckError(QgsSingleGeometryCheckError)\n"
"\n"
"\n"
"An error from a QgsSingleGeometryCheck.\n"
"\n"
".. note::\n"
"\n"
"   This class is a technology preview and unstable API.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsSingleGeometryCheckError = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsSingleGeometryCheckError = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsSingleGeometryCheckError,
        {0},
        &plugin_QgsSingleGeometryCheckError
    },
    {
        sipNameNr_QgsSingleGeometryCheckError,
        {0, 0, 1},
        6, methods_QgsSingleGeometryCheckError,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsSingleGeometryCheckError,
    -1,
    -1,
    0,
    0,
    init_type_QgsSingleGeometryCheckError,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsSingleGeometryCheckError,
    0,
    0,
    0,
    release_QgsSingleGeometryCheckError,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};


#line 157 "core/auto_generated/qgscoordinatereferencesystem.sip"
#include "qgscoordinatereferencesystem.h"
#line 1946 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 49 "core/auto_generated/qgscoordinatetransformcontext.sip"
#include "qgscoordinatetransformcontext.h"
#line 1949 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometryCheckContext(void *, int);}
static void release_QgsGeometryCheckContext(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGeometryCheckContext *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGeometryCheckContext(sipSimpleWrapper *);}
static void dealloc_QgsGeometryCheckContext(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometryCheckContext(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGeometryCheckContext(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometryCheckContext(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGeometryCheckContext *sipCpp = 0;

    {
        int a0;
        const  ::QgsCoordinateReferenceSystem* a1;
        const  ::QgsCoordinateTransformContext* a2;

        static const char *sipKwdList[] = {
            sipName_precision,
            sipName_mapCrs,
            sipName_transformContext,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "iJ9J9", &a0, sipType_QgsCoordinateReferenceSystem, &a1, sipType_QgsCoordinateTransformContext, &a2))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGeometryCheckContext(a0,*a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


extern "C" {static PyObject *varget_QgsGeometryCheckContext_mapCrs(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsGeometryCheckContext_mapCrs(void *sipSelf, PyObject *, PyObject *)
{
    const  ::QgsCoordinateReferenceSystem*sipVal;
     ::QgsGeometryCheckContext *sipCpp = reinterpret_cast< ::QgsGeometryCheckContext *>(sipSelf);

    sipVal = new  ::QgsCoordinateReferenceSystem(sipCpp->mapCrs);

    return sipConvertFromNewType(const_cast< ::QgsCoordinateReferenceSystem *>(sipVal), sipType_QgsCoordinateReferenceSystem, NULL);
}


extern "C" {static PyObject *varget_QgsGeometryCheckContext_reducedTolerance(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsGeometryCheckContext_reducedTolerance(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsGeometryCheckContext *sipCpp = reinterpret_cast< ::QgsGeometryCheckContext *>(sipSelf);

    sipVal = sipCpp->reducedTolerance;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static PyObject *varget_QgsGeometryCheckContext_tolerance(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsGeometryCheckContext_tolerance(void *sipSelf, PyObject *, PyObject *)
{
    double sipVal;
     ::QgsGeometryCheckContext *sipCpp = reinterpret_cast< ::QgsGeometryCheckContext *>(sipSelf);

    sipVal = sipCpp->tolerance;

    return PyFloat_FromDouble(sipVal);
}


extern "C" {static PyObject *varget_QgsGeometryCheckContext_transformContext(void *, PyObject *, PyObject *);}
static PyObject *varget_QgsGeometryCheckContext_transformContext(void *sipSelf, PyObject *, PyObject *)
{
    const  ::QgsCoordinateTransformContext*sipVal;
     ::QgsGeometryCheckContext *sipCpp = reinterpret_cast< ::QgsGeometryCheckContext *>(sipSelf);

    sipVal = new  ::QgsCoordinateTransformContext(sipCpp->transformContext);

    return sipConvertFromNewType(const_cast< ::QgsCoordinateTransformContext *>(sipVal), sipType_QgsCoordinateTransformContext, NULL);
}

sipVariableDef variables_QgsGeometryCheckContext[] = {
    {InstanceVariable, sipName_mapCrs, (PyMethodDef *)varget_QgsGeometryCheckContext_mapCrs, NULL, NULL, NULL},
    {InstanceVariable, sipName_reducedTolerance, (PyMethodDef *)varget_QgsGeometryCheckContext_reducedTolerance, NULL, NULL, NULL},
    {InstanceVariable, sipName_tolerance, (PyMethodDef *)varget_QgsGeometryCheckContext_tolerance, NULL, NULL, NULL},
    {InstanceVariable, sipName_transformContext, (PyMethodDef *)varget_QgsGeometryCheckContext_transformContext, NULL, NULL, NULL},
};

PyDoc_STRVAR(doc_QgsGeometryCheckContext, "\1QgsGeometryCheckContext(precision: int, mapCrs: QgsCoordinateReferenceSystem, transformContext: QgsCoordinateTransformContext)");


static pyqt5ClassPluginDef plugin_QgsGeometryCheckContext = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometryCheckContext = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometryCheckContext,
        {0},
        &plugin_QgsGeometryCheckContext
    },
    {
        sipNameNr_QgsGeometryCheckContext,
        {0, 0, 1},
        0, 0,
        0, 0,
        4, variables_QgsGeometryCheckContext,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometryCheckContext,
    -1,
    -1,
    0,
    0,
    init_type_QgsGeometryCheckContext,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometryCheckContext,
    0,
    0,
    0,
    release_QgsGeometryCheckContext,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerror.sip"
#include "qgsgeometrycheckerror.h"
#line 2131 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 109 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheck.sip"
#include "qgsgeometrycheck.h"
#line 2135 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 42 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/vector/geometry_checker/qgsgeometrycheckerutils.sip"
#include "qgsgeometrycheckerutils.h"
#line 2140 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 2143 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 2146 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 2149 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 45 "core/auto_generated/geometry/qgsgeometry.sip"
#include "qgsgeometry.h"
#line 2152 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtGui/qicon.sip"
#include <qicon.h>
#line 2155 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "core/auto_generated/geometry/qgsrectangle.sip"
#include "qgsrectangle.h"
#line 2158 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsGeometryCheckError : public  ::QgsGeometryCheckError
{
public:
    sipQgsGeometryCheckError(const  ::QgsGeometryCheck*,const  ::QgsGeometryCheckerUtils::LayerFeature&,const  ::QgsPointXY&, ::QgsVertexId,const  ::QVariant&, ::QgsGeometryCheckError::ValueType);
    sipQgsGeometryCheckError(const  ::QgsGeometryCheck*,const  ::QString&, ::QgsFeatureId,const  ::QgsGeometry&,const  ::QgsPointXY&, ::QgsVertexId,const  ::QVariant&, ::QgsGeometryCheckError::ValueType);
    sipQgsGeometryCheckError(const  ::QgsGeometryCheckError&);
    virtual ~sipQgsGeometryCheckError();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QIcon icon() const;
    void update(const  ::QgsGeometryCheckError*);
    bool closeMatch( ::QgsGeometryCheckError*) const;
    bool isEqual( ::QgsGeometryCheckError*) const;
     ::QString description() const;
     ::QgsRectangle affectedAreaBBox() const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsGeometryCheckError(const sipQgsGeometryCheckError &);
    sipQgsGeometryCheckError &operator = (const sipQgsGeometryCheckError &);

    char sipPyMethods[6];
};

sipQgsGeometryCheckError::sipQgsGeometryCheckError(const  ::QgsGeometryCheck*a0,const  ::QgsGeometryCheckerUtils::LayerFeature& a1,const  ::QgsPointXY& a2, ::QgsVertexId a3,const  ::QVariant& a4, ::QgsGeometryCheckError::ValueType a5):  ::QgsGeometryCheckError(a0,a1,a2,a3,a4,a5), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometryCheckError::sipQgsGeometryCheckError(const  ::QgsGeometryCheck*a0,const  ::QString& a1, ::QgsFeatureId a2,const  ::QgsGeometry& a3,const  ::QgsPointXY& a4, ::QgsVertexId a5,const  ::QVariant& a6, ::QgsGeometryCheckError::ValueType a7):  ::QgsGeometryCheckError(a0,a1,a2,a3,a4,a5,a6,a7), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometryCheckError::sipQgsGeometryCheckError(const  ::QgsGeometryCheckError& a0):  ::QgsGeometryCheckError(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGeometryCheckError::~sipQgsGeometryCheckError()
{
    sipInstanceDestroyed(sipPySelf);
}

 ::QIcon sipQgsGeometryCheckError::icon() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,NULL,sipName_icon);

    if (!sipMeth)
        return  ::QgsGeometryCheckError::icon();

    extern  ::QIcon sipVH__analysis_24(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_24(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQgsGeometryCheckError::update(const  ::QgsGeometryCheckError*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_update);

    if (!sipMeth)
    {
         ::QgsGeometryCheckError::update(a0);
        return;
    }

    extern void sipVH__analysis_23(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QgsGeometryCheckError*);

    sipVH__analysis_23(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQgsGeometryCheckError::closeMatch( ::QgsGeometryCheckError*a0) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[2]),sipPySelf,NULL,sipName_closeMatch);

    if (!sipMeth)
        return  ::QgsGeometryCheckError::closeMatch(a0);

    extern bool sipVH__analysis_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QgsGeometryCheckError*);

    return sipVH__analysis_22(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQgsGeometryCheckError::isEqual( ::QgsGeometryCheckError*a0) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[3]),sipPySelf,NULL,sipName_isEqual);

    if (!sipMeth)
        return  ::QgsGeometryCheckError::isEqual(a0);

    extern bool sipVH__analysis_22(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QgsGeometryCheckError*);

    return sipVH__analysis_22(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::QString sipQgsGeometryCheckError::description() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[4]),sipPySelf,NULL,sipName_description);

    if (!sipMeth)
        return  ::QgsGeometryCheckError::description();

    extern  ::QString sipVH__analysis_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_20(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QgsRectangle sipQgsGeometryCheckError::affectedAreaBBox() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,NULL,sipName_affectedAreaBBox);

    if (!sipMeth)
        return  ::QgsGeometryCheckError::affectedAreaBBox();

    extern  ::QgsRectangle sipVH__analysis_21(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_21(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_check, "check(self) -> QgsGeometryCheck\n"
"The geometry check that created this error.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_check(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_check(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
            const  ::QgsGeometryCheck*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->check();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(const_cast< ::QgsGeometryCheck *>(sipRes),sipType_QgsGeometryCheck,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_check, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_layerId, "layerId(self) -> str\n"
"The id of the layer on which this error has been detected.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_layerId(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_layerId(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->layerId());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_layerId, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_featureId, "featureId(self) -> int\n"
"The id of the feature on which this error has been detected.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_featureId(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_featureId(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QgsFeatureId sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->featureId();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyLong_FromLongLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_featureId, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_geometry, "geometry(self) -> QgsGeometry\n"
"The geometry of the error in map units.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_geometry(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_geometry(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QgsGeometry*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGeometry(sipCpp->geometry());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGeometry,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_geometry, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_affectedAreaBBox, "affectedAreaBBox(self) -> QgsRectangle\n"
"The bounding box of the affected area of the error.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_affectedAreaBBox(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_affectedAreaBBox(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QgsRectangle*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsRectangle((sipSelfWasArg ? sipCpp-> ::QgsGeometryCheckError::affectedAreaBBox() : sipCpp->affectedAreaBBox()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsRectangle,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_affectedAreaBBox, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_description, "description(self) -> str\n"
"The error description. By default the description of the parent check\n"
"will be returned.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_description(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_description(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString((sipSelfWasArg ? sipCpp-> ::QgsGeometryCheckError::description() : sipCpp->description()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_description, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_location, "location(self) -> QgsPointXY\n"
"The location of the error in map units.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_location(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_location(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QgsPointXY*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsPointXY(sipCpp->location());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsPointXY,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_location, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_value, "value(self) -> Any\n"
"An additional value for the error.\n"
"Lengths and areas are provided in map units.\n"
"\n"
".. seealso:: :py:func:`valueType`");

extern "C" {static PyObject *meth_QgsGeometryCheckError_value(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QVariant*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QVariant(sipCpp->value());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_value, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_valueType, "valueType(self) -> QgsGeometryCheckError.ValueType\n"
"The type of the value.\n"
"\n"
".. seealso:: :py:func:`value`");

extern "C" {static PyObject *meth_QgsGeometryCheckError_valueType(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_valueType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QgsGeometryCheckError::ValueType sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->valueType();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsGeometryCheckError_ValueType);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_valueType, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_vidx, "vidx(self) -> QgsVertexId\n"
"The id of the affected vertex. May be valid or not, depending on the\n"
"check.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_vidx(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_vidx(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QgsVertexId*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsVertexId(sipCpp->vidx());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsVertexId,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_vidx, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_status, "status(self) -> QgsGeometryCheckError.Status\n"
"The status of the error.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_status(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_status(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QgsGeometryCheckError::Status sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->status();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsGeometryCheckError_Status);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_status, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_resolutionMessage, "resolutionMessage(self) -> str\n"
"A message with details, how the error has been resolved.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_resolutionMessage(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_resolutionMessage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->resolutionMessage());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_resolutionMessage, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_setFixed, "setFixed(self, method: int)\n"
"Set the status to fixed and specify the ``method`` that has been used to\n"
"fix the error.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_setFixed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_setFixed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
         ::QgsGeometryCheckError *sipCpp;

        static const char *sipKwdList[] = {
            sipName_method,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setFixed(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_setFixed, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_setFixFailed, "setFixFailed(self, reason: str)\n"
"Set the error status to failed and specify the ``reason`` for failure.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_setFixFailed(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_setFixFailed(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QgsGeometryCheckError *sipCpp;

        static const char *sipKwdList[] = {
            sipName_reason,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp, sipType_QString,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setFixFailed(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_setFixFailed, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_setObsolete, "setObsolete(self)\n"
"Set the error status to obsolete.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_setObsolete(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_setObsolete(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setObsolete();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_setObsolete, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_isEqual, "isEqual(self, other: QgsGeometryCheckError) -> bool\n"
"Check if this error is equal to ``other``.\n"
"Is reimplemented by subclasses with additional information, comparison\n"
"of base information is done in parent class.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_isEqual(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_isEqual(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QgsGeometryCheckError* a0;
        const  ::QgsGeometryCheckError *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp, sipType_QgsGeometryCheckError, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsGeometryCheckError::isEqual(a0) : sipCpp->isEqual(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_isEqual, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_closeMatch, "closeMatch(self, QgsGeometryCheckError) -> bool\n"
"Check if this error is almost equal to ``other``.\n"
"If this returns ``True``, it can be used to update existing errors after re-checking.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_closeMatch(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_closeMatch(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QgsGeometryCheckError* a0;
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp, sipType_QgsGeometryCheckError, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsGeometryCheckError::closeMatch(a0) : sipCpp->closeMatch(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_closeMatch, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_update, "update(self, other: QgsGeometryCheckError)\n"
"Update this error with the information from ``other``.\n"
"Will be used to update existing errors whenever they are re-checked.");

extern "C" {static PyObject *meth_QgsGeometryCheckError_update(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_update(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsGeometryCheckError* a0;
         ::QgsGeometryCheckError *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp, sipType_QgsGeometryCheckError, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsGeometryCheckError::update(a0) : sipCpp->update(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_update, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGeometryCheckError_icon, "icon(self) -> QIcon\n"
"Returns an icon that should be shown for this kind of error.\n"
"\n"
".. versionadded:: 3.8");

extern "C" {static PyObject *meth_QgsGeometryCheckError_icon(PyObject *, PyObject *);}
static PyObject *meth_QgsGeometryCheckError_icon(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsGeometryCheckError *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGeometryCheckError, &sipCpp))
        {
             ::QIcon*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QIcon((sipSelfWasArg ? sipCpp-> ::QgsGeometryCheckError::icon() : sipCpp->icon()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QIcon,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGeometryCheckError, sipName_icon, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGeometryCheckError(void *, int);}
static void release_QgsGeometryCheckError(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsGeometryCheckError *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsGeometryCheckError *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGeometryCheckError(sipSimpleWrapper *);}
static void dealloc_QgsGeometryCheckError(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsGeometryCheckError *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGeometryCheckError(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsGeometryCheckError(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGeometryCheckError(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsGeometryCheckError *sipCpp = 0;

    {
        const  ::QgsGeometryCheck* a0;
        const  ::QgsGeometryCheckerUtils::LayerFeature* a1;
        const  ::QgsPointXY* a2;
         ::QgsVertexId a3def = QgsVertexId();
         ::QgsVertexId* a3 = &a3def;
        const  ::QVariant& a4def = QVariant();
        const  ::QVariant* a4 = &a4def;
        int a4State = 0;
         ::QgsGeometryCheckError::ValueType a5 =  ::QgsGeometryCheckError::ValueOther;

        static const char *sipKwdList[] = {
            sipName_check,
            sipName_layerFeature,
            sipName_errorLocation,
            sipName_vidx,
            sipName_value,
            sipName_valueType,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J9J9|J9J1E", sipType_QgsGeometryCheck, &a0, sipType_QgsGeometryCheckerUtils_LayerFeature, &a1, sipType_QgsPointXY, &a2, sipType_QgsVertexId, &a3, sipType_QVariant, &a4, &a4State, sipType_QgsGeometryCheckError_ValueType, &a5))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometryCheckError(a0,*a1,*a2,*a3,*a4,a5);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QVariant *>(a4),sipType_QVariant,a4State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QVariant *>(a4),sipType_QVariant,a4State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsGeometryCheck* a0;
        const  ::QString* a1;
        int a1State = 0;
         ::QgsFeatureId a2;
        const  ::QgsGeometry* a3;
        const  ::QgsPointXY* a4;
         ::QgsVertexId a5def = QgsVertexId();
         ::QgsVertexId* a5 = &a5def;
        const  ::QVariant& a6def = QVariant();
        const  ::QVariant* a6 = &a6def;
        int a6State = 0;
         ::QgsGeometryCheckError::ValueType a7 =  ::QgsGeometryCheckError::ValueOther;

        static const char *sipKwdList[] = {
            sipName_check,
            sipName_layerId,
            sipName_featureId,
            sipName_geometry,
            sipName_errorLocation,
            sipName_vidx,
            sipName_value,
            sipName_valueType,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8J1nJ9J9|J9J1E", sipType_QgsGeometryCheck, &a0, sipType_QString,&a1, &a1State, &a2, sipType_QgsGeometry, &a3, sipType_QgsPointXY, &a4, sipType_QgsVertexId, &a5, sipType_QVariant, &a6, &a6State, sipType_QgsGeometryCheckError_ValueType, &a7))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometryCheckError(a0,*a1,a2,*a3,*a4,*a5,*a6,a7);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QVariant *>(a6),sipType_QVariant,a6State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(const_cast< ::QVariant *>(a6),sipType_QVariant,a6State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsGeometryCheckError* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGeometryCheckError, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGeometryCheckError(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGeometryCheckError[] = {
    {SIP_MLNAME_CAST(sipName_affectedAreaBBox), meth_QgsGeometryCheckError_affectedAreaBBox, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_affectedAreaBBox)},
    {SIP_MLNAME_CAST(sipName_check), meth_QgsGeometryCheckError_check, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_check)},
    {SIP_MLNAME_CAST(sipName_closeMatch), meth_QgsGeometryCheckError_closeMatch, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_closeMatch)},
    {SIP_MLNAME_CAST(sipName_description), meth_QgsGeometryCheckError_description, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_description)},
    {SIP_MLNAME_CAST(sipName_featureId), meth_QgsGeometryCheckError_featureId, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_featureId)},
    {SIP_MLNAME_CAST(sipName_geometry), meth_QgsGeometryCheckError_geometry, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_geometry)},
    {SIP_MLNAME_CAST(sipName_icon), meth_QgsGeometryCheckError_icon, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_icon)},
    {SIP_MLNAME_CAST(sipName_isEqual), (PyCFunction)meth_QgsGeometryCheckError_isEqual, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_isEqual)},
    {SIP_MLNAME_CAST(sipName_layerId), meth_QgsGeometryCheckError_layerId, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_layerId)},
    {SIP_MLNAME_CAST(sipName_location), meth_QgsGeometryCheckError_location, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_location)},
    {SIP_MLNAME_CAST(sipName_resolutionMessage), meth_QgsGeometryCheckError_resolutionMessage, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_resolutionMessage)},
    {SIP_MLNAME_CAST(sipName_setFixFailed), (PyCFunction)meth_QgsGeometryCheckError_setFixFailed, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_setFixFailed)},
    {SIP_MLNAME_CAST(sipName_setFixed), (PyCFunction)meth_QgsGeometryCheckError_setFixed, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_setFixed)},
    {SIP_MLNAME_CAST(sipName_setObsolete), meth_QgsGeometryCheckError_setObsolete, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_setObsolete)},
    {SIP_MLNAME_CAST(sipName_status), meth_QgsGeometryCheckError_status, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_status)},
    {SIP_MLNAME_CAST(sipName_update), (PyCFunction)meth_QgsGeometryCheckError_update, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_update)},
    {SIP_MLNAME_CAST(sipName_value), meth_QgsGeometryCheckError_value, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_value)},
    {SIP_MLNAME_CAST(sipName_valueType), meth_QgsGeometryCheckError_valueType, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_valueType)},
    {SIP_MLNAME_CAST(sipName_vidx), meth_QgsGeometryCheckError_vidx, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGeometryCheckError_vidx)}
};

static sipEnumMemberDef enummembers_QgsGeometryCheckError[] = {
    {sipName_StatusFixFailed, static_cast<int>( ::QgsGeometryCheckError::StatusFixFailed), 31},
    {sipName_StatusFixed, static_cast<int>( ::QgsGeometryCheckError::StatusFixed), 31},
    {sipName_StatusObsolete, static_cast<int>( ::QgsGeometryCheckError::StatusObsolete), 31},
    {sipName_StatusPending, static_cast<int>( ::QgsGeometryCheckError::StatusPending), 31},
    {sipName_ValueArea, static_cast<int>( ::QgsGeometryCheckError::ValueArea), 32},
    {sipName_ValueLength, static_cast<int>( ::QgsGeometryCheckError::ValueLength), 32},
    {sipName_ValueOther, static_cast<int>( ::QgsGeometryCheckError::ValueOther), 32},
};

PyDoc_STRVAR(doc_QgsGeometryCheckError, "QgsGeometryCheckError(check: QgsGeometryCheck, layerFeature: QgsGeometryCheckerUtils.LayerFeature, errorLocation: QgsPointXY, vidx: QgsVertexId = QgsVertexId(), value: Any = None, valueType: QgsGeometryCheckError.ValueType = QgsGeometryCheckError.ValueOther)\n"
"Create a new geometry check error with the parent ``check`` and for the\n"
"``layerFeature`` pair at the ``errorLocation``. Optionally the vertex can be\n"
"specified via ``vixd`` and a ``value`` with its ``value`` Type for\n"
"additional information.\n"
"\n"
"QgsGeometryCheckError(check: QgsGeometryCheck, layerId: str, featureId: int, geometry: QgsGeometry, errorLocation: QgsPointXY, vidx: QgsVertexId = QgsVertexId(), value: Any = None, valueType: QgsGeometryCheckError.ValueType = QgsGeometryCheckError.ValueOther)\n"
"Create a new geometry check error with the parent ``check`` and for the\n"
"layer with ``layerId`` and ``featureId``.\n"
"The ``geometry`` of the error and the ``errorLocation`` need to be\n"
"specified in map coordinates.\n"
"Optionally the vertex can be specified via ``vixd`` and a ``value`` with\n"
"its ``value`` Type for additional information.\n"
"\n"
"QgsGeometryCheckError(QgsGeometryCheckError)\n"
"\n"
"This represents an error reported by a geometry check.\n"
"\n"
".. note::\n"
"\n"
"   This class is a technology preview and unstable API.\n"
"\n"
".. versionadded:: 3.4");


static pyqt5ClassPluginDef plugin_QgsGeometryCheckError = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGeometryCheckError = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGeometryCheckError,
        {0},
        &plugin_QgsGeometryCheckError
    },
    {
        sipNameNr_QgsGeometryCheckError,
        {0, 0, 1},
        19, methods_QgsGeometryCheckError,
        7, enummembers_QgsGeometryCheckError,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGeometryCheckError,
    -1,
    -1,
    0,
    0,
    init_type_QgsGeometryCheckError,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGeometryCheckError,
    0,
    0,
    0,
    release_QgsGeometryCheckError,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsvectorlayerdirector.sip"
#include "qgsvectorlayerdirector.h"
#line 3400 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 22 "core/auto_generated/qgsfeaturesource.sip"
#include "qgsfeaturesource.h"
#line 3404 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 3407 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 25 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraphbuilderinterface.sip"
#include "qgsgraphbuilderinterface.h"
#line 3410 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 3413 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 3416 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 3419 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 30 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsnetworkstrategy.sip"
#include "qgsnetworkstrategy.h"
#line 3422 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 3425 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3428 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 247 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3431 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 235 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 3434 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
#include <qobject.h>
#line 3437 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 3440 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3443 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 30 "/usr/share/sip/PyQt5/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 3446 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 149 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 3449 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3452 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qthread.sip"
#include <qthread.h>
#line 3455 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 3458 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qregexp.sip"
#include <qregexp.h>
#line 3461 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 3464 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 3467 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsVectorLayerDirector : public  ::QgsVectorLayerDirector
{
public:
    sipQgsVectorLayerDirector( ::QgsFeatureSource*,int,const  ::QString&,const  ::QString&,const  ::QString&, ::QgsVectorLayerDirector::Direction);
    virtual ~sipQgsVectorLayerDirector();

    int qt_metacall(QMetaObject::Call,int,void **);
    void *qt_metacast(const char *);
    const QMetaObject *metaObject() const;

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::QObject* sipProtect_sender() const;
    int sipProtect_receivers(const char*) const;
    void sipProtectVirt_timerEvent(bool, ::QTimerEvent*);
    void sipProtectVirt_childEvent(bool, ::QChildEvent*);
    void sipProtectVirt_customEvent(bool, ::QEvent*);
    void sipProtectVirt_connectNotify(bool,const  ::QMetaMethod&);
    void sipProtectVirt_disconnectNotify(bool,const  ::QMetaMethod&);
    int sipProtect_senderSignalIndex() const;
    bool sipProtect_isSignalConnected(const  ::QMetaMethod&) const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&);
    void connectNotify(const  ::QMetaMethod&);
    void customEvent( ::QEvent*);
    void childEvent( ::QChildEvent*);
    void timerEvent( ::QTimerEvent*);
    bool eventFilter( ::QObject*, ::QEvent*);
    bool event( ::QEvent*);
    void makeGraph( ::QgsGraphBuilderInterface*,const QVector< ::QgsPointXY>&,QVector< ::QgsPointXY>&, ::QgsFeedback*) const;
     ::QString name() const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsVectorLayerDirector(const sipQgsVectorLayerDirector &);
    sipQgsVectorLayerDirector &operator = (const sipQgsVectorLayerDirector &);

    char sipPyMethods[9];
};

sipQgsVectorLayerDirector::sipQgsVectorLayerDirector( ::QgsFeatureSource*a0,int a1,const  ::QString& a2,const  ::QString& a3,const  ::QString& a4, ::QgsVectorLayerDirector::Direction a5):  ::QgsVectorLayerDirector(a0,a1,a2,a3,a4,a5), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsVectorLayerDirector::~sipQgsVectorLayerDirector()
{
    sipInstanceDestroyed(sipPySelf);
}

const QMetaObject *sipQgsVectorLayerDirector::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip__analysis_qt_metaobject(sipPySelf,sipType_QgsVectorLayerDirector);

    return  ::QgsVectorLayerDirector::metaObject();
}

int sipQgsVectorLayerDirector::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QgsVectorLayerDirector::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip__analysis_qt_metacall(sipPySelf,sipType_QgsVectorLayerDirector,_c,_id,_a);

    return _id;
}

void *sipQgsVectorLayerDirector::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip__analysis_qt_metacast(sipPySelf, sipType_QgsVectorLayerDirector, _clname, &sipCpp) ? sipCpp :  ::QgsVectorLayerDirector::qt_metacast(_clname));
}

void sipQgsVectorLayerDirector::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QgsVectorLayerDirector::disconnectNotify(a0);
        return;
    }

    extern void sipVH__analysis_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH__analysis_2(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsVectorLayerDirector::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QgsVectorLayerDirector::connectNotify(a0);
        return;
    }

    extern void sipVH__analysis_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH__analysis_2(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsVectorLayerDirector::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_customEvent);

    if (!sipMeth)
    {
         ::QgsVectorLayerDirector::customEvent(a0);
        return;
    }

    extern void sipVH__analysis_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH__analysis_3(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsVectorLayerDirector::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_childEvent);

    if (!sipMeth)
    {
         ::QgsVectorLayerDirector::childEvent(a0);
        return;
    }

    extern void sipVH__analysis_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH__analysis_4(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsVectorLayerDirector::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QgsVectorLayerDirector::timerEvent(a0);
        return;
    }

    extern void sipVH__analysis_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH__analysis_5(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQgsVectorLayerDirector::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_eventFilter);

    if (!sipMeth)
        return  ::QgsVectorLayerDirector::eventFilter(a0,a1);

    extern bool sipVH__analysis_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH__analysis_6(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

bool sipQgsVectorLayerDirector::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_event);

    if (!sipMeth)
        return  ::QgsVectorLayerDirector::event(a0);

    extern bool sipVH__analysis_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH__analysis_7(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsVectorLayerDirector::makeGraph( ::QgsGraphBuilderInterface*a0,const QVector< ::QgsPointXY>& a1,QVector< ::QgsPointXY>& a2, ::QgsFeedback*a3) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[7]),sipPySelf,NULL,sipName_makeGraph);

    if (!sipMeth)
    {
         ::QgsVectorLayerDirector::makeGraph(a0,a1,a2,a3);
        return;
    }

    extern void sipVH__analysis_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QgsGraphBuilderInterface*,const QVector< ::QgsPointXY>&,QVector< ::QgsPointXY>&, ::QgsFeedback*);

    sipVH__analysis_19(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

 ::QString sipQgsVectorLayerDirector::name() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[8]),sipPySelf,NULL,sipName_name);

    if (!sipMeth)
        return  ::QgsVectorLayerDirector::name();

    extern  ::QString sipVH__analysis_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_20(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QObject* sipQgsVectorLayerDirector::sipProtect_sender() const
{
    return  ::QObject::sender();
}

int sipQgsVectorLayerDirector::sipProtect_receivers(const char*a0) const
{
    return  ::QObject::receivers(a0);
}

void sipQgsVectorLayerDirector::sipProtectVirt_timerEvent(bool sipSelfWasArg, ::QTimerEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::timerEvent(a0) : timerEvent(a0));
}

void sipQgsVectorLayerDirector::sipProtectVirt_childEvent(bool sipSelfWasArg, ::QChildEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::childEvent(a0) : childEvent(a0));
}

void sipQgsVectorLayerDirector::sipProtectVirt_customEvent(bool sipSelfWasArg, ::QEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::customEvent(a0) : customEvent(a0));
}

void sipQgsVectorLayerDirector::sipProtectVirt_connectNotify(bool sipSelfWasArg,const  ::QMetaMethod& a0)
{
    (sipSelfWasArg ?  ::QObject::connectNotify(a0) : connectNotify(a0));
}

void sipQgsVectorLayerDirector::sipProtectVirt_disconnectNotify(bool sipSelfWasArg,const  ::QMetaMethod& a0)
{
    (sipSelfWasArg ?  ::QObject::disconnectNotify(a0) : disconnectNotify(a0));
}

int sipQgsVectorLayerDirector::sipProtect_senderSignalIndex() const
{
    return  ::QObject::senderSignalIndex();
}

bool sipQgsVectorLayerDirector::sipProtect_isSignalConnected(const  ::QMetaMethod& a0) const
{
    return  ::QObject::isSignalConnected(a0);
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_sender, "sender(self) -> QObject");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_sender(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_sender(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp))
        {
             ::QObject*sipRes = 0;

#line 560 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL and Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        if (!sipRes)
        {
            typedef QObject *(*qtcore_qobject_sender_t)();
        
            static qtcore_qobject_sender_t qtcore_qobject_sender = 0;
        
            if (!qtcore_qobject_sender)
            {
                qtcore_qobject_sender = (qtcore_qobject_sender_t)sipImportSymbol("qtcore_qobject_sender");
                Q_ASSERT(qtcore_qobject_sender);
            }
        
            sipRes = qtcore_qobject_sender();
        }
#line 3796 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_sender, doc_QgsVectorLayerDirector_sender);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_receivers, "receivers(self, PYQT_SIGNAL) -> int");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_receivers(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_receivers(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BP0", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, &a0))
        {
            int sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 591 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
        // We need to handle the signal object.  Import the helper if it hasn't already
        // been done.
        typedef sipErrorState (*pyqt5_get_signal_signature_t)(PyObject *, const QObject *, const QByteArray &);
        
        static pyqt5_get_signal_signature_t pyqt5_get_signal_signature = 0;
        
        if (!pyqt5_get_signal_signature)
        {
            pyqt5_get_signal_signature = (pyqt5_get_signal_signature_t)sipImportSymbol("pyqt5_get_signal_signature");
            Q_ASSERT(pyqt5_get_signal_signature);
        }
        
        QByteArray signal_signature;
            
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        if ((sipError = pyqt5_get_signal_signature(a0, sipCpp, signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->receivers(signal_signature.constData());
        }
        #else
        if ((sipError = pyqt5_get_signal_signature(a0, static_cast<const QObject *>(sipCpp), signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->sipProtect_receivers(signal_signature.constData());
        }
        #endif
        else if (sipError == sipErrorContinue)
        {
            sipError = sipBadCallableArg(0, a0);
        }
#line 3856 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return SIPLong_FromLong(sipRes);
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_receivers, doc_QgsVectorLayerDirector_receivers);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_timerEvent, "timerEvent(self, QTimerEvent)");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_timerEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_timerEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QTimerEvent* a0;
        sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, sipType_QTimerEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_timerEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_timerEvent, doc_QgsVectorLayerDirector_timerEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_childEvent, "childEvent(self, QChildEvent)");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_childEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_childEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QChildEvent* a0;
        sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, sipType_QChildEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_childEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_childEvent, doc_QgsVectorLayerDirector_childEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_customEvent, "customEvent(self, QEvent)");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_customEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_customEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QEvent* a0;
        sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, sipType_QEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_customEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_customEvent, doc_QgsVectorLayerDirector_customEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_connectNotify, "connectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_connectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_connectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
        sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, sipType_QMetaMethod, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_connectNotify(sipSelfWasArg,*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_connectNotify, doc_QgsVectorLayerDirector_connectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_disconnectNotify, "disconnectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_disconnectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
        sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, sipType_QMetaMethod, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_disconnectNotify(sipSelfWasArg,*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_disconnectNotify, doc_QgsVectorLayerDirector_disconnectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_senderSignalIndex, "senderSignalIndex(self) -> int");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_senderSignalIndex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_senderSignalIndex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_senderSignalIndex();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_senderSignalIndex, doc_QgsVectorLayerDirector_senderSignalIndex);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_isSignalConnected, "isSignalConnected(self, QMetaMethod) -> bool");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_isSignalConnected(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_isSignalConnected(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QMetaMethod* a0;
        const sipQgsVectorLayerDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, sipType_QMetaMethod, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_isSignalConnected(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_isSignalConnected, doc_QgsVectorLayerDirector_isSignalConnected);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_makeGraph, "makeGraph(self, builder: QgsGraphBuilderInterface, additionalPoints: Iterable[QgsPointXY], feedback: QgsFeedback = None) -> List[QgsPointXY]\n"
"MANDATORY DIRECTOR PROPERTY DECLARATION");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_makeGraph(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_makeGraph(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QgsGraphBuilderInterface* a0;
        const QVector< ::QgsPointXY>* a1;
        int a1State = 0;
        QVector< ::QgsPointXY>* a2;
         ::QgsFeedback* a3 = 0;
        const  ::QgsVectorLayerDirector *sipCpp;

        static const char *sipKwdList[] = {
            sipName_builder,
            sipName_additionalPoints,
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J1|J8", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp, sipType_QgsGraphBuilderInterface, &a0, sipType_QVector_0100QgsPointXY,&a1, &a1State, sipType_QgsFeedback, &a3))
        {
            a2 = new QVector< ::QgsPointXY>();

            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsVectorLayerDirector::makeGraph(a0,*a1,*a2,a3) : sipCpp->makeGraph(a0,*a1,*a2,a3));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                delete a2;
            sipReleaseType(const_cast<QVector< ::QgsPointXY> *>(a1),sipType_QVector_0100QgsPointXY,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QVector< ::QgsPointXY> *>(a1),sipType_QVector_0100QgsPointXY,a1State);

            return sipConvertFromNewType(a2,sipType_QVector_0100QgsPointXY,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_makeGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsVectorLayerDirector_name, "name(self) -> str");

extern "C" {static PyObject *meth_QgsVectorLayerDirector_name(PyObject *, PyObject *);}
static PyObject *meth_QgsVectorLayerDirector_name(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsVectorLayerDirector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsVectorLayerDirector, &sipCpp))
        {
             ::QString*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString((sipSelfWasArg ? sipCpp-> ::QgsVectorLayerDirector::name() : sipCpp->name()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsVectorLayerDirector, sipName_name, doc_QgsVectorLayerDirector_name);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsVectorLayerDirector(void *, const sipTypeDef *);}
static void *cast_QgsVectorLayerDirector(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsVectorLayerDirector *sipCpp = reinterpret_cast< ::QgsVectorLayerDirector *>(sipCppV);

    if (targetType == sipType_QgsGraphDirector)
        return static_cast< ::QgsGraphDirector *>(sipCpp);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsVectorLayerDirector(void *, int);}
static void release_QgsVectorLayerDirector(void *sipCppV, int)
{
     ::QgsVectorLayerDirector *sipCpp = reinterpret_cast< ::QgsVectorLayerDirector *>(sipCppV);

    Py_BEGIN_ALLOW_THREADS

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsVectorLayerDirector(sipSimpleWrapper *);}
static void dealloc_QgsVectorLayerDirector(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsVectorLayerDirector *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsVectorLayerDirector(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsVectorLayerDirector(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsVectorLayerDirector(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsVectorLayerDirector *sipCpp = 0;

    {
         ::QgsFeatureSource* a0;
        int a1;
        const  ::QString* a2;
        int a2State = 0;
        const  ::QString* a3;
        int a3State = 0;
        const  ::QString* a4;
        int a4State = 0;
         ::QgsVectorLayerDirector::Direction a5;

        static const char *sipKwdList[] = {
            sipName_source,
            sipName_directionFieldId,
            sipName_directDirectionValue,
            sipName_reverseDirectionValue,
            sipName_bothDirectionValue,
            sipName_defaultDirection,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8iJ1J1J1E", sipType_QgsFeatureSource, &a0, &a1, sipType_QString,&a2, &a2State, sipType_QString,&a3, &a3State, sipType_QString,&a4, &a4State, sipType_QgsVectorLayerDirector_Direction, &a5))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsVectorLayerDirector(a0,a1,*a2,*a3,*a4,a5);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast< ::QString *>(a3),sipType_QString,a3State);
            sipReleaseType(const_cast< ::QString *>(a4),sipType_QString,a4State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a2),sipType_QString,a2State);
            sipReleaseType(const_cast< ::QString *>(a3),sipType_QString,a3State);
            sipReleaseType(const_cast< ::QString *>(a4),sipType_QString,a4State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsVectorLayerDirector[] = {{46, 255, 1}};


static PyMethodDef methods_QgsVectorLayerDirector[] = {
    {SIP_MLNAME_CAST(sipName_childEvent), (PyCFunction)meth_QgsVectorLayerDirector_childEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_connectNotify), (PyCFunction)meth_QgsVectorLayerDirector_connectNotify, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_customEvent), (PyCFunction)meth_QgsVectorLayerDirector_customEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), (PyCFunction)meth_QgsVectorLayerDirector_disconnectNotify, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_isSignalConnected), (PyCFunction)meth_QgsVectorLayerDirector_isSignalConnected, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_makeGraph), (PyCFunction)meth_QgsVectorLayerDirector_makeGraph, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsVectorLayerDirector_makeGraph)},
    {SIP_MLNAME_CAST(sipName_name), meth_QgsVectorLayerDirector_name, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsVectorLayerDirector_name)},
    {SIP_MLNAME_CAST(sipName_receivers), (PyCFunction)meth_QgsVectorLayerDirector_receivers, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_sender), (PyCFunction)meth_QgsVectorLayerDirector_sender, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_senderSignalIndex), (PyCFunction)meth_QgsVectorLayerDirector_senderSignalIndex, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_timerEvent), (PyCFunction)meth_QgsVectorLayerDirector_timerEvent, METH_VARARGS|METH_KEYWORDS, NULL}
};

static sipEnumMemberDef enummembers_QgsVectorLayerDirector[] = {
    {sipName_DirectionBackward, static_cast<int>( ::QgsVectorLayerDirector::DirectionBackward), 90},
    {sipName_DirectionBoth, static_cast<int>( ::QgsVectorLayerDirector::DirectionBoth), 90},
    {sipName_DirectionForward, static_cast<int>( ::QgsVectorLayerDirector::DirectionForward), 90},
};

PyDoc_STRVAR(doc_QgsVectorLayerDirector, "QgsVectorLayerDirector(source: QgsFeatureSource, directionFieldId: int, directDirectionValue: str, reverseDirectionValue: str, bothDirectionValue: str, defaultDirection: QgsVectorLayerDirector.Direction)\n"
"Default constructor\n"
"\n"
":param source: feature source representing network\n"
":param directionFieldId: field containing direction value\n"
":param directDirectionValue: value for direct one-way road\n"
":param reverseDirectionValue: value for reversed one-way road\n"
":param bothDirectionValue: value for two-way (bidirectional) road\n"
":param defaultDirection: default direction. Will be used if corresponding\n"
"                         attribute value is not set or does not equal to the given values\n"
"\n"
"Determine making the graph from vector line layer\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsVectorLayerDirector = {
    & ::QgsVectorLayerDirector::staticMetaObject,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsVectorLayerDirector = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsVectorLayerDirector,
        {0},
        &plugin_QgsVectorLayerDirector
    },
    {
        sipNameNr_QgsVectorLayerDirector,
        {0, 0, 1},
        11, methods_QgsVectorLayerDirector,
        3, enummembers_QgsVectorLayerDirector,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsVectorLayerDirector,
    -1,
    -1,
    supers_QgsVectorLayerDirector,
    0,
    init_type_QgsVectorLayerDirector,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsVectorLayerDirector,
    0,
    0,
    0,
    release_QgsVectorLayerDirector,
    cast_QgsVectorLayerDirector,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 25 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraphdirector.sip"
#include "qgsgraphdirector.h"
#line 4463 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 4467 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 30 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsnetworkstrategy.sip"
#include "qgsnetworkstrategy.h"
#line 4470 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 25 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraphbuilderinterface.sip"
#include "qgsgraphbuilderinterface.h"
#line 4473 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 4476 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 4479 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 4482 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 4485 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4488 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 247 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4491 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 235 "/usr/share/sip/PyQt5/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 4494 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
#include <qobject.h>
#line 4497 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 4500 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4503 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 30 "/usr/share/sip/PyQt5/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 4506 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 149 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 4509 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4512 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qthread.sip"
#include <qthread.h>
#line 4515 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 4518 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qregexp.sip"
#include <qregexp.h>
#line 4521 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 4524 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 4527 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsGraphDirector : public  ::QgsGraphDirector
{
public:
    sipQgsGraphDirector();
    virtual ~sipQgsGraphDirector();

    int qt_metacall(QMetaObject::Call,int,void **);
    void *qt_metacast(const char *);
    const QMetaObject *metaObject() const;

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::QObject* sipProtect_sender() const;
    int sipProtect_receivers(const char*) const;
    void sipProtectVirt_timerEvent(bool, ::QTimerEvent*);
    void sipProtectVirt_childEvent(bool, ::QChildEvent*);
    void sipProtectVirt_customEvent(bool, ::QEvent*);
    void sipProtectVirt_connectNotify(bool,const  ::QMetaMethod&);
    void sipProtectVirt_disconnectNotify(bool,const  ::QMetaMethod&);
    int sipProtect_senderSignalIndex() const;
    bool sipProtect_isSignalConnected(const  ::QMetaMethod&) const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QString name() const;
    void makeGraph( ::QgsGraphBuilderInterface*,const QVector< ::QgsPointXY>&,QVector< ::QgsPointXY>&, ::QgsFeedback*) const;
    bool event( ::QEvent*);
    bool eventFilter( ::QObject*, ::QEvent*);
    void timerEvent( ::QTimerEvent*);
    void childEvent( ::QChildEvent*);
    void customEvent( ::QEvent*);
    void connectNotify(const  ::QMetaMethod&);
    void disconnectNotify(const  ::QMetaMethod&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsGraphDirector(const sipQgsGraphDirector &);
    sipQgsGraphDirector &operator = (const sipQgsGraphDirector &);

    char sipPyMethods[9];
};

sipQgsGraphDirector::sipQgsGraphDirector():  ::QgsGraphDirector(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGraphDirector::~sipQgsGraphDirector()
{
    sipInstanceDestroyed(sipPySelf);
}

const QMetaObject *sipQgsGraphDirector::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip__analysis_qt_metaobject(sipPySelf,sipType_QgsGraphDirector);

    return  ::QgsGraphDirector::metaObject();
}

int sipQgsGraphDirector::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QgsGraphDirector::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip__analysis_qt_metacall(sipPySelf,sipType_QgsGraphDirector,_c,_id,_a);

    return _id;
}

void *sipQgsGraphDirector::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip__analysis_qt_metacast(sipPySelf, sipType_QgsGraphDirector, _clname, &sipCpp) ? sipCpp :  ::QgsGraphDirector::qt_metacast(_clname));
}

 ::QString sipQgsGraphDirector::name() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,sipName_QgsGraphDirector,sipName_name);

    if (!sipMeth)
        return  ::QString();

    extern  ::QString sipVH__analysis_20(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_20(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

void sipQgsGraphDirector::makeGraph( ::QgsGraphBuilderInterface*a0,const QVector< ::QgsPointXY>& a1,QVector< ::QgsPointXY>& a2, ::QgsFeedback*a3) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_makeGraph);

    if (!sipMeth)
    {
         ::QgsGraphDirector::makeGraph(a0,a1,a2,a3);
        return;
    }

    extern void sipVH__analysis_19(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QgsGraphBuilderInterface*,const QVector< ::QgsPointXY>&,QVector< ::QgsPointXY>&, ::QgsFeedback*);

    sipVH__analysis_19(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

bool sipQgsGraphDirector::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_event);

    if (!sipMeth)
        return  ::QgsGraphDirector::event(a0);

    extern bool sipVH__analysis_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH__analysis_7(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

bool sipQgsGraphDirector::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_eventFilter);

    if (!sipMeth)
        return  ::QgsGraphDirector::eventFilter(a0,a1);

    extern bool sipVH__analysis_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH__analysis_6(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQgsGraphDirector::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QgsGraphDirector::timerEvent(a0);
        return;
    }

    extern void sipVH__analysis_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH__analysis_5(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGraphDirector::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_childEvent);

    if (!sipMeth)
    {
         ::QgsGraphDirector::childEvent(a0);
        return;
    }

    extern void sipVH__analysis_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH__analysis_4(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGraphDirector::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_customEvent);

    if (!sipMeth)
    {
         ::QgsGraphDirector::customEvent(a0);
        return;
    }

    extern void sipVH__analysis_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH__analysis_3(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGraphDirector::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[7],sipPySelf,NULL,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QgsGraphDirector::connectNotify(a0);
        return;
    }

    extern void sipVH__analysis_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH__analysis_2(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

void sipQgsGraphDirector::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,NULL,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QgsGraphDirector::disconnectNotify(a0);
        return;
    }

    extern void sipVH__analysis_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH__analysis_2(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0);
}

 ::QObject* sipQgsGraphDirector::sipProtect_sender() const
{
    return  ::QObject::sender();
}

int sipQgsGraphDirector::sipProtect_receivers(const char*a0) const
{
    return  ::QObject::receivers(a0);
}

void sipQgsGraphDirector::sipProtectVirt_timerEvent(bool sipSelfWasArg, ::QTimerEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::timerEvent(a0) : timerEvent(a0));
}

void sipQgsGraphDirector::sipProtectVirt_childEvent(bool sipSelfWasArg, ::QChildEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::childEvent(a0) : childEvent(a0));
}

void sipQgsGraphDirector::sipProtectVirt_customEvent(bool sipSelfWasArg, ::QEvent*a0)
{
    (sipSelfWasArg ?  ::QObject::customEvent(a0) : customEvent(a0));
}

void sipQgsGraphDirector::sipProtectVirt_connectNotify(bool sipSelfWasArg,const  ::QMetaMethod& a0)
{
    (sipSelfWasArg ?  ::QObject::connectNotify(a0) : connectNotify(a0));
}

void sipQgsGraphDirector::sipProtectVirt_disconnectNotify(bool sipSelfWasArg,const  ::QMetaMethod& a0)
{
    (sipSelfWasArg ?  ::QObject::disconnectNotify(a0) : disconnectNotify(a0));
}

int sipQgsGraphDirector::sipProtect_senderSignalIndex() const
{
    return  ::QObject::senderSignalIndex();
}

bool sipQgsGraphDirector::sipProtect_isSignalConnected(const  ::QMetaMethod& a0) const
{
    return  ::QObject::isSignalConnected(a0);
}


PyDoc_STRVAR(doc_QgsGraphDirector_sender, "sender(self) -> QObject");

extern "C" {static PyObject *meth_QgsGraphDirector_sender(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_sender(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsGraphDirector, &sipCpp))
        {
             ::QObject*sipRes = 0;

#line 560 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL and Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        if (!sipRes)
        {
            typedef QObject *(*qtcore_qobject_sender_t)();
        
            static qtcore_qobject_sender_t qtcore_qobject_sender = 0;
        
            if (!qtcore_qobject_sender)
            {
                qtcore_qobject_sender = (qtcore_qobject_sender_t)sipImportSymbol("qtcore_qobject_sender");
                Q_ASSERT(qtcore_qobject_sender);
            }
        
            sipRes = qtcore_qobject_sender();
        }
#line 4856 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_sender, doc_QgsGraphDirector_sender);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_receivers, "receivers(self, PYQT_SIGNAL) -> int");

extern "C" {static PyObject *meth_QgsGraphDirector_receivers(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_receivers(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BP0", &sipSelf, sipType_QgsGraphDirector, &sipCpp, &a0))
        {
            int sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 591 "/usr/share/sip/PyQt5/QtCore/qobject.sip"
        // We need to handle the signal object.  Import the helper if it hasn't already
        // been done.
        typedef sipErrorState (*pyqt5_get_signal_signature_t)(PyObject *, const QObject *, const QByteArray &);
        
        static pyqt5_get_signal_signature_t pyqt5_get_signal_signature = 0;
        
        if (!pyqt5_get_signal_signature)
        {
            pyqt5_get_signal_signature = (pyqt5_get_signal_signature_t)sipImportSymbol("pyqt5_get_signal_signature");
            Q_ASSERT(pyqt5_get_signal_signature);
        }
        
        QByteArray signal_signature;
            
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        if ((sipError = pyqt5_get_signal_signature(a0, sipCpp, signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->receivers(signal_signature.constData());
        }
        #else
        if ((sipError = pyqt5_get_signal_signature(a0, static_cast<const QObject *>(sipCpp), signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->sipProtect_receivers(signal_signature.constData());
        }
        #endif
        else if (sipError == sipErrorContinue)
        {
            sipError = sipBadCallableArg(0, a0);
        }
#line 4916 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return SIPLong_FromLong(sipRes);
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_receivers, doc_QgsGraphDirector_receivers);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_timerEvent, "timerEvent(self, QTimerEvent)");

extern "C" {static PyObject *meth_QgsGraphDirector_timerEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_timerEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QTimerEvent* a0;
        sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QTimerEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_timerEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_timerEvent, doc_QgsGraphDirector_timerEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_childEvent, "childEvent(self, QChildEvent)");

extern "C" {static PyObject *meth_QgsGraphDirector_childEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_childEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QChildEvent* a0;
        sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QChildEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_childEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_childEvent, doc_QgsGraphDirector_childEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_customEvent, "customEvent(self, QEvent)");

extern "C" {static PyObject *meth_QgsGraphDirector_customEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_customEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QEvent* a0;
        sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_customEvent(sipSelfWasArg,a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_customEvent, doc_QgsGraphDirector_customEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_connectNotify, "connectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QgsGraphDirector_connectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_connectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
        sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QMetaMethod, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_connectNotify(sipSelfWasArg,*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_connectNotify, doc_QgsGraphDirector_connectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_disconnectNotify, "disconnectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QgsGraphDirector_disconnectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
        sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QMetaMethod, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->sipProtectVirt_disconnectNotify(sipSelfWasArg,*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_disconnectNotify, doc_QgsGraphDirector_disconnectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_senderSignalIndex, "senderSignalIndex(self) -> int");

extern "C" {static PyObject *meth_QgsGraphDirector_senderSignalIndex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_senderSignalIndex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QgsGraphDirector, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_senderSignalIndex();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_senderSignalIndex, doc_QgsGraphDirector_senderSignalIndex);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_isSignalConnected, "isSignalConnected(self, QMetaMethod) -> bool");

extern "C" {static PyObject *meth_QgsGraphDirector_isSignalConnected(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_isSignalConnected(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QMetaMethod* a0;
        const sipQgsGraphDirector *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QMetaMethod, &a0))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_isSignalConnected(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_isSignalConnected, doc_QgsGraphDirector_isSignalConnected);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_makeGraph, "makeGraph(self, builder: QgsGraphBuilderInterface, additionalPoints: Iterable[QgsPointXY], feedback: QgsFeedback = None) -> List[QgsPointXY]\n"
"Make a graph using :py:class:`QgsGraphBuilder`\n"
"\n"
":param builder: the graph builder\n"
":param additionalPoints: list of points that should be snapped to the graph\n"
":param snappedPoints: list of snapped points\n"
":param feedback: feedback object for reporting progress\n"
"\n"
".. note::\n"
"\n"
"   if snappedPoints[i] == QgsPointXY(0.0,0.0) then snapping failed.");

extern "C" {static PyObject *meth_QgsGraphDirector_makeGraph(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_makeGraph(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QgsGraphBuilderInterface* a0;
        const QVector< ::QgsPointXY>* a1;
        int a1State = 0;
        QVector< ::QgsPointXY>* a2;
         ::QgsFeedback* a3 = 0;
        const  ::QgsGraphDirector *sipCpp;

        static const char *sipKwdList[] = {
            sipName_builder,
            sipName_additionalPoints,
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J1|J8", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QgsGraphBuilderInterface, &a0, sipType_QVector_0100QgsPointXY,&a1, &a1State, sipType_QgsFeedback, &a3))
        {
            a2 = new QVector< ::QgsPointXY>();

            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsGraphDirector::makeGraph(a0,*a1,*a2,a3) : sipCpp->makeGraph(a0,*a1,*a2,a3));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                delete a2;
            sipReleaseType(const_cast<QVector< ::QgsPointXY> *>(a1),sipType_QVector_0100QgsPointXY,a1State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QVector< ::QgsPointXY> *>(a1),sipType_QVector_0100QgsPointXY,a1State);

            return sipConvertFromNewType(a2,sipType_QVector_0100QgsPointXY,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_makeGraph, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_addStrategy, "addStrategy(self, prop: QgsNetworkStrategy)\n"
"Add optimization strategy");

extern "C" {static PyObject *meth_QgsGraphDirector_addStrategy(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_addStrategy(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsNetworkStrategy* a0;
         ::QgsGraphDirector *sipCpp;

        static const char *sipKwdList[] = {
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:", &sipSelf, sipType_QgsGraphDirector, &sipCpp, sipType_QgsNetworkStrategy, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->addStrategy(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_addStrategy, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphDirector_name, "name(self) -> str\n"
"Returns director name");

extern "C" {static PyObject *meth_QgsGraphDirector_name(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphDirector_name(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::QgsGraphDirector *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphDirector, &sipCpp))
        {
             ::QString*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsGraphDirector, sipName_name);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QString(sipCpp->name());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphDirector, sipName_name, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsGraphDirector(void *, const sipTypeDef *);}
static void *cast_QgsGraphDirector(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsGraphDirector *sipCpp = reinterpret_cast< ::QgsGraphDirector *>(sipCppV);

    if (targetType == sipType_QObject)
        return static_cast< ::QObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGraphDirector(void *, int);}
static void release_QgsGraphDirector(void *sipCppV, int)
{
     ::QgsGraphDirector *sipCpp = reinterpret_cast< ::QgsGraphDirector *>(sipCppV);

    Py_BEGIN_ALLOW_THREADS

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGraphDirector(sipSimpleWrapper *);}
static void dealloc_QgsGraphDirector(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsGraphDirector *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGraphDirector(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsGraphDirector(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGraphDirector(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsGraphDirector *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGraphDirector();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsGraphDirector[] = {{6, 0, 1}};


static PyMethodDef methods_QgsGraphDirector[] = {
    {SIP_MLNAME_CAST(sipName_addStrategy), (PyCFunction)meth_QgsGraphDirector_addStrategy, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphDirector_addStrategy)},
    {SIP_MLNAME_CAST(sipName_childEvent), (PyCFunction)meth_QgsGraphDirector_childEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_connectNotify), (PyCFunction)meth_QgsGraphDirector_connectNotify, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_customEvent), (PyCFunction)meth_QgsGraphDirector_customEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), (PyCFunction)meth_QgsGraphDirector_disconnectNotify, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_isSignalConnected), (PyCFunction)meth_QgsGraphDirector_isSignalConnected, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_makeGraph), (PyCFunction)meth_QgsGraphDirector_makeGraph, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphDirector_makeGraph)},
    {SIP_MLNAME_CAST(sipName_name), meth_QgsGraphDirector_name, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphDirector_name)},
    {SIP_MLNAME_CAST(sipName_receivers), (PyCFunction)meth_QgsGraphDirector_receivers, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_sender), (PyCFunction)meth_QgsGraphDirector_sender, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_senderSignalIndex), (PyCFunction)meth_QgsGraphDirector_senderSignalIndex, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_timerEvent), (PyCFunction)meth_QgsGraphDirector_timerEvent, METH_VARARGS|METH_KEYWORDS, NULL}
};

PyDoc_STRVAR(doc_QgsGraphDirector, "\n"
"\n"
"Determine making the graph. QgsGraphBuilder and QgsGraphDirector implemented\n"
"using \"builder\" design patter.");


static pyqt5ClassPluginDef plugin_QgsGraphDirector = {
    & ::QgsGraphDirector::staticMetaObject,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGraphDirector = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGraphDirector,
        {0},
        &plugin_QgsGraphDirector
    },
    {
        sipNameNr_QgsGraphDirector,
        {0, 0, 1},
        12, methods_QgsGraphDirector,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGraphDirector,
    -1,
    -1,
    supers_QgsGraphDirector,
    0,
    init_type_QgsGraphDirector,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGraphDirector,
    0,
    0,
    0,
    release_QgsGraphDirector,
    cast_QgsGraphDirector,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraphanalyzer.sip"
#include "qgsgraphanalyzer.h"
#line 5540 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 118 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraph.sip"
#include "qgsgraph.h"
#line 5544 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 328 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 5547 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 241 "/usr/share/sip/PyQt5/QtGui/qpygui_qvector.sip"
#include <qvector.h>
#line 5550 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


PyDoc_STRVAR(doc_QgsGraphAnalyzer_dijkstra, "dijkstra(source: QgsGraph, startVertexIdx: int, criterionNum: int, resultTree: Iterable[int] = [], resultCost: Iterable[float] = []) -> List\n"
"Solve shortest path problem using Dijkstra algorithm\n"
"\n"
":param source: source graph\n"
":param startVertexIdx: index of the start vertex\n"
":param criterionNum: index of the optimization strategy\n"
":param resultTree: array that represents shortest path tree. resultTree[ vertexIndex ] == inboundingArcIndex if vertex reachable, otherwise resultTree[ vertexIndex ] == -1.\n"
"                   Note that the startVertexIdx will also have a value of -1 and may need special handling by callers.\n"
":param resultCost: array of the paths costs");

extern "C" {static PyObject *meth_QgsGraphAnalyzer_dijkstra(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphAnalyzer_dijkstra(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraph* a0;
        int a1;
        int a2;
         ::QVector<int>* a3 = 0;
        int a3State = 0;
         ::QVector< ::qreal>* a4 = 0;
        int a4State = 0;

        static const char *sipKwdList[] = {
            sipName_source,
            sipName_startVertexIdx,
            sipName_criterionNum,
            sipName_resultTree,
            sipName_resultCost,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J8ii|J0J0", sipType_QgsGraph, &a0, &a1, &a2, sipType_QVector_1800,&a3, &a3State, sipType_QVector_2400,&a4, &a4State))
        {
            PyObject * sipRes = 0;

#line 39 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraphanalyzer.sip"
    QVector< int > treeResult;
    QVector< double > costResult;
    QgsGraphAnalyzer::dijkstra( a0, a1, a2, &treeResult, &costResult );

    PyObject *l1 = PyList_New( treeResult.size() );
    if ( l1 == NULL )
    {
      return NULL;
    }
    PyObject *l2 = PyList_New( costResult.size() );
    if ( l2 == NULL )
    {
      return NULL;
    }
    int i;
    for ( i = 0; i < costResult.size(); ++i )
    {
      PyObject *Int = PyLong_FromLong( treeResult[i] );
      PyList_SET_ITEM( l1, i, Int );
      PyObject *Float = PyFloat_FromDouble( costResult[i] );
      PyList_SET_ITEM( l2, i, Float );
    }

    sipRes = PyTuple_New( 2 );
    PyTuple_SET_ITEM( sipRes, 0, l1 );
    PyTuple_SET_ITEM( sipRes, 1, l2 );
#line 5617 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
            sipReleaseType(a3,sipType_QVector_1800,a3State);
            sipReleaseType(a4,sipType_QVector_2400,a4State);

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphAnalyzer, sipName_dijkstra, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphAnalyzer_shortestTree, "shortestTree(source: QgsGraph, startVertexIdx: int, criterionNum: int) -> QgsGraph\n"
"Returns shortest path tree with root-node in startVertexIdx\n"
"\n"
":param source: source graph\n"
":param startVertexIdx: index of the start vertex\n"
":param criterionNum: index of the optimization strategy");

extern "C" {static PyObject *meth_QgsGraphAnalyzer_shortestTree(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphAnalyzer_shortestTree(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraph* a0;
        int a1;
        int a2;

        static const char *sipKwdList[] = {
            sipName_source,
            sipName_startVertexIdx,
            sipName_criterionNum,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J8ii", sipType_QgsGraph, &a0, &a1, &a2))
        {
             ::QgsGraph*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes =  ::QgsGraphAnalyzer::shortestTree(a0,a1,a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QgsGraph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphAnalyzer, sipName_shortestTree, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGraphAnalyzer(void *, int);}
static void release_QgsGraphAnalyzer(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGraphAnalyzer *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsGraphAnalyzer(void *, SIP_SSIZE_T, void *);}
static void assign_QgsGraphAnalyzer(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsGraphAnalyzer *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsGraphAnalyzer *>(sipSrc);
}


extern "C" {static void *array_QgsGraphAnalyzer(SIP_SSIZE_T);}
static void *array_QgsGraphAnalyzer(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsGraphAnalyzer[sipNrElem];
}


extern "C" {static void *copy_QgsGraphAnalyzer(const void *, SIP_SSIZE_T);}
static void *copy_QgsGraphAnalyzer(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsGraphAnalyzer(reinterpret_cast<const  ::QgsGraphAnalyzer *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsGraphAnalyzer(sipSimpleWrapper *);}
static void dealloc_QgsGraphAnalyzer(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGraphAnalyzer(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGraphAnalyzer(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGraphAnalyzer(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGraphAnalyzer *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraphAnalyzer();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsGraphAnalyzer* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGraphAnalyzer, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraphAnalyzer(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGraphAnalyzer[] = {
    {SIP_MLNAME_CAST(sipName_dijkstra), (PyCFunction)meth_QgsGraphAnalyzer_dijkstra, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphAnalyzer_dijkstra)},
    {SIP_MLNAME_CAST(sipName_shortestTree), (PyCFunction)meth_QgsGraphAnalyzer_shortestTree, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphAnalyzer_shortestTree)}
};

PyDoc_STRVAR(doc_QgsGraphAnalyzer, "\n"
"\n"
"\n"
"This class performs graph analysis, e.g. calculates shortest path between two\n"
"points using different strategies with Dijkstra algorithm");


static pyqt5ClassPluginDef plugin_QgsGraphAnalyzer = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGraphAnalyzer = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGraphAnalyzer,
        {0},
        &plugin_QgsGraphAnalyzer
    },
    {
        sipNameNr_QgsGraphAnalyzer,
        {0, 0, 1},
        2, methods_QgsGraphAnalyzer,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGraphAnalyzer,
    -1,
    -1,
    0,
    0,
    init_type_QgsGraphAnalyzer,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGraphAnalyzer,
    assign_QgsGraphAnalyzer,
    array_QgsGraphAnalyzer,
    copy_QgsGraphAnalyzer,
    release_QgsGraphAnalyzer,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 21 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsnetworkdistancestrategy.sip"
#include "qgsnetworkdistancestrategy.h"
#line 5852 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 5856 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 5862 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 261 "core/conversions.sip"
#include <QSet>
#line 5865 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsNetworkDistanceStrategy : public  ::QgsNetworkDistanceStrategy
{
public:
    sipQgsNetworkDistanceStrategy();
    sipQgsNetworkDistanceStrategy(const  ::QgsNetworkDistanceStrategy&);
    virtual ~sipQgsNetworkDistanceStrategy();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QSet<int> requiredAttributes() const;
     ::QVariant cost(double,const  ::QgsFeature&) const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsNetworkDistanceStrategy(const sipQgsNetworkDistanceStrategy &);
    sipQgsNetworkDistanceStrategy &operator = (const sipQgsNetworkDistanceStrategy &);

    char sipPyMethods[2];
};

sipQgsNetworkDistanceStrategy::sipQgsNetworkDistanceStrategy():  ::QgsNetworkDistanceStrategy(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNetworkDistanceStrategy::sipQgsNetworkDistanceStrategy(const  ::QgsNetworkDistanceStrategy& a0):  ::QgsNetworkDistanceStrategy(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNetworkDistanceStrategy::~sipQgsNetworkDistanceStrategy()
{
    sipInstanceDestroyed(sipPySelf);
}

 ::QSet<int> sipQgsNetworkDistanceStrategy::requiredAttributes() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,NULL,sipName_requiredAttributes);

    if (!sipMeth)
        return  ::QgsNetworkDistanceStrategy::requiredAttributes();

    extern  ::QSet<int> sipVH__analysis_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_17(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QVariant sipQgsNetworkDistanceStrategy::cost(double a0,const  ::QgsFeature& a1) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_cost);

    if (!sipMeth)
        return  ::QgsNetworkDistanceStrategy::cost(a0,a1);

    extern  ::QVariant sipVH__analysis_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, double,const  ::QgsFeature&);

    return sipVH__analysis_18(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}


PyDoc_STRVAR(doc_QgsNetworkDistanceStrategy_cost, "cost(self, distance: float, a1: QgsFeature) -> Any");

extern "C" {static PyObject *meth_QgsNetworkDistanceStrategy_cost(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNetworkDistanceStrategy_cost(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        double a0;
        const  ::QgsFeature* a1;
        const  ::QgsNetworkDistanceStrategy *sipCpp;

        static const char *sipKwdList[] = {
            sipName_distance,
            NULL,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BdJ9", &sipSelf, sipType_QgsNetworkDistanceStrategy, &sipCpp, &a0, sipType_QgsFeature, &a1))
        {
             ::QVariant*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QVariant((sipSelfWasArg ? sipCpp-> ::QgsNetworkDistanceStrategy::cost(a0,*a1) : sipCpp->cost(a0,*a1)));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNetworkDistanceStrategy, sipName_cost, doc_QgsNetworkDistanceStrategy_cost);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsNetworkDistanceStrategy(void *, const sipTypeDef *);}
static void *cast_QgsNetworkDistanceStrategy(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsNetworkDistanceStrategy *sipCpp = reinterpret_cast< ::QgsNetworkDistanceStrategy *>(sipCppV);

    if (targetType == sipType_QgsNetworkStrategy)
        return static_cast< ::QgsNetworkStrategy *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsNetworkDistanceStrategy(void *, int);}
static void release_QgsNetworkDistanceStrategy(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsNetworkDistanceStrategy *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsNetworkDistanceStrategy *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsNetworkDistanceStrategy(void *, SIP_SSIZE_T, void *);}
static void assign_QgsNetworkDistanceStrategy(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsNetworkDistanceStrategy *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsNetworkDistanceStrategy *>(sipSrc);
}


extern "C" {static void *array_QgsNetworkDistanceStrategy(SIP_SSIZE_T);}
static void *array_QgsNetworkDistanceStrategy(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsNetworkDistanceStrategy[sipNrElem];
}


extern "C" {static void *copy_QgsNetworkDistanceStrategy(const void *, SIP_SSIZE_T);}
static void *copy_QgsNetworkDistanceStrategy(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsNetworkDistanceStrategy(reinterpret_cast<const  ::QgsNetworkDistanceStrategy *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsNetworkDistanceStrategy(sipSimpleWrapper *);}
static void dealloc_QgsNetworkDistanceStrategy(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsNetworkDistanceStrategy *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsNetworkDistanceStrategy(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsNetworkDistanceStrategy(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsNetworkDistanceStrategy(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsNetworkDistanceStrategy *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNetworkDistanceStrategy();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsNetworkDistanceStrategy* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsNetworkDistanceStrategy, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNetworkDistanceStrategy(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsNetworkDistanceStrategy[] = {{69, 255, 1}};


static PyMethodDef methods_QgsNetworkDistanceStrategy[] = {
    {SIP_MLNAME_CAST(sipName_cost), (PyCFunction)meth_QgsNetworkDistanceStrategy_cost, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNetworkDistanceStrategy_cost)}
};

PyDoc_STRVAR(doc_QgsNetworkDistanceStrategy, "\n"
"\n"
"\n"
"Strategy for calculating edge cost based on its length. Should be\n"
"used for finding shortest path between two points.\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsNetworkDistanceStrategy = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsNetworkDistanceStrategy = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsNetworkDistanceStrategy,
        {0},
        &plugin_QgsNetworkDistanceStrategy
    },
    {
        sipNameNr_QgsNetworkDistanceStrategy,
        {0, 0, 1},
        1, methods_QgsNetworkDistanceStrategy,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsNetworkDistanceStrategy,
    -1,
    -1,
    supers_QgsNetworkDistanceStrategy,
    0,
    init_type_QgsNetworkDistanceStrategy,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsNetworkDistanceStrategy,
    assign_QgsNetworkDistanceStrategy,
    array_QgsNetworkDistanceStrategy,
    copy_QgsNetworkDistanceStrategy,
    release_QgsNetworkDistanceStrategy,
    cast_QgsNetworkDistanceStrategy,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 21 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsnetworkspeedstrategy.sip"
#include "qgsnetworkspeedstrategy.h"
#line 6182 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 261 "core/conversions.sip"
#include <QSet>
#line 6186 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6189 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 6195 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsNetworkSpeedStrategy : public  ::QgsNetworkSpeedStrategy
{
public:
    sipQgsNetworkSpeedStrategy(int,double,double);
    sipQgsNetworkSpeedStrategy(const  ::QgsNetworkSpeedStrategy&);
    virtual ~sipQgsNetworkSpeedStrategy();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QSet<int> requiredAttributes() const;
     ::QVariant cost(double,const  ::QgsFeature&) const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsNetworkSpeedStrategy(const sipQgsNetworkSpeedStrategy &);
    sipQgsNetworkSpeedStrategy &operator = (const sipQgsNetworkSpeedStrategy &);

    char sipPyMethods[2];
};

sipQgsNetworkSpeedStrategy::sipQgsNetworkSpeedStrategy(int a0,double a1,double a2):  ::QgsNetworkSpeedStrategy(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNetworkSpeedStrategy::sipQgsNetworkSpeedStrategy(const  ::QgsNetworkSpeedStrategy& a0):  ::QgsNetworkSpeedStrategy(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNetworkSpeedStrategy::~sipQgsNetworkSpeedStrategy()
{
    sipInstanceDestroyed(sipPySelf);
}

 ::QSet<int> sipQgsNetworkSpeedStrategy::requiredAttributes() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,NULL,sipName_requiredAttributes);

    if (!sipMeth)
        return  ::QgsNetworkSpeedStrategy::requiredAttributes();

    extern  ::QSet<int> sipVH__analysis_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_17(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}

 ::QVariant sipQgsNetworkSpeedStrategy::cost(double a0,const  ::QgsFeature& a1) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_cost);

    if (!sipMeth)
        return  ::QgsNetworkSpeedStrategy::cost(a0,a1);

    extern  ::QVariant sipVH__analysis_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, double,const  ::QgsFeature&);

    return sipVH__analysis_18(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}


PyDoc_STRVAR(doc_QgsNetworkSpeedStrategy_cost, "cost(self, distance: float, f: QgsFeature) -> Any");

extern "C" {static PyObject *meth_QgsNetworkSpeedStrategy_cost(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNetworkSpeedStrategy_cost(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        double a0;
        const  ::QgsFeature* a1;
        const  ::QgsNetworkSpeedStrategy *sipCpp;

        static const char *sipKwdList[] = {
            sipName_distance,
            sipName_f,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BdJ9", &sipSelf, sipType_QgsNetworkSpeedStrategy, &sipCpp, &a0, sipType_QgsFeature, &a1))
        {
             ::QVariant*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QVariant((sipSelfWasArg ? sipCpp-> ::QgsNetworkSpeedStrategy::cost(a0,*a1) : sipCpp->cost(a0,*a1)));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNetworkSpeedStrategy, sipName_cost, doc_QgsNetworkSpeedStrategy_cost);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNetworkSpeedStrategy_requiredAttributes, "requiredAttributes(self) -> object");

extern "C" {static PyObject *meth_QgsNetworkSpeedStrategy_requiredAttributes(PyObject *, PyObject *);}
static PyObject *meth_QgsNetworkSpeedStrategy_requiredAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsNetworkSpeedStrategy *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsNetworkSpeedStrategy, &sipCpp))
        {
             ::QSet<int>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QSet<int>((sipSelfWasArg ? sipCpp-> ::QgsNetworkSpeedStrategy::requiredAttributes() : sipCpp->requiredAttributes()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QSet_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNetworkSpeedStrategy, sipName_requiredAttributes, doc_QgsNetworkSpeedStrategy_requiredAttributes);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsNetworkSpeedStrategy(void *, const sipTypeDef *);}
static void *cast_QgsNetworkSpeedStrategy(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsNetworkSpeedStrategy *sipCpp = reinterpret_cast< ::QgsNetworkSpeedStrategy *>(sipCppV);

    if (targetType == sipType_QgsNetworkStrategy)
        return static_cast< ::QgsNetworkStrategy *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsNetworkSpeedStrategy(void *, int);}
static void release_QgsNetworkSpeedStrategy(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsNetworkSpeedStrategy *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsNetworkSpeedStrategy *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsNetworkSpeedStrategy(sipSimpleWrapper *);}
static void dealloc_QgsNetworkSpeedStrategy(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsNetworkSpeedStrategy *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsNetworkSpeedStrategy(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsNetworkSpeedStrategy(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsNetworkSpeedStrategy(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsNetworkSpeedStrategy *sipCpp = 0;

    {
        int a0;
        double a1;
        double a2;

        static const char *sipKwdList[] = {
            sipName_attributeId,
            sipName_defaultValue,
            sipName_toMetricFactor,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "idd", &a0, &a1, &a2))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNetworkSpeedStrategy(a0,a1,a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsNetworkSpeedStrategy* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsNetworkSpeedStrategy, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNetworkSpeedStrategy(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsNetworkSpeedStrategy[] = {{69, 255, 1}};


static PyMethodDef methods_QgsNetworkSpeedStrategy[] = {
    {SIP_MLNAME_CAST(sipName_cost), (PyCFunction)meth_QgsNetworkSpeedStrategy_cost, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNetworkSpeedStrategy_cost)},
    {SIP_MLNAME_CAST(sipName_requiredAttributes), meth_QgsNetworkSpeedStrategy_requiredAttributes, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsNetworkSpeedStrategy_requiredAttributes)}
};

PyDoc_STRVAR(doc_QgsNetworkSpeedStrategy, "QgsNetworkSpeedStrategy(attributeId: int, defaultValue: float, toMetricFactor: float)\n"
"Default constructor\n"
"\n"
"QgsNetworkSpeedStrategy(QgsNetworkSpeedStrategy)\n"
"\n"
"Strategy for calculating edge cost based on travel time. Should be\n"
"used for finding fastest path between two points.\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsNetworkSpeedStrategy = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsNetworkSpeedStrategy = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsNetworkSpeedStrategy,
        {0},
        &plugin_QgsNetworkSpeedStrategy
    },
    {
        sipNameNr_QgsNetworkSpeedStrategy,
        {0, 0, 1},
        2, methods_QgsNetworkSpeedStrategy,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsNetworkSpeedStrategy,
    -1,
    -1,
    supers_QgsNetworkSpeedStrategy,
    0,
    init_type_QgsNetworkSpeedStrategy,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsNetworkSpeedStrategy,
    0,
    0,
    0,
    release_QgsNetworkSpeedStrategy,
    cast_QgsNetworkSpeedStrategy,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 30 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsnetworkstrategy.sip"
#include "qgsnetworkstrategy.h"
#line 6547 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6551 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgsfeature.sip"
#include "qgsfeature.h"
#if (SIP_VERSION >= 0x040900 && SIP_VERSION < 0x040c01)
#define sipType_QVariant ((sipWrapperType *) sipTypeAsPyTypeObject (sipType_QVariant))
#endif
#line 6557 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 261 "core/conversions.sip"
#include <QSet>
#line 6560 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsNetworkStrategy : public  ::QgsNetworkStrategy
{
public:
    sipQgsNetworkStrategy();
    sipQgsNetworkStrategy(const  ::QgsNetworkStrategy&);
    virtual ~sipQgsNetworkStrategy();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::QVariant cost(double,const  ::QgsFeature&) const;
     ::QSet<int> requiredAttributes() const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsNetworkStrategy(const sipQgsNetworkStrategy &);
    sipQgsNetworkStrategy &operator = (const sipQgsNetworkStrategy &);

    char sipPyMethods[2];
};

sipQgsNetworkStrategy::sipQgsNetworkStrategy():  ::QgsNetworkStrategy(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNetworkStrategy::sipQgsNetworkStrategy(const  ::QgsNetworkStrategy& a0):  ::QgsNetworkStrategy(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsNetworkStrategy::~sipQgsNetworkStrategy()
{
    sipInstanceDestroyed(sipPySelf);
}

 ::QVariant sipQgsNetworkStrategy::cost(double a0,const  ::QgsFeature& a1) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,sipName_QgsNetworkStrategy,sipName_cost);

    if (!sipMeth)
        return  ::QVariant();

    extern  ::QVariant sipVH__analysis_18(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, double,const  ::QgsFeature&);

    return sipVH__analysis_18(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

 ::QSet<int> sipQgsNetworkStrategy::requiredAttributes() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_requiredAttributes);

    if (!sipMeth)
        return  ::QgsNetworkStrategy::requiredAttributes();

    extern  ::QSet<int> sipVH__analysis_17(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__analysis_17(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_QgsNetworkStrategy_requiredAttributes, "requiredAttributes(self) -> object\n"
"Returns a list of the source layer attributes needed for cost calculation.\n"
"This is method called by :py:class:`QgsGraphDirector`.");

extern "C" {static PyObject *meth_QgsNetworkStrategy_requiredAttributes(PyObject *, PyObject *);}
static PyObject *meth_QgsNetworkStrategy_requiredAttributes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QgsNetworkStrategy *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsNetworkStrategy, &sipCpp))
        {
             ::QSet<int>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QSet<int>((sipSelfWasArg ? sipCpp-> ::QgsNetworkStrategy::requiredAttributes() : sipCpp->requiredAttributes()));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QSet_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNetworkStrategy, sipName_requiredAttributes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsNetworkStrategy_cost, "cost(self, distance: float, f: QgsFeature) -> Any\n"
"Returns edge cost");

extern "C" {static PyObject *meth_QgsNetworkStrategy_cost(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsNetworkStrategy_cost(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
        double a0;
        const  ::QgsFeature* a1;
        const  ::QgsNetworkStrategy *sipCpp;

        static const char *sipKwdList[] = {
            sipName_distance,
            sipName_f,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BdJ9", &sipSelf, sipType_QgsNetworkStrategy, &sipCpp, &a0, sipType_QgsFeature, &a1))
        {
             ::QVariant*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_QgsNetworkStrategy, sipName_cost);
                return NULL;
            }

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QVariant(sipCpp->cost(a0,*a1));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsNetworkStrategy, sipName_cost, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsNetworkStrategy(void *, int);}
static void release_QgsNetworkStrategy(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsNetworkStrategy *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsNetworkStrategy *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsNetworkStrategy(sipSimpleWrapper *);}
static void dealloc_QgsNetworkStrategy(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsNetworkStrategy *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsNetworkStrategy(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsNetworkStrategy(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsNetworkStrategy(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsNetworkStrategy *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNetworkStrategy();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsNetworkStrategy* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsNetworkStrategy, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsNetworkStrategy(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsNetworkStrategy[] = {
    {SIP_MLNAME_CAST(sipName_cost), (PyCFunction)meth_QgsNetworkStrategy_cost, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsNetworkStrategy_cost)},
    {SIP_MLNAME_CAST(sipName_requiredAttributes), meth_QgsNetworkStrategy_requiredAttributes, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsNetworkStrategy_requiredAttributes)}
};

PyDoc_STRVAR(doc_QgsNetworkStrategy, "QgsNetworkStrategy()\n"
"Default constructor\n"
"\n"
"QgsNetworkStrategy(QgsNetworkStrategy)\n"
"\n"
"QgsNetworkStrategy defines strategy used for calculation of the edge cost. For example it can\n"
"take into account travel distance, amount of time or money. Currently there are two strategies\n"
"implemented in the analysis library: QgsNetworkDistanceStrategy and QgsNetworkSpeedStrategy.\n"
"QgsNetworkStrategy implemented using \"strategy\" design pattern.\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsNetworkStrategy = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsNetworkStrategy = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsNetworkStrategy,
        {0},
        &plugin_QgsNetworkStrategy
    },
    {
        sipNameNr_QgsNetworkStrategy,
        {0, 0, 1},
        2, methods_QgsNetworkStrategy,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsNetworkStrategy,
    -1,
    -1,
    0,
    0,
    init_type_QgsNetworkStrategy,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsNetworkStrategy,
    0,
    0,
    0,
    release_QgsNetworkStrategy,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 21 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraphbuilder.sip"
#include "qgsgraphbuilder.h"
#line 6896 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 157 "core/auto_generated/qgscoordinatereferencesystem.sip"
#include "qgscoordinatereferencesystem.h"
#line 6900 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 6903 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 118 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraph.sip"
#include "qgsgraph.h"
#line 6906 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 6909 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 6912 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 6915 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 34 "core/auto_generated/qgsdistancearea.sip"
#include "qgsdistancearea.h"
#line 6918 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsGraphBuilder : public  ::QgsGraphBuilder
{
public:
    sipQgsGraphBuilder(const  ::QgsCoordinateReferenceSystem&,bool,double,const  ::QString&);
    sipQgsGraphBuilder(const  ::QgsGraphBuilder&);
    virtual ~sipQgsGraphBuilder();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void addVertex(int,const  ::QgsPointXY&);
    void addEdge(int,const  ::QgsPointXY&,int,const  ::QgsPointXY&,const QVector< ::QVariant>&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsGraphBuilder(const sipQgsGraphBuilder &);
    sipQgsGraphBuilder &operator = (const sipQgsGraphBuilder &);

    char sipPyMethods[2];
};

sipQgsGraphBuilder::sipQgsGraphBuilder(const  ::QgsCoordinateReferenceSystem& a0,bool a1,double a2,const  ::QString& a3):  ::QgsGraphBuilder(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGraphBuilder::sipQgsGraphBuilder(const  ::QgsGraphBuilder& a0):  ::QgsGraphBuilder(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGraphBuilder::~sipQgsGraphBuilder()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipQgsGraphBuilder::addVertex(int a0,const  ::QgsPointXY& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_addVertex);

    if (!sipMeth)
    {
         ::QgsGraphBuilder::addVertex(a0,a1);
        return;
    }

    extern void sipVH__analysis_15(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,const  ::QgsPointXY&);

    sipVH__analysis_15(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}

void sipQgsGraphBuilder::addEdge(int a0,const  ::QgsPointXY& a1,int a2,const  ::QgsPointXY& a3,const QVector< ::QVariant>& a4)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_addEdge);

    if (!sipMeth)
    {
         ::QgsGraphBuilder::addEdge(a0,a1,a2,a3,a4);
        return;
    }

    extern void sipVH__analysis_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,const  ::QgsPointXY&,int,const  ::QgsPointXY&,const QVector< ::QVariant>&);

    sipVH__analysis_16(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4);
}


PyDoc_STRVAR(doc_QgsGraphBuilder_addVertex, "addVertex(self, id: int, pt: QgsPointXY)\n"
"MANDATORY BUILDER PROPERTY DECLARATION");

extern "C" {static PyObject *meth_QgsGraphBuilder_addVertex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilder_addVertex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0;
        const  ::QgsPointXY* a1;
         ::QgsGraphBuilder *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ9", &sipSelf, sipType_QgsGraphBuilder, &sipCpp, &a0, sipType_QgsPointXY, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsGraphBuilder::addVertex(a0,*a1) : sipCpp->addVertex(a0,*a1));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilder, sipName_addVertex, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphBuilder_addEdge, "addEdge(self, pt1id: int, pt1: QgsPointXY, pt2id: int, pt2: QgsPointXY, prop: Iterable[Any])");

extern "C" {static PyObject *meth_QgsGraphBuilder_addEdge(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilder_addEdge(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0;
        const  ::QgsPointXY* a1;
        int a2;
        const  ::QgsPointXY* a3;
        const QVector< ::QVariant>* a4;
        int a4State = 0;
         ::QgsGraphBuilder *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt1id,
            sipName_pt1,
            sipName_pt2id,
            sipName_pt2,
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ9iJ9J1", &sipSelf, sipType_QgsGraphBuilder, &sipCpp, &a0, sipType_QgsPointXY, &a1, &a2, sipType_QgsPointXY, &a3, sipType_QVector_0100QVariant,&a4, &a4State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsGraphBuilder::addEdge(a0,*a1,a2,*a3,*a4) : sipCpp->addEdge(a0,*a1,a2,*a3,*a4));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QVector< ::QVariant> *>(a4),sipType_QVector_0100QVariant,a4State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QVector< ::QVariant> *>(a4),sipType_QVector_0100QVariant,a4State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilder, sipName_addEdge, doc_QgsGraphBuilder_addEdge);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphBuilder_graph, "graph(self) -> QgsGraph\n"
"Returns generated :py:class:`QgsGraph`");

extern "C" {static PyObject *meth_QgsGraphBuilder_graph(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilder_graph(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsGraphBuilder *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphBuilder, &sipCpp))
        {
             ::QgsGraph*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->graph();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGraph,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilder, sipName_graph, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsGraphBuilder(void *, const sipTypeDef *);}
static void *cast_QgsGraphBuilder(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsGraphBuilder *sipCpp = reinterpret_cast< ::QgsGraphBuilder *>(sipCppV);

    if (targetType == sipType_QgsGraphBuilderInterface)
        return static_cast< ::QgsGraphBuilderInterface *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGraphBuilder(void *, int);}
static void release_QgsGraphBuilder(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsGraphBuilder *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsGraphBuilder *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGraphBuilder(sipSimpleWrapper *);}
static void dealloc_QgsGraphBuilder(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsGraphBuilder *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGraphBuilder(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsGraphBuilder(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGraphBuilder(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsGraphBuilder *sipCpp = 0;

    {
        const  ::QgsCoordinateReferenceSystem* a0;
        bool a1 = 1;
        double a2 = 0;
        const  ::QString& a3def = "WGS84";
        const  ::QString* a3 = &a3def;
        int a3State = 0;

        static const char *sipKwdList[] = {
            sipName_crs,
            sipName_otfEnabled,
            sipName_topologyTolerance,
            sipName_ellipsoidID,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|bdJ1", sipType_QgsCoordinateReferenceSystem, &a0, &a1, &a2, sipType_QString,&a3, &a3State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGraphBuilder(*a0,a1,a2,*a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a3),sipType_QString,a3State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a3),sipType_QString,a3State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsGraphBuilder* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGraphBuilder, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGraphBuilder(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsGraphBuilder[] = {{45, 255, 1}};


static PyMethodDef methods_QgsGraphBuilder[] = {
    {SIP_MLNAME_CAST(sipName_addEdge), (PyCFunction)meth_QgsGraphBuilder_addEdge, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphBuilder_addEdge)},
    {SIP_MLNAME_CAST(sipName_addVertex), (PyCFunction)meth_QgsGraphBuilder_addVertex, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphBuilder_addVertex)},
    {SIP_MLNAME_CAST(sipName_graph), meth_QgsGraphBuilder_graph, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphBuilder_graph)}
};

PyDoc_STRVAR(doc_QgsGraphBuilder, "QgsGraphBuilder(crs: QgsCoordinateReferenceSystem, otfEnabled: bool = True, topologyTolerance: float = 0, ellipsoidID: str = '')\n"
"Default constructor\n"
"\n"
"QgsGraphBuilder(QgsGraphBuilder)\n"
"\n"
"This class used for making the QgsGraph object");


static pyqt5ClassPluginDef plugin_QgsGraphBuilder = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGraphBuilder = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGraphBuilder,
        {0},
        &plugin_QgsGraphBuilder
    },
    {
        sipNameNr_QgsGraphBuilder,
        {0, 0, 1},
        3, methods_QgsGraphBuilder,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGraphBuilder,
    -1,
    -1,
    supers_QgsGraphBuilder,
    0,
    init_type_QgsGraphBuilder,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGraphBuilder,
    0,
    0,
    0,
    release_QgsGraphBuilder,
    cast_QgsGraphBuilder,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 25 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraphbuilderinterface.sip"
#include "qgsgraphbuilderinterface.h"
#line 7336 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 157 "core/auto_generated/qgscoordinatereferencesystem.sip"
#include "qgscoordinatereferencesystem.h"
#line 7340 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 27 "/usr/share/sip/PyQt5/QtCore/qstring.sip"
#include <qstring.h>
#line 7343 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 7346 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 7349 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 7352 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 34 "core/auto_generated/qgsdistancearea.sip"
#include "qgsdistancearea.h"
#line 7355 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsGraphBuilderInterface : public  ::QgsGraphBuilderInterface
{
public:
    sipQgsGraphBuilderInterface(const  ::QgsCoordinateReferenceSystem&,bool,double,const  ::QString&);
    sipQgsGraphBuilderInterface(const  ::QgsGraphBuilderInterface&);
    virtual ~sipQgsGraphBuilderInterface();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void addEdge(int,const  ::QgsPointXY&,int,const  ::QgsPointXY&,const QVector< ::QVariant>&);
    void addVertex(int,const  ::QgsPointXY&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsGraphBuilderInterface(const sipQgsGraphBuilderInterface &);
    sipQgsGraphBuilderInterface &operator = (const sipQgsGraphBuilderInterface &);

    char sipPyMethods[2];
};

sipQgsGraphBuilderInterface::sipQgsGraphBuilderInterface(const  ::QgsCoordinateReferenceSystem& a0,bool a1,double a2,const  ::QString& a3):  ::QgsGraphBuilderInterface(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGraphBuilderInterface::sipQgsGraphBuilderInterface(const  ::QgsGraphBuilderInterface& a0):  ::QgsGraphBuilderInterface(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsGraphBuilderInterface::~sipQgsGraphBuilderInterface()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipQgsGraphBuilderInterface::addEdge(int a0,const  ::QgsPointXY& a1,int a2,const  ::QgsPointXY& a3,const QVector< ::QVariant>& a4)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_addEdge);

    if (!sipMeth)
    {
         ::QgsGraphBuilderInterface::addEdge(a0,a1,a2,a3,a4);
        return;
    }

    extern void sipVH__analysis_16(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,const  ::QgsPointXY&,int,const  ::QgsPointXY&,const QVector< ::QVariant>&);

    sipVH__analysis_16(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3, a4);
}

void sipQgsGraphBuilderInterface::addVertex(int a0,const  ::QgsPointXY& a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_addVertex);

    if (!sipMeth)
    {
         ::QgsGraphBuilderInterface::addVertex(a0,a1);
        return;
    }

    extern void sipVH__analysis_15(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,const  ::QgsPointXY&);

    sipVH__analysis_15(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1);
}


PyDoc_STRVAR(doc_QgsGraphBuilderInterface_destinationCrs, "destinationCrs(self) -> QgsCoordinateReferenceSystem\n"
"Returns destinaltion CRS");

extern "C" {static PyObject *meth_QgsGraphBuilderInterface_destinationCrs(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilderInterface_destinationCrs(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraphBuilderInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphBuilderInterface, &sipCpp))
        {
             ::QgsCoordinateReferenceSystem*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsCoordinateReferenceSystem(sipCpp->destinationCrs());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsCoordinateReferenceSystem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilderInterface, sipName_destinationCrs, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphBuilderInterface_coordinateTransformationEnabled, "coordinateTransformationEnabled(self) -> bool\n"
"Returns coordinate transformation enabled");

extern "C" {static PyObject *meth_QgsGraphBuilderInterface_coordinateTransformationEnabled(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilderInterface_coordinateTransformationEnabled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsGraphBuilderInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphBuilderInterface, &sipCpp))
        {
            bool sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->coordinateTransformationEnabled();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilderInterface, sipName_coordinateTransformationEnabled, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphBuilderInterface_topologyTolerance, "topologyTolerance(self) -> float\n"
"Returns topology tolerance");

extern "C" {static PyObject *meth_QgsGraphBuilderInterface_topologyTolerance(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilderInterface_topologyTolerance(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsGraphBuilderInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphBuilderInterface, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->topologyTolerance();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilderInterface, sipName_topologyTolerance, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphBuilderInterface_distanceArea, "distanceArea(self) -> QgsDistanceArea\n"
"Returns measurement tool");

extern "C" {static PyObject *meth_QgsGraphBuilderInterface_distanceArea(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilderInterface_distanceArea(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsGraphBuilderInterface *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphBuilderInterface, &sipCpp))
        {
             ::QgsDistanceArea*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->distanceArea();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_QgsDistanceArea,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilderInterface, sipName_distanceArea, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphBuilderInterface_addVertex, "addVertex(self, id: int, pt: QgsPointXY)\n"
"Add vertex to the graph\n"
"\n"
":param id: vertex identifier\n"
":param pt: vertex coordinates\n"
"\n"
".. note::\n"
"\n"
"   id and pt are redundant. You can use pt or id to identify the vertex");

extern "C" {static PyObject *meth_QgsGraphBuilderInterface_addVertex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilderInterface_addVertex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0;
        const  ::QgsPointXY* a1;
         ::QgsGraphBuilderInterface *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ9", &sipSelf, sipType_QgsGraphBuilderInterface, &sipCpp, &a0, sipType_QgsPointXY, &a1))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsGraphBuilderInterface::addVertex(a0,*a1) : sipCpp->addVertex(a0,*a1));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilderInterface, sipName_addVertex, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphBuilderInterface_addEdge, "addEdge(self, pt1id: int, pt1: QgsPointXY, pt2id: int, pt2: QgsPointXY, strategies: Iterable[Any])\n"
"Add edge to the graph\n"
"\n"
":param pt1id: first vertex identificator\n"
":param pt1: first vertex coordinates\n"
":param pt2id: second vertex identificator\n"
":param pt2: second vertex coordinates\n"
":param strategies: optimization strategies\n"
"\n"
".. note::\n"
"\n"
"   pt1id, pt1 and pt2id, pt2 is a redundant interface. You can use vertex coordinates or their identificators.");

extern "C" {static PyObject *meth_QgsGraphBuilderInterface_addEdge(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphBuilderInterface_addEdge(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int a0;
        const  ::QgsPointXY* a1;
        int a2;
        const  ::QgsPointXY* a3;
        const QVector< ::QVariant>* a4;
        int a4State = 0;
         ::QgsGraphBuilderInterface *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt1id,
            sipName_pt1,
            sipName_pt2id,
            sipName_pt2,
            sipName_strategies,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ9iJ9J1", &sipSelf, sipType_QgsGraphBuilderInterface, &sipCpp, &a0, sipType_QgsPointXY, &a1, &a2, sipType_QgsPointXY, &a3, sipType_QVector_0100QVariant,&a4, &a4State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            (sipSelfWasArg ? sipCpp-> ::QgsGraphBuilderInterface::addEdge(a0,*a1,a2,*a3,*a4) : sipCpp->addEdge(a0,*a1,a2,*a3,*a4));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QVector< ::QVariant> *>(a4),sipType_QVector_0100QVariant,a4State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QVector< ::QVariant> *>(a4),sipType_QVector_0100QVariant,a4State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphBuilderInterface, sipName_addEdge, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGraphBuilderInterface(void *, int);}
static void release_QgsGraphBuilderInterface(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsGraphBuilderInterface *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsGraphBuilderInterface *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsGraphBuilderInterface(sipSimpleWrapper *);}
static void dealloc_QgsGraphBuilderInterface(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsGraphBuilderInterface *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGraphBuilderInterface(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsGraphBuilderInterface(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGraphBuilderInterface(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsGraphBuilderInterface *sipCpp = 0;

    {
        const  ::QgsCoordinateReferenceSystem* a0;
        bool a1 = 1;
        double a2 = 0;
        const  ::QString& a3def = "WGS84";
        const  ::QString* a3 = &a3def;
        int a3State = 0;

        static const char *sipKwdList[] = {
            sipName_crs,
            sipName_ctfEnabled,
            sipName_topologyTolerance,
            sipName_ellipsoidID,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|bdJ1", sipType_QgsCoordinateReferenceSystem, &a0, &a1, &a2, sipType_QString,&a3, &a3State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGraphBuilderInterface(*a0,a1,a2,*a3);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast< ::QString *>(a3),sipType_QString,a3State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::QString *>(a3),sipType_QString,a3State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsGraphBuilderInterface* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGraphBuilderInterface, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsGraphBuilderInterface(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGraphBuilderInterface[] = {
    {SIP_MLNAME_CAST(sipName_addEdge), (PyCFunction)meth_QgsGraphBuilderInterface_addEdge, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphBuilderInterface_addEdge)},
    {SIP_MLNAME_CAST(sipName_addVertex), (PyCFunction)meth_QgsGraphBuilderInterface_addVertex, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphBuilderInterface_addVertex)},
    {SIP_MLNAME_CAST(sipName_coordinateTransformationEnabled), meth_QgsGraphBuilderInterface_coordinateTransformationEnabled, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphBuilderInterface_coordinateTransformationEnabled)},
    {SIP_MLNAME_CAST(sipName_destinationCrs), meth_QgsGraphBuilderInterface_destinationCrs, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphBuilderInterface_destinationCrs)},
    {SIP_MLNAME_CAST(sipName_distanceArea), meth_QgsGraphBuilderInterface_distanceArea, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphBuilderInterface_distanceArea)},
    {SIP_MLNAME_CAST(sipName_topologyTolerance), meth_QgsGraphBuilderInterface_topologyTolerance, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphBuilderInterface_topologyTolerance)}
};

PyDoc_STRVAR(doc_QgsGraphBuilderInterface, "QgsGraphBuilderInterface(crs: QgsCoordinateReferenceSystem, ctfEnabled: bool = True, topologyTolerance: float = 0, ellipsoidID: str = '')\n"
"Default constructor\n"
"\n"
":param crs: Coordinate reference system for new graph vertex\n"
":param ctfEnabled: enable coordinate transform from source graph CRS to CRS graph\n"
":param topologyTolerance: sqrt distance between source point as one graph vertex\n"
":param ellipsoidID: ellipsoid for edge measurement\n"
"\n"
"QgsGraphBuilderInterface(QgsGraphBuilderInterface)\n"
"\n"
"Determine interface for creating a graph. Contains the settings of the graph.\n"
"QgsGraphBuilder and QgsGraphDirector both use a \"builder\" design pattern");


static pyqt5ClassPluginDef plugin_QgsGraphBuilderInterface = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGraphBuilderInterface = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGraphBuilderInterface,
        {0},
        &plugin_QgsGraphBuilderInterface
    },
    {
        sipNameNr_QgsGraphBuilderInterface,
        {0, 0, 1},
        6, methods_QgsGraphBuilderInterface,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGraphBuilderInterface,
    -1,
    -1,
    0,
    0,
    init_type_QgsGraphBuilderInterface,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGraphBuilderInterface,
    0,
    0,
    0,
    release_QgsGraphBuilderInterface,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 118 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraph.sip"
#include "qgsgraph.h"
#line 7906 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 7910 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 23 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraph.sip"
#include "qgsgraph.h"
#line 7913 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 72 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraph.sip"
#include "qgsgraph.h"
#line 7916 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 7919 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 7922 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


PyDoc_STRVAR(doc_QgsGraph_addVertex, "addVertex(self, pt: QgsPointXY) -> int\n"
"Add a vertex to the graph");

extern "C" {static PyObject *meth_QgsGraph_addVertex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraph_addVertex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsPointXY* a0;
         ::QgsGraph *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsGraph, &sipCpp, sipType_QgsPointXY, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->addVertex(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraph, sipName_addVertex, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraph_addEdge, "addEdge(self, fromVertexIdx: int, toVertexIdx: int, strategies: Iterable[Any]) -> int\n"
"Add an edge to the graph, going from the ``fromVertexIdx``\n"
"to ``toVertexIdx``.");

extern "C" {static PyObject *meth_QgsGraph_addEdge(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraph_addEdge(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        int a1;
        const QVector< ::QVariant>* a2;
        int a2State = 0;
         ::QgsGraph *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fromVertexIdx,
            sipName_toVertexIdx,
            sipName_strategies,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiiJ1", &sipSelf, sipType_QgsGraph, &sipCpp, &a0, &a1, sipType_QVector_0100QVariant,&a2, &a2State))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->addEdge(a0,a1,*a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QVector< ::QVariant> *>(a2),sipType_QVector_0100QVariant,a2State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QVector< ::QVariant> *>(a2),sipType_QVector_0100QVariant,a2State);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraph, sipName_addEdge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraph_vertexCount, "vertexCount(self) -> int\n"
"Returns number of graph vertices");

extern "C" {static PyObject *meth_QgsGraph_vertexCount(PyObject *, PyObject *);}
static PyObject *meth_QgsGraph_vertexCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraph, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->vertexCount();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraph, sipName_vertexCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraph_vertex, "vertex(self, idx: int) -> QgsGraphVertex\n"
"Returns vertex at given index");

extern "C" {static PyObject *meth_QgsGraph_vertex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraph_vertex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        const  ::QgsGraph *sipCpp;

        static const char *sipKwdList[] = {
            sipName_idx,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_QgsGraph, &sipCpp, &a0))
        {
             ::QgsGraphVertex*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGraphVertex(sipCpp->vertex(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGraphVertex,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraph, sipName_vertex, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraph_edgeCount, "edgeCount(self) -> int\n"
"Returns number of graph edges");

extern "C" {static PyObject *meth_QgsGraph_edgeCount(PyObject *, PyObject *);}
static PyObject *meth_QgsGraph_edgeCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraph *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraph, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->edgeCount();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraph, sipName_edgeCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraph_edge, "edge(self, idx: int) -> QgsGraphEdge\n"
"Returns edge at given index");

extern "C" {static PyObject *meth_QgsGraph_edge(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraph_edge(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        const  ::QgsGraph *sipCpp;

        static const char *sipKwdList[] = {
            sipName_idx,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_QgsGraph, &sipCpp, &a0))
        {
             ::QgsGraphEdge*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGraphEdge(sipCpp->edge(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsGraphEdge,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraph, sipName_edge, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraph_findVertex, "findVertex(self, pt: QgsPointXY) -> int\n"
"Find vertex by associated point\n"
"\n"
":return: vertex index");

extern "C" {static PyObject *meth_QgsGraph_findVertex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraph_findVertex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsPointXY* a0;
        const  ::QgsGraph *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_QgsGraph, &sipCpp, sipType_QgsPointXY, &a0))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->findVertex(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraph, sipName_findVertex, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGraph(void *, int);}
static void release_QgsGraph(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGraph *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsGraph(void *, SIP_SSIZE_T, void *);}
static void assign_QgsGraph(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsGraph *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsGraph *>(sipSrc);
}


extern "C" {static void *array_QgsGraph(SIP_SSIZE_T);}
static void *array_QgsGraph(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsGraph[sipNrElem];
}


extern "C" {static void *copy_QgsGraph(const void *, SIP_SSIZE_T);}
static void *copy_QgsGraph(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsGraph(reinterpret_cast<const  ::QgsGraph *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsGraph(sipSimpleWrapper *);}
static void dealloc_QgsGraph(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGraph(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGraph(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGraph(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGraph *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraph();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsGraph* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGraph, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraph(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGraph[] = {
    {SIP_MLNAME_CAST(sipName_addEdge), (PyCFunction)meth_QgsGraph_addEdge, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraph_addEdge)},
    {SIP_MLNAME_CAST(sipName_addVertex), (PyCFunction)meth_QgsGraph_addVertex, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraph_addVertex)},
    {SIP_MLNAME_CAST(sipName_edge), (PyCFunction)meth_QgsGraph_edge, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraph_edge)},
    {SIP_MLNAME_CAST(sipName_edgeCount), meth_QgsGraph_edgeCount, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraph_edgeCount)},
    {SIP_MLNAME_CAST(sipName_findVertex), (PyCFunction)meth_QgsGraph_findVertex, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraph_findVertex)},
    {SIP_MLNAME_CAST(sipName_vertex), (PyCFunction)meth_QgsGraph_vertex, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraph_vertex)},
    {SIP_MLNAME_CAST(sipName_vertexCount), meth_QgsGraph_vertexCount, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraph_vertexCount)}
};

PyDoc_STRVAR(doc_QgsGraph, "QgsGraph()\n"
"Constructor for QgsGraph.\n"
"\n"
"QgsGraph(QgsGraph)\n"
"\n"
"Mathematical graph representation\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsGraph = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGraph = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGraph,
        {0},
        &plugin_QgsGraph
    },
    {
        sipNameNr_QgsGraph,
        {0, 0, 1},
        7, methods_QgsGraph,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGraph,
    -1,
    -1,
    0,
    0,
    init_type_QgsGraph,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGraph,
    assign_QgsGraph,
    array_QgsGraph,
    copy_QgsGraph,
    release_QgsGraph,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 72 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraph.sip"
#include "qgsgraph.h"
#line 8424 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 28 "core/auto_generated/qgspointxy.sip"
#include "qgspointxy.h"
#line 8428 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 646 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 8431 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


PyDoc_STRVAR(doc_QgsGraphVertex_incomingEdges, "incomingEdges(self) -> List[int]\n"
"Returns the incoming edge ids, i.e. edges which end at this node.\n"
"\n"
".. seealso:: :py:func:`outgoingEdges`");

extern "C" {static PyObject *meth_QgsGraphVertex_incomingEdges(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphVertex_incomingEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraphVertex *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphVertex, &sipCpp))
        {
             ::QgsGraphEdgeIds*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGraphEdgeIds(sipCpp->incomingEdges());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphVertex, sipName_incomingEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphVertex_outgoingEdges, "outgoingEdges(self) -> List[int]\n"
"Returns outgoing edge ids, i.e. edges which start at this node.\n"
"\n"
".. seealso:: :py:func:`incomingEdges`");

extern "C" {static PyObject *meth_QgsGraphVertex_outgoingEdges(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphVertex_outgoingEdges(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraphVertex *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphVertex, &sipCpp))
        {
             ::QgsGraphEdgeIds*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsGraphEdgeIds(sipCpp->outgoingEdges());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QList_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphVertex, sipName_outgoingEdges, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphVertex_point, "point(self) -> QgsPointXY\n"
"Returns point associated with graph vertex.");

extern "C" {static PyObject *meth_QgsGraphVertex_point(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphVertex_point(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraphVertex *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphVertex, &sipCpp))
        {
             ::QgsPointXY*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsPointXY(sipCpp->point());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsPointXY,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphVertex, sipName_point, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGraphVertex(void *, int);}
static void release_QgsGraphVertex(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGraphVertex *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsGraphVertex(void *, SIP_SSIZE_T, void *);}
static void assign_QgsGraphVertex(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsGraphVertex *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsGraphVertex *>(sipSrc);
}


extern "C" {static void *array_QgsGraphVertex(SIP_SSIZE_T);}
static void *array_QgsGraphVertex(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsGraphVertex[sipNrElem];
}


extern "C" {static void *copy_QgsGraphVertex(const void *, SIP_SSIZE_T);}
static void *copy_QgsGraphVertex(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsGraphVertex(reinterpret_cast<const  ::QgsGraphVertex *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsGraphVertex(sipSimpleWrapper *);}
static void dealloc_QgsGraphVertex(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGraphVertex(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGraphVertex(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGraphVertex(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGraphVertex *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraphVertex();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsPointXY* a0;

        static const char *sipKwdList[] = {
            sipName_point,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_QgsPointXY, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraphVertex(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsGraphVertex* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGraphVertex, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraphVertex(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGraphVertex[] = {
    {SIP_MLNAME_CAST(sipName_incomingEdges), meth_QgsGraphVertex_incomingEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphVertex_incomingEdges)},
    {SIP_MLNAME_CAST(sipName_outgoingEdges), meth_QgsGraphVertex_outgoingEdges, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphVertex_outgoingEdges)},
    {SIP_MLNAME_CAST(sipName_point), meth_QgsGraphVertex_point, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphVertex_point)}
};

PyDoc_STRVAR(doc_QgsGraphVertex, "QgsGraphVertex()\n"
"Default constructor. It is needed for Qt's container, e.g. QVector\n"
"\n"
"QgsGraphVertex(point: QgsPointXY)\n"
"This constructor initializes QgsGraphVertex object and associates a vertex with a point\n"
"\n"
"QgsGraphVertex(QgsGraphVertex)\n"
"\n"
"This class implements a graph vertex\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsGraphVertex = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGraphVertex = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGraphVertex,
        {0},
        &plugin_QgsGraphVertex
    },
    {
        sipNameNr_QgsGraphVertex,
        {0, 0, 1},
        3, methods_QgsGraphVertex,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGraphVertex,
    -1,
    -1,
    0,
    0,
    init_type_QgsGraphVertex,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGraphVertex,
    assign_QgsGraphVertex,
    array_QgsGraphVertex,
    copy_QgsGraphVertex,
    release_QgsGraphVertex,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 23 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/network/qgsgraph.sip"
#include "qgsgraph.h"
#line 8765 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 28 "/usr/share/sip/PyQt5/QtCore/qpycore_qvector.sip"
#include <qvector.h>
#line 8769 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 26 "/usr/share/sip/PyQt5/QtCore/qvariant.sip"
#include <qvariant.h>
#line 8772 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


PyDoc_STRVAR(doc_QgsGraphEdge_cost, "cost(self, strategyIndex: int) -> Any\n"
"Returns edge cost calculated using specified strategy\n"
"\n"
":param strategyIndex: strategy index");

extern "C" {static PyObject *meth_QgsGraphEdge_cost(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsGraphEdge_cost(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        const  ::QgsGraphEdge *sipCpp;

        static const char *sipKwdList[] = {
            sipName_strategyIndex,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_QgsGraphEdge, &sipCpp, &a0))
        {
             ::QVariant*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QVariant(sipCpp->cost(a0));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphEdge, sipName_cost, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphEdge_strategies, "strategies(self) -> List[Any]\n"
"Returns array of available strategies");

extern "C" {static PyObject *meth_QgsGraphEdge_strategies(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphEdge_strategies(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraphEdge *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphEdge, &sipCpp))
        {
            QVector< ::QVariant>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new QVector< ::QVariant>(sipCpp->strategies());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QVector_0100QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphEdge, sipName_strategies, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphEdge_toVertex, "toVertex(self) -> int\n"
"Returns the index of the vertex at the end of this edge.\n"
"\n"
".. seealso:: :py:func:`fromVertex`");

extern "C" {static PyObject *meth_QgsGraphEdge_toVertex(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphEdge_toVertex(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraphEdge *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphEdge, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->toVertex();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphEdge, sipName_toVertex, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsGraphEdge_fromVertex, "fromVertex(self) -> int\n"
"Returns the index of the vertex at the start of this edge.\n"
"\n"
".. seealso:: :py:func:`toVertex`");

extern "C" {static PyObject *meth_QgsGraphEdge_fromVertex(PyObject *, PyObject *);}
static PyObject *meth_QgsGraphEdge_fromVertex(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsGraphEdge *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsGraphEdge, &sipCpp))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->fromVertex();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsGraphEdge, sipName_fromVertex, NULL);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsGraphEdge(void *, int);}
static void release_QgsGraphEdge(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::QgsGraphEdge *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_QgsGraphEdge(void *, SIP_SSIZE_T, void *);}
static void assign_QgsGraphEdge(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::QgsGraphEdge *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::QgsGraphEdge *>(sipSrc);
}


extern "C" {static void *array_QgsGraphEdge(SIP_SSIZE_T);}
static void *array_QgsGraphEdge(SIP_SSIZE_T sipNrElem)
{
    return new  ::QgsGraphEdge[sipNrElem];
}


extern "C" {static void *copy_QgsGraphEdge(const void *, SIP_SSIZE_T);}
static void *copy_QgsGraphEdge(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::QgsGraphEdge(reinterpret_cast<const  ::QgsGraphEdge *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_QgsGraphEdge(sipSimpleWrapper *);}
static void dealloc_QgsGraphEdge(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsGraphEdge(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_QgsGraphEdge(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsGraphEdge(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::QgsGraphEdge *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraphEdge();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    {
        const  ::QgsGraphEdge* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsGraphEdge, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new  ::QgsGraphEdge(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QgsGraphEdge[] = {
    {SIP_MLNAME_CAST(sipName_cost), (PyCFunction)meth_QgsGraphEdge_cost, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsGraphEdge_cost)},
    {SIP_MLNAME_CAST(sipName_fromVertex), meth_QgsGraphEdge_fromVertex, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphEdge_fromVertex)},
    {SIP_MLNAME_CAST(sipName_strategies), meth_QgsGraphEdge_strategies, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphEdge_strategies)},
    {SIP_MLNAME_CAST(sipName_toVertex), meth_QgsGraphEdge_toVertex, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsGraphEdge_toVertex)}
};

PyDoc_STRVAR(doc_QgsGraphEdge, "QgsGraphEdge()\n"
"Constructor for QgsGraphEdge.\n"
"\n"
"QgsGraphEdge(QgsGraphEdge)\n"
"\n"
"This class implements a graph edge\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsGraphEdge = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsGraphEdge = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsGraphEdge,
        {0},
        &plugin_QgsGraphEdge
    },
    {
        sipNameNr_QgsGraphEdge,
        {0, 0, 1},
        4, methods_QgsGraphEdge,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsGraphEdge,
    -1,
    -1,
    0,
    0,
    init_type_QgsGraphEdge,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsGraphEdge,
    assign_QgsGraphEdge,
    array_QgsGraphEdge,
    copy_QgsGraphEdge,
    release_QgsGraphEdge,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 22 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgstininterpolator.sip"
#include "qgstininterpolator.h"
#line 9124 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9128 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 9131 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 9134 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 21 "core/auto_generated/qgsfeaturesink.sip"
#include "qgsfeaturesink.h"
#line 9137 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 28 "core/auto_generated/qgsfields.sip"
#include "qgsfields.h"
#line 9140 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 9143 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsTinInterpolator : public  ::QgsTinInterpolator
{
public:
    sipQgsTinInterpolator(const QList< ::QgsInterpolator::LayerData>&, ::QgsTinInterpolator::TinInterpolation, ::QgsFeedback*);
    sipQgsTinInterpolator(const  ::QgsTinInterpolator&);
    virtual ~sipQgsTinInterpolator();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::QgsInterpolator::Result sipProtect_cacheBaseData( ::QgsFeedback*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int interpolatePoint(double,double,double&, ::QgsFeedback*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsTinInterpolator(const sipQgsTinInterpolator &);
    sipQgsTinInterpolator &operator = (const sipQgsTinInterpolator &);

    char sipPyMethods[1];
};

sipQgsTinInterpolator::sipQgsTinInterpolator(const QList< ::QgsInterpolator::LayerData>& a0, ::QgsTinInterpolator::TinInterpolation a1, ::QgsFeedback*a2):  ::QgsTinInterpolator(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsTinInterpolator::sipQgsTinInterpolator(const  ::QgsTinInterpolator& a0):  ::QgsTinInterpolator(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsTinInterpolator::~sipQgsTinInterpolator()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipQgsTinInterpolator::interpolatePoint(double a0,double a1,double& a2, ::QgsFeedback*a3)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_interpolatePoint);

    if (!sipMeth)
        return  ::QgsTinInterpolator::interpolatePoint(a0,a1,a2,a3);

    extern int sipVH__analysis_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, double,double,double&, ::QgsFeedback*);

    return sipVH__analysis_14(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

 ::QgsInterpolator::Result sipQgsTinInterpolator::sipProtect_cacheBaseData( ::QgsFeedback*a0)
{
    return  ::QgsInterpolator::cacheBaseData(a0);
}


PyDoc_STRVAR(doc_QgsTinInterpolator_cacheBaseData, "cacheBaseData(self, feedback: QgsFeedback = None) -> QgsInterpolator.Result\n"
"Caches the vertex and value data from the provider. All the vertex data\n"
"will be held in virtual memory.\n"
"\n"
"An optional ``feedback`` argument may be specified to allow cancellation and\n"
"progress reports from the cache operation.\n"
"\n"
":return: Success in case of success");

extern "C" {static PyObject *meth_QgsTinInterpolator_cacheBaseData(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsTinInterpolator_cacheBaseData(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
        sipQgsTinInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsTinInterpolator, &sipCpp, sipType_QgsFeedback, &a0))
        {
             ::QgsInterpolator::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_cacheBaseData(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsInterpolator_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsTinInterpolator, sipName_cacheBaseData, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsTinInterpolator_interpolatePoint, "interpolatePoint(self, x: float, y: float, feedback: QgsFeedback) -> Tuple[int, float]");

extern "C" {static PyObject *meth_QgsTinInterpolator_interpolatePoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsTinInterpolator_interpolatePoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        double a0;
        double a1;
        double a2;
         ::QgsFeedback* a3;
         ::QgsTinInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BddJ8", &sipSelf, sipType_QgsTinInterpolator, &sipCpp, &a0, &a1, sipType_QgsFeedback, &a3))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsTinInterpolator::interpolatePoint(a0,a1,a2,a3) : sipCpp->interpolatePoint(a0,a1,a2,a3));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(id)",sipRes,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsTinInterpolator, sipName_interpolatePoint, doc_QgsTinInterpolator_interpolatePoint);

    return NULL;
}


PyDoc_STRVAR(doc_QgsTinInterpolator_triangulationFields, "triangulationFields() -> QgsFields\n"
"Returns the fields output by features when saving the triangulation.\n"
"These fields should be used when creating\n"
"a suitable feature sink for setTriangulationSink()\n"
"\n"
".. seealso:: :py:func:`setTriangulationSink`\n"
"\n"
".. versionadded:: 3.0");

extern "C" {static PyObject *meth_QgsTinInterpolator_triangulationFields(PyObject *, PyObject *);}
static PyObject *meth_QgsTinInterpolator_triangulationFields(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::QgsFields*sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = new  ::QgsFields( ::QgsTinInterpolator::triangulationFields());
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_QgsFields,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsTinInterpolator, sipName_triangulationFields, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsTinInterpolator_setTriangulationSink, "setTriangulationSink(self, sink: QgsFeatureSink)\n"
"Sets the optional ``sink`` for saving the triangulation features.\n"
"\n"
"The sink must be setup to accept LineString features, with fields matching\n"
"those returned by triangulationFields().\n"
"\n"
".. seealso:: :py:func:`triangulationFields`\n"
"\n"
".. versionadded:: 3.0");

extern "C" {static PyObject *meth_QgsTinInterpolator_setTriangulationSink(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsTinInterpolator_setTriangulationSink(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeatureSink* a0;
         ::QgsTinInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sink,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_QgsTinInterpolator, &sipCpp, sipType_QgsFeatureSink, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setTriangulationSink(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsTinInterpolator, sipName_setTriangulationSink, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsTinInterpolator(void *, const sipTypeDef *);}
static void *cast_QgsTinInterpolator(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsTinInterpolator *sipCpp = reinterpret_cast< ::QgsTinInterpolator *>(sipCppV);

    if (targetType == sipType_QgsInterpolator)
        return static_cast< ::QgsInterpolator *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsTinInterpolator(void *, int);}
static void release_QgsTinInterpolator(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsTinInterpolator *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsTinInterpolator *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsTinInterpolator(sipSimpleWrapper *);}
static void dealloc_QgsTinInterpolator(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsTinInterpolator *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsTinInterpolator(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsTinInterpolator(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsTinInterpolator(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsTinInterpolator *sipCpp = 0;

    {
        const QList< ::QgsInterpolator::LayerData>* a0;
        int a0State = 0;
         ::QgsTinInterpolator::TinInterpolation a1 =  ::QgsTinInterpolator::Linear;
         ::QgsFeedback* a2 = 0;

        static const char *sipKwdList[] = {
            sipName_inputData,
            sipName_interpolation,
            sipName_feedback,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|EJ8", sipType_QList_0100QgsInterpolator_LayerData,&a0, &a0State, sipType_QgsTinInterpolator_TinInterpolation, &a1, sipType_QgsFeedback, &a2))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsTinInterpolator(*a0,a1,a2);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QList< ::QgsInterpolator::LayerData> *>(a0),sipType_QList_0100QgsInterpolator_LayerData,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QList< ::QgsInterpolator::LayerData> *>(a0),sipType_QList_0100QgsInterpolator_LayerData,a0State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsTinInterpolator* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsTinInterpolator, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsTinInterpolator(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsTinInterpolator[] = {{53, 255, 1}};


static PyMethodDef methods_QgsTinInterpolator[] = {
    {SIP_MLNAME_CAST(sipName_cacheBaseData), (PyCFunction)meth_QgsTinInterpolator_cacheBaseData, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_interpolatePoint), (PyCFunction)meth_QgsTinInterpolator_interpolatePoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsTinInterpolator_interpolatePoint)},
    {SIP_MLNAME_CAST(sipName_setTriangulationSink), (PyCFunction)meth_QgsTinInterpolator_setTriangulationSink, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsTinInterpolator_setTriangulationSink)},
    {SIP_MLNAME_CAST(sipName_triangulationFields), meth_QgsTinInterpolator_triangulationFields, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsTinInterpolator_triangulationFields)}
};

static sipEnumMemberDef enummembers_QgsTinInterpolator[] = {
    {sipName_CloughTocher, static_cast<int>( ::QgsTinInterpolator::CloughTocher), 87},
    {sipName_Linear, static_cast<int>( ::QgsTinInterpolator::Linear), 87},
};

PyDoc_STRVAR(doc_QgsTinInterpolator, "QgsTinInterpolator(inputData: Iterable[QgsInterpolator.LayerData], interpolation: QgsTinInterpolator.TinInterpolation = QgsTinInterpolator.Linear, feedback: QgsFeedback = None)\n"
"Constructor for QgsTinInterpolator.\n"
"The ``feedback`` object specifies an optional QgsFeedback object for progress reports and cancellation support.\n"
"Ownership of ``feedback`` is not transferred and callers must ensure that it exists for the lifetime of this object.\n"
"\n"
"QgsTinInterpolator(QgsTinInterpolator)\n"
"\n"
"Interpolation in a triangular irregular network\n"
"\n"
".. versionadded:: 3.0");


static pyqt5ClassPluginDef plugin_QgsTinInterpolator = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsTinInterpolator = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsTinInterpolator,
        {0},
        &plugin_QgsTinInterpolator
    },
    {
        sipNameNr_QgsTinInterpolator,
        {0, 0, 1},
        4, methods_QgsTinInterpolator,
        2, enummembers_QgsTinInterpolator,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsTinInterpolator,
    -1,
    -1,
    supers_QgsTinInterpolator,
    0,
    init_type_QgsTinInterpolator,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsTinInterpolator,
    0,
    0,
    0,
    release_QgsTinInterpolator,
    cast_QgsTinInterpolator,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 19 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsidwinterpolator.sip"
#include "qgsidwinterpolator.h"
#line 9612 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"

#line 38 "/usr/share/sip/PyQt5/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 9616 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 9619 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 35 "core/auto_generated/qgsfeedback.sip"
#include "qgsfeedback.h"
#line 9622 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"
#line 41 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/auto_generated/interpolation/qgsinterpolator.sip"
#include "qgsinterpolator.h"
#line 9625 "/home/guangping/dev/cpp/GIT/QGIS/python/analysis/sip_analysispart1.cpp"


class sipQgsIDWInterpolator : public  ::QgsIDWInterpolator
{
public:
    sipQgsIDWInterpolator(const QList< ::QgsInterpolator::LayerData>&);
    sipQgsIDWInterpolator(const  ::QgsIDWInterpolator&);
    virtual ~sipQgsIDWInterpolator();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::QgsInterpolator::Result sipProtect_cacheBaseData( ::QgsFeedback*);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int interpolatePoint(double,double,double&, ::QgsFeedback*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQgsIDWInterpolator(const sipQgsIDWInterpolator &);
    sipQgsIDWInterpolator &operator = (const sipQgsIDWInterpolator &);

    char sipPyMethods[1];
};

sipQgsIDWInterpolator::sipQgsIDWInterpolator(const QList< ::QgsInterpolator::LayerData>& a0):  ::QgsIDWInterpolator(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsIDWInterpolator::sipQgsIDWInterpolator(const  ::QgsIDWInterpolator& a0):  ::QgsIDWInterpolator(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQgsIDWInterpolator::~sipQgsIDWInterpolator()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipQgsIDWInterpolator::interpolatePoint(double a0,double a1,double& a2, ::QgsFeedback*a3)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_interpolatePoint);

    if (!sipMeth)
        return  ::QgsIDWInterpolator::interpolatePoint(a0,a1,a2,a3);

    extern int sipVH__analysis_14(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, double,double,double&, ::QgsFeedback*);

    return sipVH__analysis_14(sipGILState, sipImportedVirtErrorHandlers__analysis_QtCore[0].iveh_handler, sipPySelf, sipMeth, a0, a1, a2, a3);
}

 ::QgsInterpolator::Result sipQgsIDWInterpolator::sipProtect_cacheBaseData( ::QgsFeedback*a0)
{
    return  ::QgsInterpolator::cacheBaseData(a0);
}


PyDoc_STRVAR(doc_QgsIDWInterpolator_cacheBaseData, "cacheBaseData(self, feedback: QgsFeedback = None) -> QgsInterpolator.Result\n"
"Caches the vertex and value data from the provider. All the vertex data\n"
"will be held in virtual memory.\n"
"\n"
"An optional ``feedback`` argument may be specified to allow cancellation and\n"
"progress reports from the cache operation.\n"
"\n"
":return: Success in case of success");

extern "C" {static PyObject *meth_QgsIDWInterpolator_cacheBaseData(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsIDWInterpolator_cacheBaseData(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::QgsFeedback* a0 = 0;
        sipQgsIDWInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_QgsIDWInterpolator, &sipCpp, sipType_QgsFeedback, &a0))
        {
             ::QgsInterpolator::Result sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->sipProtect_cacheBaseData(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_QgsInterpolator_Result);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsIDWInterpolator, sipName_cacheBaseData, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsIDWInterpolator_interpolatePoint, "interpolatePoint(self, x: float, y: float, feedback: QgsFeedback = None) -> Tuple[int, float]");

extern "C" {static PyObject *meth_QgsIDWInterpolator_interpolatePoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsIDWInterpolator_interpolatePoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        double a0;
        double a1;
        double a2;
         ::QgsFeedback* a3 = 0;
         ::QgsIDWInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_feedback,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd|J8", &sipSelf, sipType_QgsIDWInterpolator, &sipCpp, &a0, &a1, sipType_QgsFeedback, &a3))
        {
            int sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = (sipSelfWasArg ? sipCpp-> ::QgsIDWInterpolator::interpolatePoint(a0,a1,a2,a3) : sipCpp->interpolatePoint(a0,a1,a2,a3));
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return sipBuildResult(0,"(id)",sipRes,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsIDWInterpolator, sipName_interpolatePoint, doc_QgsIDWInterpolator_interpolatePoint);

    return NULL;
}


PyDoc_STRVAR(doc_QgsIDWInterpolator_setDistanceCoefficient, "setDistanceCoefficient(self, coefficient: float)\n"
"Sets the distance ``coefficient``, the parameter that sets how the values are\n"
"weighted with distance. Smaller values mean sharper peaks at the data points.\n"
"\n"
"Point values are weighted by 1 / ( distance ^ coefficient ).\n"
"\n"
".. seealso:: :py:func:`distanceCoefficient`\n"
"\n"
".. versionadded:: 3.0");

extern "C" {static PyObject *meth_QgsIDWInterpolator_setDistanceCoefficient(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QgsIDWInterpolator_setDistanceCoefficient(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::QgsIDWInterpolator *sipCpp;

        static const char *sipKwdList[] = {
            sipName_coefficient,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_QgsIDWInterpolator, &sipCpp, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp->setDistanceCoefficient(a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsIDWInterpolator, sipName_setDistanceCoefficient, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_QgsIDWInterpolator_distanceCoefficient, "distanceCoefficient(self) -> float\n"
"Returns the distance coefficient, the parameter that sets how the values are\n"
"weighted with distance. Smaller values mean sharper peaks at the data points.\n"
"The default is a coefficient of 2.\n"
"\n"
"Point values are weighted by 1 / ( distance ^ coefficient ).\n"
"\n"
".. seealso:: :py:func:`setDistanceCoefficient`\n"
"\n"
".. versionadded:: 3.0");

extern "C" {static PyObject *meth_QgsIDWInterpolator_distanceCoefficient(PyObject *, PyObject *);}
static PyObject *meth_QgsIDWInterpolator_distanceCoefficient(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QgsIDWInterpolator *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QgsIDWInterpolator, &sipCpp))
        {
            double sipRes;

            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipRes = sipCpp->distanceCoefficient();
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QgsIDWInterpolator, sipName_distanceCoefficient, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_QgsIDWInterpolator(void *, const sipTypeDef *);}
static void *cast_QgsIDWInterpolator(void *sipCppV, const sipTypeDef *targetType)
{
     ::QgsIDWInterpolator *sipCpp = reinterpret_cast< ::QgsIDWInterpolator *>(sipCppV);

    if (targetType == sipType_QgsInterpolator)
        return static_cast< ::QgsInterpolator *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_QgsIDWInterpolator(void *, int);}
static void release_QgsIDWInterpolator(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipQgsIDWInterpolator *>(sipCppV);
    else
        delete reinterpret_cast< ::QgsIDWInterpolator *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_QgsIDWInterpolator(sipSimpleWrapper *);}
static void dealloc_QgsIDWInterpolator(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQgsIDWInterpolator *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QgsIDWInterpolator(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QgsIDWInterpolator(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QgsIDWInterpolator(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipQgsIDWInterpolator *sipCpp = 0;

    {
        const QList< ::QgsInterpolator::LayerData>* a0;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_layerData,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1", sipType_QList_0100QgsInterpolator_LayerData,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsIDWInterpolator(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

            sipReleaseType(const_cast<QList< ::QgsInterpolator::LayerData> *>(a0),sipType_QList_0100QgsInterpolator_LayerData,a0State);
                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast<QList< ::QgsInterpolator::LayerData> *>(a0),sipType_QList_0100QgsInterpolator_LayerData,a0State);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::QgsIDWInterpolator* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_QgsIDWInterpolator, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            try
            {
            sipCpp = new sipQgsIDWInterpolator(*a0);
            }
            catch (...)
            {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_QgsIDWInterpolator[] = {{53, 255, 1}};


static PyMethodDef methods_QgsIDWInterpolator[] = {
    {SIP_MLNAME_CAST(sipName_cacheBaseData), (PyCFunction)meth_QgsIDWInterpolator_cacheBaseData, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_distanceCoefficient), meth_QgsIDWInterpolator_distanceCoefficient, METH_VARARGS, SIP_MLDOC_CAST(doc_QgsIDWInterpolator_distanceCoefficient)},
    {SIP_MLNAME_CAST(sipName_interpolatePoint), (PyCFunction)meth_QgsIDWInterpolator_interpolatePoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsIDWInterpolator_interpolatePoint)},
    {SIP_MLNAME_CAST(sipName_setDistanceCoefficient), (PyCFunction)meth_QgsIDWInterpolator_setDistanceCoefficient, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QgsIDWInterpolator_setDistanceCoefficient)}
};

PyDoc_STRVAR(doc_QgsIDWInterpolator, "QgsIDWInterpolator(layerData: Iterable[QgsInterpolator.LayerData])\n"
"Constructor for QgsIDWInterpolator, with the specified ``layerData`` sources.\n"
"\n"
"QgsIDWInterpolator(QgsIDWInterpolator)\n"
"\n"
"Inverse distance weight interpolator.");


static pyqt5ClassPluginDef plugin_QgsIDWInterpolator = {
    0,
    0,
    0,
    0
};


sipClassTypeDef sipTypeDef__analysis_QgsIDWInterpolator = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QgsIDWInterpolator,
        {0},
        &plugin_QgsIDWInterpolator
    },
    {
        sipNameNr_QgsIDWInterpolator,
        {0, 0, 1},
        4, methods_QgsIDWInterpolator,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QgsIDWInterpolator,
    -1,
    -1,
    supers_QgsIDWInterpolator,
    0,
    init_type_QgsIDWInterpolator,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QgsIDWInterpolator,
    0,
    0,
    0,
    release_QgsIDWInterpolator,
    cast_QgsIDWInterpolator,
    0,
    0,
    0,
    0,
    0,
    0
};
